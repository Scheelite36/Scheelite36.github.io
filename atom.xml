<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只柑の博客</title>
  
  
  <link href="http://123.57.158.5/atom.xml" rel="self"/>
  
  <link href="http://123.57.158.5/"/>
  <updated>2023-05-08T16:20:25.712Z</updated>
  <id>http://123.57.158.5/</id>
  
  <author>
    <name>一只柑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>develop test</title>
    <link href="http://123.57.158.5/2023/04/18/develop-test/"/>
    <id>http://123.57.158.5/2023/04/18/develop-test/</id>
    <published>2023-04-18T15:44:37.000Z</published>
    <updated>2023-05-08T16:20:25.712Z</updated>
    
    <content type="html"><![CDATA[<p>基于mockito-inline 和 junit-jupiter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-inline&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol><li><p>定义对象阶段</p><ul><li>定义测试对象</li><li>模拟依赖对象（类成员）</li><li>注入依赖对象（类成员）</li></ul></li><li><p>模拟方法阶段</p><ul><li>模拟依赖对象（参数或返回值）</li><li>模拟依赖方法</li></ul></li><li><p>调用方法阶段</p><ul><li>模拟依赖对象（参数）</li><li>调用测试方法</li><li>验证数据对象（返回值）</li></ul></li><li><p>验证方法阶段</p><ul><li><p>验证依赖方法</p></li><li><p>验证数据对象（参数）</p></li><li><p>验证依赖对象</p></li></ul></li></ol><h3 id="定义测试对象"><a href="#定义测试对象" class="headerlink" title="定义测试对象"></a>定义测试对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 直接构造对象</span></span><br><span class="line">UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line"><span class="comment">// 2. 利用Mockito.spy方法</span></span><br><span class="line">UserService userService = Mockito.spy(UserService.class);</span><br><span class="line"><span class="comment">// 3. 利用@Spy注解</span></span><br><span class="line"><span class="meta">@Spy</span></span><br><span class="line"><span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line"><span class="comment">// 4. 利用InjectMocks注解</span></span><br><span class="line"><span class="meta">@InjectMocks</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><h3 id="模拟依赖对象"><a href="#模拟依赖对象" class="headerlink" title="模拟依赖对象"></a>模拟依赖对象</h3><p>需要模拟依赖对象——类成员变量、方法参数和方法返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 直接构建对象</span></span><br><span class="line">UserDao user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">List&lt;Long&gt; userList = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 反序列化对象</span></span><br><span class="line">UserDao user = Json.parseObject(text, UserDao.class);</span><br><span class="line">List&lt;UserDao&gt; userList = Json.parseArray(text, UserDao.class);</span><br><span class="line">Map&lt;Long, UserDao&gt; userMap = Json.parseObject(text, <span class="keyword">new</span> TypeReference&lt;Map&lt;Long, UserDao&gt;&gt;()&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 利用Mockito.mock方法</span></span><br><span class="line">MockCalss mockClass = Mockito.mock(MockClass.class);</span><br><span class="line">List&lt;Long&gt; userIdList = (List&lt;Long&gt;)Mockito.mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 利用@Mock 注解</span></span><br><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> MockDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 利用Spy方法</span></span><br><span class="line">UserService userService = Mockito.spy(<span class="keyword">new</span> UserService());</span><br><span class="line">AbstractOssService ossService = Mockito.spy(AbstractOssService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 利用@Spy注解</span></span><br><span class="line"><span class="meta">@Spy</span></span><br><span class="line"><span class="keyword">private</span> Uservice userService = <span class="keyword">new</span> UserService(); <span class="comment">// 必须初始化</span></span><br></pre></td></tr></table></figure><p>Spy可以使用真实方法，Mock全部都是模拟方法</p><h3 id="注入依赖对象"><a href="#注入依赖对象" class="headerlink" title="注入依赖对象"></a>注入依赖对象</h3><p>需注入各种依赖对象——类成员变量或静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用Setter方法注入</span></span><br><span class="line">userService.setMaxCount(<span class="number">100</span>);</span><br><span class="line">userService.setUserDao(userDao);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用ReflectionTestUtils.setField方法注入</span></span><br><span class="line">ReflectionTestUtils.setField(userService, <span class="string">&quot;maxCount&quot;</span>, <span class="number">100</span>);</span><br><span class="line">ReflectionTestUtils.setField(userService, <span class="string">&quot;userDao&quot;</span>, userDao);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用@InjectMocks 注解注入 dao是service中的成员变量</span></span><br><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="meta">@InjectMocks</span></span><br><span class="line"><span class="keyword">private</span> UserService userservice = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模拟依赖方法"><a href="#模拟依赖方法" class="headerlink" title="模拟依赖方法"></a>模拟依赖方法</h3><p>需要模拟方法指定参数返回对应值</p><h4 id="根据-返回-参数-模拟方法"><a href="#根据-返回-参数-模拟方法" class="headerlink" title="根据 返回/参数 模拟方法"></a>根据 返回/参数 模拟方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟无返回值方法</span></span><br><span class="line">Mockito.doNothing().when(userDao).delete(userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟方法设置返回值</span></span><br><span class="line">Mockito.when(userDao.get(userId)).thenReturn(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟方法多个返回值 适用于对方法的多次调用后参数返回</span></span><br><span class="line">Mockito.when(userMapper.updateByPrimaryKeySelective(Mockito.any())).thenReturn(<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟方法抛出异常</span></span><br><span class="line">when(userMapper.deleteByPrimaryKey(Mockito.anyLong())).thenThrow(<span class="keyword">new</span> OrangeMallException());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用真实方法</span></span><br><span class="line">when(userService.getUser(userId)).thenCallRealMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟静态方法 之后直接使用when进行模拟</span></span><br><span class="line">mockStatic(MD5EncodeUtils.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 灵活根据返回结果</span></span><br><span class="line">when(MD5EncodeUtils.getMD5Str(Mockito.anyString())).thenAnswer(input -&gt;&#123;</span><br><span class="line">  String arg = input.getArgument(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> arg.length() % <span class="number">2</span> == <span class="number">0</span> ? <span class="keyword">null</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>私有方法的mock可以采用放射方式</p><h3 id="调用被测方法"><a href="#调用被测方法" class="headerlink" title="调用被测方法"></a>调用被测方法</h3><p>有权限的直接调用方法即可，私有方法通过反射调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method method = service.getClass().getDeclaredMethod(&quot;privateMethod&quot;, Integer.class);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line">Object invoke = method.invoke(service, 1);</span><br></pre></td></tr></table></figure><h3 id="验证依赖方法"><a href="#验证依赖方法" class="headerlink" title="验证依赖方法"></a>验证依赖方法</h3><p>验证时确认模拟的依赖方法是否按照预期结果被调用或未被调用的过程</p><h4 id="根据参数验证方法调用（调用1次）"><a href="#根据参数验证方法调用（调用1次）" class="headerlink" title="根据参数验证方法调用（调用1次）"></a>根据参数验证方法调用（调用1次）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证无参方法调用</span></span><br><span class="line">Mockito.verify(userDao).deleteAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证指定参数调用</span></span><br><span class="line">Mockito.verify(userDao).delete(userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证任意参数方法调用</span></span><br><span class="line">Mockito.verify(userDao).delete(Mockito.anyLong());</span><br><span class="line">Mockito.verify(userDao).delete(Mockito.any(Long.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证可空/必空参数方法调用</span></span><br><span class="line">Mockito.verify(userDao).queryCompany(Mockito.nullable(Long.class), Mockito.isNull());</span><br></pre></td></tr></table></figure><h4 id="验证方法调用次数-超时"><a href="#验证方法调用次数-超时" class="headerlink" title="验证方法调用次数/ 超时"></a>验证方法调用次数/ 超时</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mockito.verify(userDao, Mockito.never()).deleteAll();</span><br><span class="line">Mockito.verify(userDao, Mockito.times(n)).deleteAll();</span><br><span class="line">Mockito.verify(userDao, Mockito.atLeast(n)).deleteAll();</span><br><span class="line"></span><br><span class="line">Mockito.verify(userDao, timeout(<span class="number">100</span>)).verifyUser();</span><br></pre></td></tr></table></figure><h4 id="验证方法调用并捕获参数"><a href="#验证方法调用并捕获参数" class="headerlink" title="验证方法调用并捕获参数"></a>验证方法调用并捕获参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Argument.forClass 方法定义参数捕获器</span></span><br><span class="line">ArgumentCaptor&lt;User&gt; userCaptor = ArgumentCaptor.forClass(User.class);</span><br><span class="line">Mockito.verify(userDao).modify(userCaptor.capture());</span><br><span class="line">User user = userCaptor.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用@Captor 注解定义参数捕获器</span></span><br><span class="line"><span class="meta">@Captor</span></span><br><span class="line"><span class="keyword">private</span> ArgumentCaptor&lt;User&gt; userCaptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获多次调用的参数列表</span></span><br><span class="line">ArgumentCaptor&lt;User&gt; userCaptor = ArgumentCaptor.forClass(User.class);</span><br><span class="line">Mockito.verify(userDao, Mockito.atLeastOnce()).modify(userCaptor.capture());</span><br><span class="line">List&lt;User&gt; userList = userCaptor.getAllValues();</span><br></pre></td></tr></table></figure><h4 id="验证其他特殊方法"><a href="#验证其他特殊方法" class="headerlink" title="验证其他特殊方法"></a>验证其他特殊方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法验证 普通方法也可以使用verify(Verfication verification)形式</span></span><br><span class="line">mockedStatic = mockStatic(MD5EncodeUtils.class);</span><br><span class="line">mockedStatic.verify(() -&gt; MD5EncodeUtils.getMD5Str(Mockito.any()));</span><br></pre></td></tr></table></figure><h3 id="验证数据对象"><a href="#验证数据对象" class="headerlink" title="验证数据对象"></a>验证数据对象</h3><img src="/2023/04/18/develop-test/image-20230419003637057.png" alt="image-20230419003637057"><img src="/2023/04/18/develop-test/image-20230419003727453.png" alt="image-20230419003727453"><p><img src="/2023/04/18/develop-test/image-20230419003916460.png" alt="image-20230419003916460"></p><p><img src="/2023/04/18/develop-test/image-20230419004007948.png" alt="image-20230419004007948"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于mockito-inline 和 junit-jupiter&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Mockito" scheme="http://123.57.158.5/tags/Mockito/"/>
    
    <category term="JUnit" scheme="http://123.57.158.5/tags/JUnit/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis二级缓存与临时表</title>
    <link href="http://123.57.158.5/2023/04/08/mybatis-temp-table-problem/"/>
    <id>http://123.57.158.5/2023/04/08/mybatis-temp-table-problem/</id>
    <published>2023-04-08T15:07:38.000Z</published>
    <updated>2023-04-09T09:39:19.782Z</updated>
    
    <content type="html"><![CDATA[<p>大概一周前，我们服务在公司生产环境出现了用户导出excel数据空白情况，现象可以具体体现为用户在某个页面进行查询，随后进行Excel导出，经常出现第一次点击导出时候Excel中只有表头，而没有数据情况，第二次点击导出后正常，日志中也无错误信息。而同样的问题在测试环境并没有复现。排查过后其实问题是Mybatis二级缓存与滥用（GAUSS）PGSQL临时表语法导致的</p><p><img src="/2023/04/08/mybatis-temp-table-problem/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p><p>我们的导出和查询分别是两个接口，实际sql语法比较复杂，查询时候需要使用临时存储一些产品BOM分解的编码，然后使用临时表中的数据进行查询操作，导出时候逻辑相同，统计之后分页进行查询导出。去掉复杂的业务逻辑，简单用代码模拟一下</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    模拟业务场景 使用临时表计算中间数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;createTmp&quot;</span>&gt;</span></span><br><span class="line">        CREATE TEMPORARY TABLE TEST_CACHE(name_col varchar(20),comment_col varchar(20)) on commit delete rows;</span><br><span class="line">                insert into TEST_CACHE VALUE (&#x27;hh&#x27;,&#x27;test&#x27;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    模拟查询结果数据总计--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectTotal&quot;</span>  <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;createTmp&quot;</span>/&gt;</span></span><br><span class="line">        select count(1) from test_cache;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    模拟查询具体结果数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectTotalRes&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.util.Map&quot;</span>&gt;</span></span><br><span class="line">        select * from test_cache;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mybatisCacheTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 第一次查询 用于产生缓存</span></span><br><span class="line">            SqlSession sqlSession = MyBatisUtils.openSession();</span><br><span class="line">            Integer count = (Integer) sqlSession.selectList(<span class="string">&quot;business_type.selectTotal&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;toal: &quot;</span>+count);</span><br><span class="line">            List&lt;Map&lt;String,String&gt;&gt; firstQuery = sqlSession.selectList(<span class="string">&quot;business_type.selectTotalRes&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;result size: &quot;</span>+firstQuery.size());</span><br><span class="line">            MyBatisUtils.closeSession(sqlSession);</span><br><span class="line">            System.out.println(sqlSession);</span><br><span class="line">            <span class="comment">// 使用另一个线程去模拟导出请求</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                SqlSession sqlSession2 = MyBatisUtils.openSession();</span><br><span class="line">                Integer countTwice = (Integer) sqlSession2.selectList(<span class="string">&quot;business_type.selectTotal&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;toal: &quot;</span>+countTwice);</span><br><span class="line">                List&lt;Map&lt;String,String&gt;&gt; secondQuery = sqlSession2.selectList(<span class="string">&quot;business_type.selectTotalRes&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;result size: &quot;</span>+secondQuery.size());</span><br><span class="line">                MyBatisUtils.closeSession(sqlSession2);</span><br><span class="line">                System.out.println(sqlSession2);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>临时表在mysql pgsql中是以会话形式存在的，如果会话关闭，临时表就被删除了。而在pgsql中创建临时表时候可以加上<code>ON COMMIT DELETE ROWS</code>让临时表在事务提交之后，删除临时表数据（这个sql是前人留下的，这个迭代上的需求是对导出部分使用分页查询减少内存占用避免oom，同时加入transactional注解让统计与查询请求都使用同一个sqlsession共享临时表，而原有的sql没有进行改动）。</p><p>查询导出的数据库处理逻辑一样。可以看到在统计总数的sql块中加入中间数据的处理，返回统计结果，同时开启了二级缓存。导出时候统计结果的sql击中了缓存而没有去生成临时表数据，但是接下来的查询sql，就查询不到临时表中的数据了，就能看到描述的现象。起初测试环境没有复现是因为将mybatis二级缓存的配置给关闭了（哭</p><p><img src="/2023/04/08/mybatis-temp-table-problem/image-20230409171917308.png" alt="image-20230409171917308"></p><p>但是还有个问题，按理来说临时表在第一次导出请求时候应该是不存在了，为什么日志中没有报错？推测是因为spring mybatis中sqlsession会将数据库会话进行复用，导致查询到了临时表只是因为on commit delete rows作用，之前的数据被清空了而已。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大概一周前，我们服务在公司生产环境出现了用户导出excel数据空白情况，现象可以具体体现为用户在某个页面进行查询，随后进行Excel导出，经常出现第一次点击导出时候Excel中只有表头，而没有数据情况，第二次点击导出后正常，日志中也无错误信息。而同样的问题在测试环境并没有复</summary>
      
    
    
    
    
    <category term="Mybatis" scheme="http://123.57.158.5/tags/Mybatis/"/>
    
    <category term="Mysql" scheme="http://123.57.158.5/tags/Mysql/"/>
    
    <category term="Pgsql" scheme="http://123.57.158.5/tags/Pgsql/"/>
    
  </entry>
  
  <entry>
    <title>分布式微服务</title>
    <link href="http://123.57.158.5/2022/05/15/micro-server/"/>
    <id>http://123.57.158.5/2022/05/15/micro-server/</id>
    <published>2022-05-15T13:09:01.000Z</published>
    <updated>2022-07-03T16:57:44.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务介绍"><a href="#微服务介绍" class="headerlink" title="微服务介绍"></a>微服务介绍</h2><p>单体应用的痛点：</p><ul><li>部署效率低下</li><li>团队协作开发成本高</li><li>系统高可用性差</li></ul><p><strong>服务化</strong></p><ul><li>把传统的单机应用中的本地方法调用，改造成通过RPC, HTTP产生的远程方法调用</li><li>把模块从单体应用中拆分出来，独立成一个服务部署</li><li>用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队做，与主模块不耦合</li></ul><h3 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h3><ul><li><p>组件以服务形式来提供</p></li><li><p>产品不是项目</p></li><li><p>轻量级通信、独立进程</p></li><li><p>分散治理、去中心化治理</p></li><li><p>容错性设计</p></li></ul><img src="/2022/05/15/micro-server/image-20220515210952337.png" alt="image-20220515210952337" style="zoom:50%;"><p>dubbo对于其他业务的实现可以通过与其他组件配合</p><p><strong>通信协议对比</strong></p><p>对于Dubbo的RPC，消耗的网络流量更小，速度更快。但是服务提供方与调用接口依赖方式太强；服务对平台敏感，难以简单复用</p><h3 id="微服务的重要模块"><a href="#微服务的重要模块" class="headerlink" title="微服务的重要模块"></a>微服务的重要模块</h3><p>服务描述 注册中心 服务框架 负载均衡 熔断和降级 网关</p><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><table><thead><tr><th>核心组件</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>服务注册中心</td><td>Spring Cloud Netflix Eureka</td></tr><tr><td>服务调用方式</td><td>REST API  Feign Ribbon</td></tr><tr><td>服务网关</td><td>Spring Cloud Netflix Zuul</td></tr><tr><td>断路器</td><td>Spring Cloud Netflix Hystrix</td></tr></tbody></table><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>Netflix子模块。服务注册发现</p><h4 id="为什么需要服务注册与发现"><a href="#为什么需要服务注册与发现" class="headerlink" title="为什么需要服务注册与发现"></a>为什么需要服务注册与发现</h4><p>因为正常的通过http调用另一个服务，那么调用方法需要记录在这个服务的配置中。如果发生了ip变化那么就变得难以维护。</p><p>改进方法就是建立一个服务注册中心，每个服务都去注册，其他服务需要时候去调用。同时也可以解决多个节点的负载均衡。</p><img src="/2022/05/15/micro-server/image-20220522180158867.png" alt="image-20220522180158867" style="zoom:50%;"><p>集群服务eureka架构</p><img src="/2022/05/15/micro-server/image-20220522180322731.png" alt="image-20220522180322731" style="zoom:50%;"><p>服务提供者需要提供上线，心跳，下线等信息。使用者只需要注册即可</p><p>使用者需要引入eureka-client 依赖</p><h4 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h4><img src="/2022/05/15/micro-server/image-20220530234000270.png" alt="image-20220530234000270" style="zoom:50%;"><p>feign就是在这第三步中起作用</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p><strong>客户端负载均衡（Ribbon）</strong> 内部服务调用时候考虑负载均衡</p><ul><li>RandomRule 随机策略</li><li>RoundRobinRule 表示轮训策略</li><li>ReponseTimeWeightedRule 加权 根据每个Server的平均响应时间动态加权</li></ul><p>通过Ribbon.NFLoadBalancerRuleClassName指定配置的负载均衡策略</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server-provider-name.ribbon.NFLoadBalancerRuleClassName</span>=<span class="string">com.netflix.loadbalancer.RandomRule;</span></span><br></pre></td></tr></table></figure><p>也可以自定义规则之后在配置中指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        List&lt;Server&gt; allServers = getLoadBalancer().getAllServers();</span><br><span class="line">        <span class="comment">// return radom server</span></span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>) (Math.random() * allServers.size());</span><br><span class="line">        <span class="keyword">return</span> allServers.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig iClientConfig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端负载均衡（Nginx）</strong></p><h4 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h4><p>场景：当某个服务出现问题，大量请求在这个服务中卡住。而其他服务的资源（比如数据库连接池）也没有被释放，从而导致了整个系统出现故障</p><p>作用：当某个服务出现问题，利用断路器将它隔离出去，避免故障的蔓延</p><p>在client端引入断路器 ，实现调用server失败后的默认业务逻辑</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启断路器</span></span><br><span class="line"><span class="meta">hystrix.metrics.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">feign.circuitbreaker.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># courselistclient是调用远端服务的接口</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseListClientHystrix</span> <span class="keyword">implements</span> <span class="title">CourseListClient</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Course&gt; <span class="title">getAllCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用远端服务失败后的处理 todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;course-list&quot;, fallback = CourseListClientHystrix.class, url = &quot;http://localhost:8081&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CourseListClient</span> </span>&#123;</span><br></pre></td></tr></table></figure><h4 id="网关Zuul"><a href="#网关Zuul" class="headerlink" title="网关Zuul"></a>网关Zuul</h4><p>为什么需要网关：</p><ul><li>登陆校验，签名校验</li><li>统一访问地址和端口</li></ul><p>api网关允许您将api请求（内部或外部）路由到正确的位置</p><img src="/2022/05/15/micro-server/image-20220704005609111.png" alt="image-20220704005609111" style="zoom: 33%;"><p>zuul</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微服务介绍&quot;&gt;&lt;a href=&quot;#微服务介绍&quot; class=&quot;headerlink&quot; title=&quot;微服务介绍&quot;&gt;&lt;/a&gt;微服务介绍&lt;/h2&gt;&lt;p&gt;单体应用的痛点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署效率低下&lt;/li&gt;
&lt;li&gt;团队协作开发成本高&lt;/li&gt;
&lt;li&gt;系</summary>
      
    
    
    
    <category term="Spring" scheme="http://123.57.158.5/categories/Spring/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>gateway连接超时错误</title>
    <link href="http://123.57.158.5/2022/05/15/gateway-connection-closed-srror/"/>
    <id>http://123.57.158.5/2022/05/15/gateway-connection-closed-srror/</id>
    <published>2022-05-15T07:30:21.000Z</published>
    <updated>2022-05-15T08:45:04.982Z</updated>
    
    <content type="html"><![CDATA[<p>在公司遇到的一个gateway问题，在请求很频繁的情况下。后台这边偶尔会出现服务器连接断开的情况。发送请求方报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;path&quot;:&quot;/xx/xx&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;Connection prematurely closed BEFORE response&quot;&#125;</span><br></pre></td></tr></table></figure><p>查看gateway发现对应报错日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response</span><br></pre></td></tr></table></figure><p>经过查找资料发现：</p><p>geteway调用后台服务，会使用httpClient连接池里的连接。其中老版本（spring cloud低于Hoxton.SR1，或者gateway低于2.2.1版本）不可以配置max-idle-time（空闲连接超时回收时间），默认为null，连接不关闭</p><p>而其他后台服务也有对应连接池参数connection-timeout（tcp连接超时时间）。当gateway与另一个服务建立连接之后，发生了后台服务等待了数十秒后关闭了，而此时后台服务就没有和gateway对应的连接了，于是发生了异常。所以服务端的connection-timeout时间需要适当大雨gateway的max-idle-time。<font color="red">就是说网关层的对后端的连接的空闲时间要小于后端服务的连接空闲时间，这样就不会获取到无效的网关层连接</font>。</p><p>此时将spring版本升级后配置max-idle-time时间后可解：</p><table><thead><tr><th>组件</th><th>版本</th><th>其他</th></tr></thead><tbody><tr><td>spring boot</td><td>2.3.4.RELEASE</td><td></td></tr><tr><td>spring cloud</td><td>Hoxton.SR1</td><td></td></tr><tr><td>spring cloud gateway</td><td>2.2.1.RELEASE</td><td></td></tr></tbody></table><h3 id="HttpMessaageConvert未注入"><a href="#HttpMessaageConvert未注入" class="headerlink" title="HttpMessaageConvert未注入"></a>HttpMessaageConvert未注入</h3><p>升级之后发现gateway启动feign组件会抛出HttpMessageConvert未注入异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feign.codec.DecodeException: No qualifying bean of type &#x27;org.springframework.boot.autoconfigure.http.HttpMessageConverters&#x27; available</span><br></pre></td></tr></table></figure><p>配置类中手动注入可解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">messageConverters</span><span class="params">(ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(converters.orderedStream().collect(Collectors.toList()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为：</p><p>spring-boot2.1.x版本是不用手动注入HttpMessageConverters的，因为可以自动配置的, 见HttpMessageConvertersAutoConfiguration。<br>但是在spring-boot2.2.x版本HttpMessageConvertersAutoConfiguration有所改动，加了个@Conditional(NotReactiveWebApplicationCondition.class) ， 因为gateway是ReactiveWeb，所以针对HttpMessageConverters的自动配置就不生效了，故需要手动注入HttpMessageConverters。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在公司遇到的一个gateway问题，在请求很频繁的情况下。后台这边偶尔会出现服务器连接断开的情况。发送请求方报错如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="Spring Boot" scheme="http://123.57.158.5/tags/Spring-Boot/"/>
    
    <category term="Gateway" scheme="http://123.57.158.5/tags/Gateway/"/>
    
  </entry>
  
  <entry>
    <title>分布式基本工具学习</title>
    <link href="http://123.57.158.5/2022/02/27/distribute/"/>
    <id>http://123.57.158.5/2022/02/27/distribute/</id>
    <published>2022-02-26T16:25:03.000Z</published>
    <updated>2022-04-24T17:22:50.116Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/02/27/distribute/image-20220227003608410.png" alt="image-20220227003608410"></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><strong>Docker</strong> 是一个用来装程序及其环境的容器，属于Linux容器的一种封装，提供简单易用的容器使用接口。是目前最流行的linux容器解决方案。</p><h3 id="为什么需要docker"><a href="#为什么需要docker" class="headerlink" title="为什么需要docker"></a>为什么需要docker</h3><ul><li>环境配置的难题</li><li>虚拟机资源占用多 冗余多</li><li>Docker的基础——Linux容器</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>提供统一的环境</li><li>提供快速拓展、弹性伸缩的云服务</li><li>防止其他用户的进程把服务器资源占用过多，隔离</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>标准化</p><p>运输方式（把程序和环境从一个机器运到另一个机器）</p><p>存储方式（程序和环境的存储）</p><p>API接口（不需要Tomcat等应用的命令，都标准化了）</p></li><li><p>灵活：即使是最复杂的应用也可以集装箱化</p></li><li><p>轻量级：容器利用并共享主机内核</p></li><li><p>便携式：可以在本地构建，部署到云，并在任何地方运行</p></li></ul><h3 id="Docker组成、架构等"><a href="#Docker组成、架构等" class="headerlink" title="Docker组成、架构等"></a>Docker组成、架构等</h3><img src="/2022/02/27/distribute/image-20220303003957879.png" alt="image-20220303003957879" style="zoom:50%;"><p><strong>image镜像</strong></p><p>存储：联合文件，UnionFS</p><p>把不同的目录放到同一个虚拟的文件系统下</p><img src="/2022/02/27/distribute/image-20220303004247535.png" alt="image-20220303004247535" style="zoom:50%;"><img src="/2022/02/27/distribute/image-20220303004419133.png" alt="image-20220303004419133" style="zoom:50%;"><p>将环境/软件进行分层。往往是在别的层之上开发image</p><p><strong>容器</strong></p><p>镜像类似于Java中的类，容器类似于实例；容器层可以被修改，而镜像不可以被修改；一个镜像可以生成多个容器，容器之间没有任何的干扰。</p><p><a href="hub.docker.com">官方仓库</a></p><p><strong>client</strong> 提供给用户一个终端，用户输入Docker提供的命令来管理本地或远程的服务器</p><p><strong>deamon</strong> 服务端守护进程，接收Client发送的命令并执行相应的操作</p><img src="/2022/02/27/distribute/image-20220303005526922.png" alt="image-20220303005526922" style="zoom:50%;"><h3 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 下载镜像</span><br><span class="line">docker pull [options] name[:tag]</span><br><span class="line"># 显示本机镜像</span><br><span class="line">docker images [options] [repository[:tag]]</span><br><span class="line"># 运行镜像</span><br><span class="line">docker run [options] image [command] [args]</span><br><span class="line"># 查看容器</span><br><span class="line">docker ps</span><br><span class="line"># 访问容器内部</span><br><span class="line">docker exec [options] container command [args]</span><br><span class="line"># 关闭容器</span><br><span class="line">docker stop [options] container_id</span><br><span class="line">docker kill container_id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例：docker exec -it 444 bash</p><p>把容器（id444开头）内部终端映射到当前终端，对容器内部进行访问</p><h3 id="Docker的网络模式"><a href="#Docker的网络模式" class="headerlink" title="Docker的网络模式"></a>Docker的网络模式</h3><ul><li><p>Bridge</p><p>最常用。获得独立的网络 通过bridge与外部进行映射</p><p><code>docker run -d -p 8080:80 docker/getting-started</code>将本机8080端口映射到容器的80端口，-d后台运行</p><p><code>-P</code> 可以将容器内部的所有端口全部进行随机映射 到本机</p></li><li><p>Host</p><p>不需要获得独立的网络 端口</p></li><li><p>None</p><p>无网络</p></li></ul><h3 id="DockerFile实践"><a href="#DockerFile实践" class="headerlink" title="DockerFile实践"></a>DockerFile实践</h3><p>通过dockerfile来管理环境，写自己的dockerfile。</p><p>dockerfile（名称一致）文件的基本内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 获取基础镜像</span><br><span class="line">FROM alpine:latest</span><br><span class="line"># 维护者</span><br><span class="line">MAINTAINER scheelite</span><br><span class="line"># 自己dockerfile具体内容</span><br><span class="line">CMD echo &quot;hello my dockerfile&quot;</span><br></pre></td></tr></table></figure><p>制作image（当前路径）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hello_docker .</span><br></pre></td></tr></table></figure><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ul><li><p>Http反向代理</p><p>首先正向代理是什么？客户端 -&gt; 代理服务器 -&gt; 互联网。例如需要代理访问外网（被墙），保护隐私和具有安全性的访问</p><p><img src="/2022/02/27/distribute/305504-20161112124853014-1532060796.png" alt="img"></p><p>方向代理是对于服务端而言，作用可以是提供负载均衡，将压力进行分配；提供资源缓存等</p><p><img src="/2022/02/27/distribute/image-20220309003553007.png" alt="image-20220309003553007"></p><p>nginx就是起到反向代理的作用</p></li><li><p>动静态资源分离</p><p>需要动静态资源分离时候，静态资源无需tomcat，Tomcat只负责处理动态请求，nginx可以直接获取到当前请求的文件并返回</p><p>另外，nginx可以直接作为静态资源服务器</p></li></ul><p>优点是 1. 高并发、高性能 2. 可扩展性好 3. 可靠性高 4. 热部署 5. 开源、可商用</p><h3 id="命令与配置文件"><a href="#命令与配置文件" class="headerlink" title="命令与配置文件"></a>命令与配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nginx -c 修改配置文件</span><br><span class="line">nginx -s stop 立即停止</span><br><span class="line">nginx -s quit 优雅停止</span><br><span class="line">nginx -s reload 重启</span><br><span class="line">nginx -t 测试配置文件/显示当前配置文件</span><br></pre></td></tr></table></figure><p>配置文件语法：</p><p>打括号包含很多指令</p><p>include 引入，# 注释，$变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">cat nginx.conf</span><br><span class="line"></span><br><span class="line"># 运行用户，默认是nginx</span><br><span class="line">user  nginx;</span><br><span class="line"># nginx进程数,一般设置为和cpu核数一样</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 全局错误日志路径</span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line"># 进程pid路径</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line"># 最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置http服务器</span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"># 设置日志的格式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"># 访问日志的路径</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line"># 开启高效传输模式</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"># 长连接超时时间，单位是秒</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">#传输时是否压缩，压缩的话需要解压，但是传的大小就小了</span><br><span class="line">    #gzip  on;</span><br><span class="line">#加载其他的配置文件，一带多</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认配置 default.cofig内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"># 端口 服务名</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line"># 访问路径</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 错误转发路径</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>核心思想：接受并转发消息。可以把它想象成邮局。</p><p>关键名词 producer queue consumer </p><p><strong>消息队列</strong>：消息队列已经逐渐成为企业IT系统内部通信的核心手段，具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能</p><p><strong>特性</strong>： 业务无关；FIFO；容灾；性能 </p><p><strong>为什么要使用消息队列</strong>：1.系统模块之间解耦；2.异步调用（比如下单完成后加入队列，后面一系列平行的操作如扣款、通知用户，卖家等就直接进行分发）；3.流量削峰（将请求存入队列，以可接受速度进行分发）</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>RabbitMQ特点</strong>：开源、跨语言；Erlang语言编写；应用广泛；社区活跃；API丰富</p><p><strong>AMPQ协议</strong>：Advanced Message Queuing Protocol</p><p><img src="/2022/02/27/distribute/image-20220313204729731.png" alt="image-20220313204729731"></p><p>Virtual Host对应很多独立的使用队列的用户，生产者只需要投递，消费者只需要监听消息队列，完成解耦。Exchange和Message Queue通过路由键进行绑定</p><p><strong>RabbitMQ架构</strong>：</p><p><img src="/2022/02/27/distribute/image-20220313205135545.png" alt="image-20220313205135545"></p><ul><li>Server/Broker服务，conneciton与Server建立连接</li><li>channel信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道，message消息由properties和body组成。</li><li>Virtual host虚拟主机，顶层隔离。同一个虚拟主机下，不能有重复的交换机和queue</li><li>Exchange 交换机，接收生产者的消息，然后根据指定的Routing Key路由器去把消息转发到所绑定的队列上。bingding 绑定交换机和队列</li><li>routing key路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个流转</li><li>queue 队列，消费者只需要监听队列来消费消息，不需要关注消息来自于哪个Exchange</li><li>Exchange和Message Queue存在着绑定关系，一个Exchange可以绑定多个消息队列</li></ul><h3 id="消息流转过程"><a href="#消息流转过程" class="headerlink" title="消息流转过程"></a>消息流转过程</h3><p>生产者发送消息时候会指定routing key，用来确定去哪个MQ</p><p><img src="/2022/02/27/distribute/image-20220313210124464.png" alt="image-20220313210124464"></p><h4 id="官方安装教程地址"><a href="#官方安装教程地址" class="headerlink" title="官方安装教程地址"></a>官方安装教程地址</h4><p><a href="https://www.rabbitmq.com/install-rpm.html#package-dependencies">https://www.rabbitmq.com/install-rpm.html#package-dependencies</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 启动rabbitmq</span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"># 查看状态</span><br><span class="line">rabbitmqctl status</span><br><span class="line"># 查看服务状态</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure><p>Mac下配置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/.bash_profile</span><br><span class="line">export PATH=$PATH:/usr/local/opt/rabbitmq/sbin</span><br><span class="line"># source ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="RabbitMQ管理后台"><a href="#RabbitMQ管理后台" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 启动管理后台</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"># 设置用户名密码</span><br><span class="line">rabbitmqctl add_user admin password</span><br><span class="line"># 设置为管理员</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><p>就可以通过15672端口登陆rabbitmq的后台</p><h3 id="HelloWorld案例"><a href="#HelloWorld案例" class="headerlink" title="HelloWorld案例"></a>HelloWorld案例</h3><p>maven-rabbitmq客户端项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>平均分配</strong>：按照数量平均。直接按照顺序给消费者发放，可以不需要确认。</p><p>发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(ConnectionFactoryUtil.QUEUE, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 空字符串代表使用默认的交换机</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,ConnectionFactoryUtil.QUEUE,<span class="keyword">null</span>, bytes);</span><br></pre></td></tr></table></figure><p>接受消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recive messgae todo</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>按照压力分配任务</strong>：需要手动确认消息过程，使得消费者任务完成后能够自动得到新的任务进行分配。</p><p>处理任务内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(ConnectionFactoryUtil.QUEUE,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// expect max task, do this work one by one</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// deal with the message and ack by ourselves</span></span><br><span class="line">channel.basicConsume(ConnectionFactoryUtil.QUEUE,<span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// dosomething code</span></span><br><span class="line">    <span class="comment">// ack the message</span></span><br><span class="line">    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="交换机工作模式"><a href="#交换机工作模式" class="headerlink" title="交换机工作模式"></a>交换机工作模式</h3><p><strong>fanout</strong>：广播这种交换模式只需要将队列绑定到交换机上即可，是不需要设置路由键的。如果接受到消息的Exchange当时没有与任何Queue绑定，则消息会被抛弃。</p><p><img src="/2022/02/27/distribute/image-20220418010208861.png" alt="image-20220418010208861"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT);</span><br><span class="line">// fanout mode do not need to set rotingKey</span><br><span class="line">channel.basicPublish(exchangeName, &quot;&quot;, null, message.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT);</span><br><span class="line"><span class="comment">// get a unsustainable queue randomly tempatation</span></span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">// bind queue with exchange, while routingKey can be empty in this fanout mode;</span></span><br><span class="line">channel.queueBind(queueName, exchangeName, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// create the consumer and show the message</span></span><br><span class="line">DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;message recieved successfully&quot;</span>);</span><br><span class="line">    String s = <span class="keyword">new</span> String(body, Charset.defaultCharset());</span><br><span class="line">    System.out.println(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="keyword">true</span>, defaultConsumer);</span><br></pre></td></tr></table></figure><p><strong>direct</strong>：根据RoutingKey匹配消息路由到指定的队列</p><p><img src="/2022/02/27/distribute/image-20220418010410608.png" alt="image-20220418010410608"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT);</span><br><span class="line">channel.basicPublish(exchangeName, routingKeyName,<span class="keyword">null</span>,message.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(String exchangeName, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">// get a random temp queue</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">// bind routingkey</span></span><br><span class="line">channel.queueBind(queue, exchangeName, routingKeyName);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>topic</strong>：生产者指定RoutingKey消息根据消费端指定的队列通过模糊匹配的方式进行相应的转发</p><p><img src="/2022/02/27/distribute/image-20220419233710059.png" alt="image-20220419233710059"></p><p><code>*</code>可以代替一个单词，<code>#</code>可以代替0个或多个单词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(consts.EXCHANGE, BuiltinExchangeType.TOPIC);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// match all the error messages</span></span><br><span class="line">channel.queueBind(queueName, consts.EXCHANGE, <span class="string">&quot;*.*.error&quot;</span>);</span><br></pre></td></tr></table></figure><p>headers: 根据发送消息内容的headers属性来匹配</p><p>略</p><h3 id="Spring-RabbitMQ"><a href="#Spring-RabbitMQ" class="headerlink" title="Spring RabbitMQ"></a>Spring RabbitMQ</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以topic交换机模式为例：</p><p>首先对消费者进行配置，并将队列以相应的routing key绑定在一个交换机上</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">producer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.rabbitmq.addresses</span>=<span class="string">x.x.x.x:5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">Gan336000</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br><span class="line"><span class="meta">spring.rabbitmq.connection-timeout</span>=<span class="string">15000</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TopicExchange <span class="title">exchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">&quot;bootExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeMessage1</span><span class="params">(Queue queue1, TopicExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1).to(exchange).with(<span class="string">&quot;dog.red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeMessage2</span><span class="params">(Queue queue2, TopicExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue2).to(exchange).with(<span class="string">&quot;dog.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息就通过AmqpTemplate的convertAndSend方法进行发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amqpTemplate.convertAndSend(exchangeName, RoutingKeyName, message);</span><br></pre></td></tr></table></figure><p>而消息的接收方则通过RabbitListener进行绑定监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reciver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;reciver1: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/02/27/distribute/image-20220227003608410.png&quot; alt=&quot;image-20220227003608410&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="分布式" scheme="http://123.57.158.5/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="Docker" scheme="http://123.57.158.5/tags/Docker/"/>
    
    <category term="Nginx" scheme="http://123.57.158.5/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="http://123.57.158.5/2022/02/23/java-threadLocal/"/>
    <id>http://123.57.158.5/2022/02/23/java-threadLocal/</id>
    <published>2022-02-23T15:40:03.000Z</published>
    <updated>2022-02-24T16:47:18.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal两大使用场景"><a href="#ThreadLocal两大使用场景" class="headerlink" title="ThreadLocal两大使用场景"></a>ThreadLocal两大使用场景</h2><ul><li>每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random，他们都是线程不安全的类）</li><li>每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦</li></ul><h3 id="每个线程需要一个独享的对象"><a href="#每个线程需要一个独享的对象" class="headerlink" title="每个线程需要一个独享的对象"></a>每个线程需要一个独享的对象</h3><p>例如我们需要用创建一个打印时间的线程，可以这样做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUsage0</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一个获取时间的工具类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDate</span><span class="params">(<span class="keyword">int</span> seconds)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 转化为毫秒</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span>*seconds);</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个打印时间的线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(ThreadLocalUsage0.getDate(<span class="number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要1000个线程来打印时间，可以将打印日期的任务提交到线程池中。同时为了不重复创建<code>SimpleDateFormat</code>对象，则让所有线程使用了同一个<code>SimpleDateFormat</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUsage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDate</span><span class="params">(<span class="keyword">int</span> seconds)</span></span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span>*seconds);</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(getDate(finalI));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是因为<code>SimpleDateFormat</code>类是线程不安全的，以上代码中使用同一个<code>SimpleDateFormat</code>对象后会导致部分打印出来的结果是一致的。解决办法是给线程加锁，防止出现访问同一个线程导致的线程安全问题。排队执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUsage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDate</span><span class="params">(<span class="keyword">int</span> seconds)</span></span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span>*seconds);</span><br><span class="line">        String dateString = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(ThreadLocalUsage2.class)&#123;</span><br><span class="line">            dateString = dateFormat.format(date);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dateString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(getDate(finalI));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁之后，打印日期的线程依次使用<code>SimpleDateFormat</code>，但是此时效率变低了。终极办法就是使用<code>ThreadLocal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUsage3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDate</span><span class="params">(<span class="keyword">int</span> seconds)</span></span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span>*seconds);</span><br><span class="line">        <span class="comment">// 使用threadLocal中的变量</span></span><br><span class="line">        <span class="keyword">return</span> ThreadSafeFormat.sdfl.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(getDate(finalI));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeFormat</span></span>&#123;</span><br><span class="line">    <span class="comment">// 普通写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; sdf = <span class="keyword">new</span> ThreadLocal&lt;&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//lambada表达式写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; sdfl = ThreadLocal.withInitial(</span><br><span class="line">            ()-&gt;<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每个线程内需要保存全局变量"><a href="#每个线程内需要保存全局变量" class="headerlink" title="每个线程内需要保存全局变量"></a>每个线程内需要保存全局变量</h3><p>典型场景如前端请求时候，需要判断每次用户信息，用户信息也经常需要层层传递。如果将用户信息放在一个对象中供所有线程使用，可以使用<code>Sychronized</code> 也可以用<code>ConcurrentHashMap</code>进行加锁，但是会对性能有所影响。</p><p>比如用户的信息一但生成后需要被很多线程的服务共享：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * threadLocal应用场景2</span></span><br><span class="line"><span class="comment"> * 当前用户需要被所有服务共享</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLcoalUsage10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service1.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name: &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadUserHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; user = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 生成当前用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;giao&quot;</span>);</span><br><span class="line">        ThreadUserHolder.user.set(user);</span><br><span class="line">        Service2.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get from Service2: &quot;</span> + ThreadUserHolder.user.get());</span><br><span class="line">        Service3.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get from Service3: &quot;</span> + ThreadUserHolder.user.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>让某个需要用的对象在<strong>线程间隔离</strong>（每个线程都有自己独立的对象）</li><li>在任何方法中都可以<strong>轻松获取</strong>到该对象</li></ol><p><font color="red">根据对象的生成时机的不同，选择initialValue或set来保存对象</font></p><h4 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a>initialValue</h4><p>在ThreadLocal第一次get的时候把对象给初始化处理啊，对像的初始化时机可以由我们控制</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>如果需要保存到ThreadLocal里的对象的生成时机不由我们随意控制，例如拦截器生成的用户信息</p><p>用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用</p><h4 id="ThreadLocal带来的好处"><a href="#ThreadLocal带来的好处" class="headerlink" title="ThreadLocal带来的好处"></a>ThreadLocal带来的好处</h4><ol><li>达到线程安全</li><li>不需要加锁，提高执行效率</li><li>更高效的利用内存，节省开销</li><li>避免了多次传参的繁琐，代码耦合度低，优雅</li></ol><h2 id="ThreadLocal主要方法介绍"><a href="#ThreadLocal主要方法介绍" class="headerlink" title="ThreadLocal主要方法介绍"></a>ThreadLocal主要方法介绍</h2><h3 id="T-initialValue-初始化"><a href="#T-initialValue-初始化" class="headerlink" title="T initialValue() 初始化"></a>T initialValue() 初始化</h3><ol><li>该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用<code>get</code>的时候，才会触发</li><li>当线程第一次使用<code>get</code>方法访问变量时，将调用此方法。（如果已经是set方法写入过的，直接返回<code>set</code>的value</li><li>每个线程最多调用一次此方法，但是如果已经调用了<code>remove()</code>后，再调用<code>get()</code></li><li>如果不重写本方法，这个方法会返回null，一般使用匿名内部类方法来重写<code>initialValue()</code>方法</li></ol><p>void set(T t) 为线程设置一个新值</p><p>T get() 得到线程对应的value，如果首次调用会通过initalValue得到值</p><p>void remove() 删除对应这个线程的值</p><h2 id="ThreadLocal详解"><a href="#ThreadLocal详解" class="headerlink" title="ThreadLocal详解"></a>ThreadLocal详解</h2><p>每个Thread对象中都持有一个ThreadLcoalMap成员对象，但是ThreadLocalMap中可以有许多个ThreadLocal对象</p><p><img src="/2022/02/23/java-threadLocal/image-20220224235821950.png" alt="image-20220224235821950"></p><p><code>get</code>方法是先取出当前线程的ThreadLocalMap，然后调用<code>map.getEntry</code>方法，把本ThreadLocal的引用作为参数传入</p><p>取出map中属于本ThreadLocal的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>注意：这个map以及map中的key和value都是<font color="red">保存在线程</font>中的，而不是保存在threadLocal中</em></p><p><code>intialValue</code>方法 没有默认实现，如果要用initialValue方法，需要自己实现，通常使用匿名内部类的方法实现</p><h4 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h4><p>也就是Thread.threadLocals</p><p>ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个<font color="red">键值对数组<code>Entry[] </code>table</font>，可以认为是一个map，键值对：</p><p>key： ThreadLocal</p><p>value：实际需要的成员变量 比如user或者simpleDateFormat对象</p><p>？但是解决Hash冲突的方式与HashMap不同：</p><p>ThreadLocal使用的是链表拉链和红黑树，ThreadLocalMap这里采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置，而不是链表拉链。</p><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>指某个对象不再有用，但是占用的内存却不能被回收 最终导致OOM</p><p><strong>弱引用</strong>特点：如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">      <span class="keyword">super</span>(k);</span><br><span class="line">      value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Value的泄漏：</p><p>ThreedLocalMap的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用。正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有扔河强引用了。但是，如果线程不终止（比如线程需要保持很久），那么key对应的value久不能被回收，因为有以下的调用链：</p><p><font color="red">Thread -&gt; ThreadLocalMap -&gt; Entry(key为null) -&gt;Value</font></p><p>因为vlaue和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能出现OOM</p><p>但是在jdk的设计中 扫描到key为null的Entry，会把对应的value设置为null。比如LocalThread中的很多方法都会对key进行判断。</p><p>但是如果一个ThreadLocal不被使用，它的很多方法也不调用，就可能导致value的内存泄漏</p><h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>调用<code>remove()</code>方法，就会删除对应的Entry对象，可以避免内存泄漏，所以使用完ThreadLocal后，应该调用该方法。（比如用户的退出登陆操作）</p><h3 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h3><p>在get之前，必须先set，否则会报空指针异常？不是的，如果不进行set，也会在get时候会直接返回null，不会报空指针。注意可能在包装类型转基本类型时候发生空指针异常</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ThreadLocal两大使用场景&quot;&gt;&lt;a href=&quot;#ThreadLocal两大使用场景&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal两大使用场景&quot;&gt;&lt;/a&gt;ThreadLocal两大使用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个线程</summary>
      
    
    
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO操作笔记</title>
    <link href="http://123.57.158.5/2022/02/06/java-io/"/>
    <id>http://123.57.158.5/2022/02/06/java-io/</id>
    <published>2022-02-06T05:58:15.000Z</published>
    <updated>2022-02-10T13:43:00.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件输入输出流"><a href="#文件输入输出流" class="headerlink" title="文件输入输出流"></a>文件输入输出流</h3><p><code>FileInputStream</code></p><ul><li>从文件系统中某个文件中获得输入字节</li><li>用于读取诸如图像数据之类的原始字节流</li></ul><p><code>read</code>方法读取数据字节（逐字节），可选参数 <code>byte[] b</code> <em>从输入流中最多b.length个字节的数据读取一个byte数组中</em>，<code>int off,int len</code>从off位置开始读取最多len个字节</p><p><code>close</code>方法释放资源</p><p>返回值-1表示读到文件末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用文本数据演示，但是实际使用中不推荐使用字节流读取，而用字符流读取。</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;io/fileStream.txt&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 逐个字节读取，然后转化为字符</span></span><br><span class="line"><span class="keyword">while</span> ((n = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.print((<span class="keyword">char</span>) n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">fis.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取指定数量的字节流输出</span></span><br><span class="line">FileInputStream fis2 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;io/fileStream.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 指定读取36个字节的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">36</span>];</span><br><span class="line">fis2.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">fis2.close();</span><br></pre></td></tr></table></figure><p><code>FileOutputStream</code></p><p><code>write</code>方法写入字节数据 </p><p>可选参数 <code>int b</code>写入指定的字节（ascii），<code>byte[] b</code>写入指定字节流的数据 </p><p><code>close</code>释放系统资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加模式写入</span></span><br><span class="line">FileOutputStream fos= <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;io/fileStream.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">fos.write(<span class="number">13</span>);</span><br><span class="line"><span class="comment">// 写入字符g</span></span><br><span class="line">fos.write(<span class="number">103</span>);</span><br><span class="line"><span class="comment">// 字符串转字节数组输入</span></span><br><span class="line">fos.write(<span class="string">&quot;iao&quot;</span>.getBytes());</span><br><span class="line">fos.write(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p><strong>文件复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis  = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;io/fileStream.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;io/temp.txt&quot;</span>);</span><br><span class="line"><span class="comment">//一次性读取1024个字节</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((fis.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">  fos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p>值得注意的是使用这样的方法拷贝时候可能会导致复制后的文件比原来稍大，因为最后一次读取的实际内容可能小于1024；可以改按实际长度读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((n = fis.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">  fos.write(b,<span class="number">0</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>前面的输入输出流是直接从ROM中读取，如果直接从内存中读取，那么速度则大大提高。这就是<strong>缓冲流</strong></p><p><code>BufferedInputStream</code>和<code>BufferedOutputStream</code></p><p>在文件写入过程中，缓冲区的数据如果没有满不会被写入到文件中，需要有<code>flush</code>清空操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;io/temp.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">bos.write(<span class="string">&quot;\n20220206, on the train...&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 清空缓冲区操作</span></span><br><span class="line">bos.flush();</span><br><span class="line">bos.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p><code>close</code>其实也会自动将缓冲区情况，但是习惯flush和close都写</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><code>InputStreamReader</code>和<code>OutputStreamWriter</code>。<strong>字节字符转化流</strong></p><p><code>BufferedReader/BufferedWriter</code> 缓冲读写方法，可配合输入输出流使用，增加读写速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;io/fileStream.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 构建fos对象，文件不存在会自动创建</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line"><span class="comment">// osw对象 将输入的字符流转换字节流对象fos进行写操作</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 使用缓冲，增加文件读写速度</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line"><span class="comment">// 写入缓冲区</span></span><br><span class="line">bw.append(<span class="string">&quot;随便输入一些东西&quot;</span>);</span><br><span class="line">bw.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">bw.append(<span class="string">&quot;write something&quot;</span>);</span><br><span class="line"><span class="comment">// 关闭写入流 缓冲区内容写入文件</span></span><br><span class="line">osw.close();</span><br><span class="line"><span class="comment">//关闭输出流，释放系统资源</span></span><br><span class="line">fos.close();</span><br><span class="line"><span class="comment">// 关闭缓冲</span></span><br><span class="line">bw.close();</span><br><span class="line"><span class="comment">// 构建fip对象</span></span><br><span class="line">FileInputStream fip = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="comment">// 构建isr对象读取字节流 转换为字符流</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fip,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//使用缓冲，增加文件读写速度</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span>(br.ready())&#123;</span><br><span class="line">  <span class="comment">//转化为char对象添加到string中</span></span><br><span class="line">  sb.append((<span class="keyword">char</span>)br.read());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line"><span class="comment">// 关闭读取流</span></span><br><span class="line">isr.close();</span><br><span class="line"><span class="comment">// 关闭输入流，释放系统资源</span></span><br><span class="line">fip.close();</span><br><span class="line"><span class="comment">// 关闭缓冲</span></span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><p>把java对象转化为字节序列的过程</p><p>创建类 继承Serializable接口；创建对象；将对象进行序列化，反序列化读取对象信息。</p><p><code>ObjectInputStream</code>, <code>ObjectOutputStream</code> 对象的序列化类</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文件输入输出流&quot;&gt;&lt;a href=&quot;#文件输入输出流&quot; class=&quot;headerlink&quot; title=&quot;文件输入输出流&quot;&gt;&lt;/a&gt;文件输入输出流&lt;/h3&gt;&lt;p&gt;&lt;code&gt;FileInputStream&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从文件系统中某个</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法之next数组代码理解</title>
    <link href="http://123.57.158.5/2021/12/29/kmp-next-list/"/>
    <id>http://123.57.158.5/2021/12/29/kmp-next-list/</id>
    <published>2021-12-29T14:49:53.000Z</published>
    <updated>2021-12-30T16:17:38.175Z</updated>
    
    <content type="html"><![CDATA[<p>kmp算法中next数组指的是当模式串某个位置匹配失败的情况下，应该跳转到模式串的哪个位置继续匹配。</p><p>next数组求法：</p><p><img src="/2021/12/29/kmp-next-list/image-20211229225226560.png" alt="image-20211229225226560"></p><p>就是找前缀和后缀相同的个数：</p><p><img src="/2021/12/29/kmp-next-list/image-20211231000830448.png" alt="image-20211231000830448"></p><p>代码求next数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] ch) &#123;</span><br><span class="line">  <span class="keyword">int</span> len = ch.length;</span><br><span class="line">  <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">  <span class="comment">// 模式串序号，第一个序号为1</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 模式串第i位匹配失败后跳转序号，第一个为0</span></span><br><span class="line">  <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">  next[i] = j;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span> || ch[i] == ch[j])</span><br><span class="line">      next[++i] = ++j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      j = next[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nextVal数组是next数组的优化，如果<code>ch[i]==ch[j]</code>成立就可以令<code>next[i]=next[j]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextVal(<span class="keyword">char</span>[] ch) &#123;</span><br><span class="line">  <span class="keyword">int</span> len = ch.length;</span><br><span class="line">  <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">  next[i] = j;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span> || ch[i] == ch[j]) &#123;</span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      <span class="keyword">if</span> (ch[i] != ch[j])</span><br><span class="line">        next[i] = j;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        next[i] = next[j];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      j = next[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pattern</span><span class="params">(String main, String model)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] m = main.toCharArray();</span><br><span class="line">  <span class="keyword">char</span>[] mo = model.toCharArray();</span><br><span class="line">  <span class="keyword">int</span>[] nextval = getNextVal(mo);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 逐个匹配，使用nextval数组减少匹配次数，跳到对应位置</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; mo.length &amp;&amp; ans &lt; m.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m[ans] == mo[i]) &#123;</span><br><span class="line">      ++ans;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        ++ans;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        i = nextval[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果带匹配的字符串index等于长度的话</span></span><br><span class="line">  <span class="keyword">if</span> (i == mo.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> ans - i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;kmp算法中next数组指的是当模式串某个位置匹配失败的情况下，应该跳转到模式串的哪个位置继续匹配。&lt;/p&gt;
&lt;p&gt;next数组求法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/12/29/kmp-next-list/image-20211229225226560.pn</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识补充</title>
    <link href="http://123.57.158.5/2021/12/26/java-thread/"/>
    <id>http://123.57.158.5/2021/12/26/java-thread/</id>
    <published>2021-12-26T15:26:12.000Z</published>
    <updated>2022-02-10T14:17:21.303Z</updated>
    
    <content type="html"><![CDATA[<img src="/2021/12/26/java-thread/image-20211226233842837.png" alt="image-20211226233842837" style="zoom:50%;"><h3 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h3><ol><li>创建继承Thread类的方法，重写run方法；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">xxxx;</span><br><span class="line">System.out.println(getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><ol><li>实现runnable接口方法</li></ol><p>因为java不支持多继承；同时也不打算重写Thread类其他方法时候可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">xxx;</span><br><span class="line">System.out.println(Thread.currentThread.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyRunnable run = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(run);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h3 id="线程的几个主要方法"><a href="#线程的几个主要方法" class="headerlink" title="线程的几个主要方法"></a>线程的几个主要方法</h3><p><code>sleep()</code>和<code>yield()</code>都是线程类的静态方法，<code>join()</code>是线程对象的调用方法</p><p><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>这三个都是Object对象方法，用于协调多个线程对共享数据的读取。</p><p>它们都是用于协调多个线程对共享数据的存取，所以必须在Synchronized语句块内使用这三个方法。Synchronized这个关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出Synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。 </p><p>(1) wait()方法使当前线程暂停执行并<strong>释放对象锁</strong>标志，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。</p><p>(2) 当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。<br>(3) notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中</p><p><code>sleep()</code>释放cpu资源，不释放锁资源了；<code>wait()</code>释放cpu资源和锁资源</p><p>1.sleep：Thread类的方法，必须带一个时间参数。<strong>会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段）</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。</p><p>2.yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是<strong>不能由用户指定暂停多长时间 ，</strong>并且yield()方法<strong>只能让同优先级的线程</strong>有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入<strong>到可执行状态后</strong>马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</p><p>3.wait：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒 (notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒) 即放入锁池中竞争同步锁 </p><p>4.join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。</p><p>等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p><h3 id="线程同步-通信"><a href="#线程同步-通信" class="headerlink" title="线程同步/通信"></a>线程同步/通信</h3><p>解决多线程运行的问题：</p><img src="/2021/12/26/java-thread/image-20220210215810109.png" alt="image-20220210215810109" style="zoom:50%;"><p>sychronized关键字 可用于成员方法、静态方法、语句块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">svaeAccount</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;&#125;</span><br></pre></td></tr></table></figure><p>关于线程相关方法的使用参见github上关于线程的学习代码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2021/12/26/java-thread/image-20211226233842837.png&quot; alt=&quot;image-20211226233842837&quot; style=&quot;zoom:50%;&quot;&gt;

&lt;h3 id=&quot;创建线程的方法&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池解析</title>
    <link href="http://123.57.158.5/2021/12/21/java-thread-pool/"/>
    <id>http://123.57.158.5/2021/12/21/java-thread-pool/</id>
    <published>2021-12-21T14:08:54.000Z</published>
    <updated>2021-12-26T13:38:35.622Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线程池</strong>就是为了处理避免反复创建并销毁县城所带来的开销问题</p><p><strong>corePoolsize</strong> 核心线程数</p><p><strong>maxPoolSize</strong>在核心线程数之上，最大的线程数量</p><p>达到核心线程数之后，会将任务放入队列，队列满了，创建线程直到最大线程数，再大于之后则拒绝</p><img src="/2021/12/21/java-thread-pool/image-20211221221954658.png" alt="image-20211221221954658" style="zoom:50%;"><p><strong>workQueye</strong>任务存储队列</p><p>常见队列类型</p><ul><li>直接交接：<strong>SynchronousQueue</strong>，队列无容量，直接创建线程</li><li>无界队列：<strong>LinkedBlockingQueue</strong>，队列放不满，最大线程数失效。容易导致OOM异常</li><li>有界队列：<strong>ArrayBlockingQueue</strong>，队列满了，才创建线程</li></ul><p><strong>keepAliveTime</strong>当超过核心线程的多余线程空闲时间超过了这个数，线程被回收</p><p><strong>TreadFactory</strong>用于创建线程，默认使用Executors.defaultThreadFactory()，创建出来的线程都在一个线程组，优先级都是5，都不是守护线程。这个参数可自定义线程名，线程组，优先级和是否为守护线程（服务其他线程的线程，比如垃圾回收线程）等。</p><h3 id="自动创建线程池的风险"><a href="#自动创建线程池的风险" class="headerlink" title="自动创建线程池的风险"></a>自动创建线程池的风险</h3><p>自动创建的常见方法：</p><p>例如我们通过Executors.newFixedThreadPool(n)自动创建线程，执行的线程数最大就是n</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// ExecutorService executorService = Executors.newFixedThreadPool(3);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> FixedThreadDemo.Task());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个线程用于演示固定大小的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们的执行任务不停的创建，单固定线程数有限，执行时间非常长的时候，此时任务队列不停增大容易导致OOM异常，<code>newSingleThreadPool</code>同理，使用的也都是<strong>无界队列</strong></p><p><img src="/2021/12/21/java-thread-pool/image-20211222002400912.png" alt="image-20211222002400912"></p><p><code>newCachedThreadPool</code>可缓存线程池，使用<strong>直接交换</strong>队列。特点是具有自动回收多余线程的功能。弊端在于最大线程数量设置为了Integer.MAX_VALUE，这可能导致创建非常多的线程数量，同样可能导致OOM异常。</p><p><img src="/2021/12/21/java-thread-pool/image-20211222002431567.png" alt="image-20211222002431567"></p><p><code>newScheduledThreadPool</code>支持定时及周期任务执行的线程池。可以进行定时运行线程，或者以一定频率执行线程任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 定时5s之后执行</span></span><br><span class="line">executorService.schedule(<span class="keyword">new</span> FixedThreadDemo.Task(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 定时1s后执行，每隔2s执行一次</span></span><br><span class="line">executorService.scheduleAtFixedRate(<span class="keyword">new</span> FixedThreadDemo.Task(), <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>正确的创建线程的方法：</p><ul><li>根据不同的业务场景，设置线程池参数</li><li>比如：内存有多大，给线程取什么名字等等</li></ul><p><img src="/2021/12/21/java-thread-pool/image-20211222002620100.png" alt="image-20211222002620100"></p><h3 id="线程池的数量设定为多少合适"><a href="#线程池的数量设定为多少合适" class="headerlink" title="线程池的数量设定为多少合适"></a>线程池的数量设定为多少合适</h3><ul><li><p>CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右</p></li><li><p>耗时IO型（读写数据库、文件、网络读写等等）：最佳线程数一般大于CPU线程核心数很多倍</p><p>参考Brain Goetz推荐计算方法：<br>线程数=CPU核心数*（1+平均等待时间/平均工作时间）</p><p>2实际应该根据不同的程序进行压测</p></li></ul><h3 id="阻塞队列分析"><a href="#阻塞队列分析" class="headerlink" title="阻塞队列分析"></a>阻塞队列分析</h3><p><img src="/2021/12/21/java-thread-pool/image-20211222003214514.png" alt="image-20211222003214514"></p><ol><li>固定大小线程池，因为线程数固定，新来任务数未知，必须使用无限大的队列去存储</li><li>可缓存线程池目的为了执行效率最高，直接去新增线程</li><li>延时队列就是方便让任务延时进行</li></ol><p><code>workStealingPool</code>适用于容易产生子任务（比如递归）的线程；窃取，让线程之间“互相帮助”并发执行，线程之间不能加锁。</p><h3 id="关闭线程池的正确方法"><a href="#关闭线程池的正确方法" class="headerlink" title="关闭线程池的正确方法"></a>关闭线程池的正确方法</h3><p><code>shutdown</code> 存量任务执行完毕，新任务不增加</p><p><code>isShutdown</code>判断线程是否关闭</p><p><code>isTerminated</code>判断线程任务是否执行完毕</p><p><code>awaitTerminated</code>判断是否在规定时间内执行完毕</p><p><code>shutdownNow</code>正在执行的线程会立刻被终止，队列中的不执行，返回队列中的任务列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// ExecutorService executorService = Executors.newCachedThreadPool();</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> FixedThreadDemo.Task());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// System.out.println(&quot;thread service is shutdown or not ?&quot; + executorService.isShutdown());</span></span><br><span class="line">        <span class="comment">// executorService.shutdown();</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;thread service is shutdown or not ?&quot; + executorService.isShutdown());</span></span><br><span class="line">        <span class="comment">// Thread.sleep(2000);</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;thread service is terminated or not ?&quot; + executorService.isTerminated());</span></span><br><span class="line">        <span class="comment">// System.out.println( &quot;thread service is terminated or not ?&quot; + executorService.awaitTermination(2, TimeUnit.SECONDS));</span></span><br><span class="line">        <span class="comment">// 强制关闭在执行线程，队列中任务不执行，保存在list中</span></span><br><span class="line">        List&lt;Runnable&gt; list = executorService.shutdownNow();</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个线程用于演示固定大小的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; is interrupted.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程池暂停和恢复"><a href="#线程池暂停和恢复" class="headerlink" title="线程池暂停和恢复"></a>线程池暂停和恢复</h3><p>线程拒绝时机：</p><ul><li>当Executor关闭时，提交新任务会被拒绝</li><li>当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时</li></ul><p><img src="/2021/12/21/java-thread-pool/Untitled.png" alt="Untitled"></p><p>四种拒绝策略：</p><ol><li>AbortPolicy</li><li>DiscardPolicy</li><li>DiscardOldestPolicy</li><li>CallerRunsPolicy</li></ol><p>通过钩子函数给线程池添加功能，比如添加日志等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PausableThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 比synchronized更安全，因为需要考虑异常情况，一般不会导致死锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PausableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">true</span>;</span><br><span class="line">            unpaused.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isPaused) &#123;</span><br><span class="line">                unpaused.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">false</span>;</span><br><span class="line">            unpaused.notifyAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                Thread thread = Thread.currentThread();</span><br><span class="line">                System.out.println(thread.getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PausableThreadPool pausableThreadPool = <span class="keyword">new</span> PausableThreadPool(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br><span class="line">        <span class="comment">// ExecutorService pausableThreadPool = Executors.newFixedThreadPool(10);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            pausableThreadPool.execute(<span class="keyword">new</span> Task());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            pausableThreadPool.pause();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread is paused.....&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            pausableThreadPool.resume();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread is now released.....&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><p><em>继承改写ThreadPoolExecutor过程中运行时候一直显示一个线程在执行</em></p><p>发现是重写<code>beforeExecutor</code>方法时候没有解锁<code>lock.unlock()</code>导致</p><p><em>运行报错java.lang.IllegalMonitorStateException<br>        at java.base/java.lang.Object.notifyAll(Native Method)</em></p><p>发现是添加线程并没有被暂停<code>await</code>，导致不能被恢复<code>notifyAll</code></p><p>其他可能原因：</p><p>1&gt;当前线程不含有当前对象的锁资源的时候，调用obj.wait()方法;<br> 2&gt;当前线程不含有当前对象的锁资源的时候，调用obj.notify()方法。<br> 3&gt;当前线程不含有当前对象的锁资源的时候，调用obj.notifyAll()方法。</p><h3 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h3><p>线程池的组成部分：</p><ul><li>线程池管理器</li><li>工作线程</li><li>任务队列</li><li>任务接口</li></ul><img src="/2021/12/21/java-thread-pool/image-20211226130932071.png" alt="image-20211226130932071" style="zoom:50%;"><p><code>Executor</code>作为接口只有一个<code>void execute(Runnable commad)</code>方法</p><p><code>ExecutorService</code>继承了上一个方法，有了线程开启 停止等方法，详情可见api文档</p><img src="/2021/12/21/java-thread-pool/image-20211226131420571.png" alt="image-20211226131420571" style="zoom:20%;"><p><code>Executors</code> 则是一个工具类，可以方便的创建线程池等（详见api文档）</p><p>另外两个则是<code>ExecutorService</code>的继承和实现类， 方法内返回的仍然是<code>ExecutorService</code></p><h4 id="线程池实现任务复用的原理"><a href="#线程池实现任务复用的原理" class="headerlink" title="线程池实现任务复用的原理"></a>线程池实现任务复用的原理</h4><p>让我们看看线程池的执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment">     * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment">     * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment">     * the task is handled by the current &#123;<span class="doctag">@link</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment">     *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">// 小于核心数 创建</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 如果线程池在运行状态就放入工作队列中</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">          <span class="comment">// 再次检查如果线程池不在运行了则移除任务</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">          <span class="comment">// 防止任务提交到队列却没有被执行 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 其他情况如线程池停止，线程数大于核心数等</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>线程池的状态</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits 截取自ThreadPoolExecutor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p><strong>线程池使用注意点</strong>：</p><ul><li>避免任务堆积。比如在使用newFixedThreadPool时候</li><li>避免线程数量过度增加。比如在使用newCachedThreadPool时候</li><li>排查线程泄漏</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;线程池&lt;/strong&gt;就是为了处理避免反复创建并销毁县城所带来的开销问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;corePoolsize&lt;/strong&gt; 核心线程数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;maxPoolSize&lt;/strong&gt;在核心线程数之上，最大的线</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java判定2的方幂和2方幂取法</title>
    <link href="http://123.57.158.5/2021/12/13/java-power2/"/>
    <id>http://123.57.158.5/2021/12/13/java-power2/</id>
    <published>2021-12-13T14:02:18.000Z</published>
    <updated>2021-12-13T15:56:19.104Z</updated>
    
    <content type="html"><![CDATA[<p>判断是不是2的方幂可以通过按位与是否等于0来判定，很容易可以推出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个数获取包含它在内的最近额2的方幂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// numberOfLeadingZeros就是1前面0的个数，int总位数这里是32</span></span><br><span class="line">  <span class="comment">// 负数的非符号位在计算机中就是它对应正数的补码（反码加一）</span></span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;是忽略符号位右移（左边直接补0）</span></span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>例如 输入值为 9 我们来找方幂，为了方便观看假定int为8位。</p><p>8二进制为00001000 numberOfLeadingZeros方法返回4，-1非符号位补码表示为11111111右移4位，填充0，00001111</p><p>所以n = 15 最终返回16，即要找的2方幂</p><p>对于numberOfLeadingZeros方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个处理逻辑很符合二分搜索树。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// HD, Figure 5-6</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">        <span class="comment">// 为什么是1呢？因为如果i不是0，那么就表明在二进制表示中其至少有一位为1。</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果 i 无符号右移 16位成立，那么就表示i的前16为0，这是就可以对n进行+16(32-16)的操作，然后</span></span><br><span class="line">        <span class="comment">// 再将i左移16位，这个主要是将低位的数值移到高位去进行处理 </span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">16</span> == <span class="number">0</span>) &#123; n += <span class="number">16</span>; i &lt;&lt;= <span class="number">16</span>; &#125;</span><br><span class="line">        <span class="comment">// 如果 i 无符号右移 24位成立，那么就表示前24位为0，这时就可以对n进行+8操作(加8操作的来源是：</span></span><br><span class="line">        <span class="comment">// 32 - 24 得来的)，接着将i左移8位，这样就把24位的0覆盖掉，将低位数字移到高位来进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">24</span> == <span class="number">0</span>) &#123; n +=  <span class="number">8</span>; i &lt;&lt;=  <span class="number">8</span>; &#125;</span><br><span class="line">        <span class="comment">// 一样的逻辑来进行处理（加4的来源是：32-28）</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">28</span> == <span class="number">0</span>) &#123; n +=  <span class="number">4</span>; i &lt;&lt;=  <span class="number">4</span>; &#125;</span><br><span class="line">        <span class="comment">// 一样的逻辑（加2的来源是：32-30）</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">30</span> == <span class="number">0</span>) &#123; n +=  <span class="number">2</span>; i &lt;&lt;=  <span class="number">2</span>; &#125;</span><br><span class="line">       </span><br><span class="line">        n -= i &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;判断是不是2的方幂可以通过按位与是否等于0来判定，很容易可以推出。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java实现pythonzip方法</title>
    <link href="http://123.57.158.5/2021/12/12/java-zip-function/"/>
    <id>http://123.57.158.5/2021/12/12/java-zip-function/</id>
    <published>2021-12-12T15:36:27.000Z</published>
    <updated>2021-12-12T16:24:18.103Z</updated>
    
    <content type="html"><![CDATA[<p>工作中遇见一个问题需要将x轴和y轴的数据拼合起来，类似于python的zip函数，但是java中没有原生方法，随即根据zip的源码封装了一个类似的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  合并arrays，类似于python的zip方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrys &#123;1.1, 3.3, 2.6&#125;、&#123;1.3, 3.3, 7.7, 4.3&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> [[1.1,1.3],[3.3,3.3],[2.6,7.7]]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Collection&lt;Object&gt;&gt; zip(Double[]... arrys) &#123;</span><br><span class="line">        Collection&lt;Collection&lt;Object&gt;&gt; zips = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 将每个数组保存为迭代器list</span></span><br><span class="line">        List&lt;Iterator&lt;Double&gt;&gt; iterators = Arrays.stream(arrys).map(a -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.stream(a).iterator();</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        loop:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!iterators.isEmpty()) &#123;</span><br><span class="line">              <span class="comment">// 遍历每个迭代器依次添加集合</span></span><br><span class="line">                Collection&lt;Object&gt; zip = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (Iterator it : iterators</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (it.hasNext()) &#123;</span><br><span class="line">                        Double ele = (Double) it.next();</span><br><span class="line">                        zip.add(ele);</span><br><span class="line">                        <span class="keyword">continue</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">                zips.add(zip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zips;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工作中遇见一个问题需要将x轴和y轴的数据拼合起来，类似于python的zip函数，但是java中没有原生方法，随即根据zip的源码封装了一个类似的&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC的一些配置</title>
    <link href="http://123.57.158.5/2021/12/06/springmvc/"/>
    <id>http://123.57.158.5/2021/12/06/springmvc/</id>
    <published>2021-12-06T14:59:39.000Z</published>
    <updated>2022-03-17T16:14:16.707Z</updated>
    
    <content type="html"><![CDATA[<p>新建maven项目-》project structure中添加web的module-》添加xml路径 和webapp路径（同时create artifact）-》edit configuration添加tomcat路径-》deployment中添加artifact-》webapp下添加的html可以正常访问。</p><p>配置好web应用和资源目录</p><p><img src="/2021/12/06/springmvc/image-20220120005840229.png" alt="image-20220120005840229"></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ol><li><p>配置依赖</p><p>pom.xml 包括spring-webmvc/freemarker/spring-context-support/jackson-core/jackson-annotations/jackson-databind/</p><p>Project structure中artifact将包推进WEB-INF的lib中</p></li><li><p>配置DispatcherServlet 及请求中文乱码问题</p><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    解决请求中的中文乱码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>开启springmvc注解模式 配置freemarker模版引擎</p><p>需要注意的是context:component-scan中use-default-filter设置为true代表将对包中的所有Component注解（包括controller srevice 等等注解进行扫描），如果是false会导致各种注解失效（血的教训）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:task</span>=<span class="string">&quot;http://www.springframework.org/schema/task&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/task</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/task/spring-task.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启springmvc注解模式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example.booker&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json;charset=utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置freemarker模版引擎--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;freemarkerConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateLoaderPath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/ftl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;freemarkerSettings&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;defaultEncoding&quot;</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;contentType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.ftl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="SSM-MyBatis-整合配置"><a href="#SSM-MyBatis-整合配置" class="headerlink" title="SSM-MyBatis 整合配置"></a>SSM-MyBatis 整合配置</h3><p>在spring启动时创建sqlsessionfactory对象 方便进行管理</p><img src="/2021/12/06/springmvc/image-20211206235834963.png" alt="image-20211206235834963" style="zoom:50%;"><p>添加依赖 spring-jdbc、mybatis、mybatis- Spring、mysql-connector-java、druid</p><p>mybatis与spring的整合配置之配置数据源。涉及到的classpath需要有对应文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    mybatis与spring的整合配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/book_reader?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>allowPublicKeyRetrieval=true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        一般可设置为用户使用上限--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    会基于配置信息创建sqlsessionFactory，交给ioc容器管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mappers/*.xml&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 配置驼峰命名转换--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configuration&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.core.MybatisConfiguration&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    mapper扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.example.booker.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Logback、声明式事务、junit单元测试</strong></p><h4 id="junit单元测试"><a href="#junit单元测试" class="headerlink" title="junit单元测试"></a>junit单元测试</h4><p>spring-text、junit依赖 但<strong>单元测试需要servlet接口</strong>，引入javax.servlet-api依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        单元测试依赖--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis操作数据库一般结构： 添加mapper接口，resource的mappers中添加对应的xml文件 通过namespace指向对应接口。crud的id指向接口的方法名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.booker.mapper.TestMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">        insert into book_reader (content) values (&quot;test content&quot;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service/serviceImpl中写curd业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestMapper testMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        testMapper.insert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Junit4测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestService testService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testService.insert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="logback配置"><a href="#logback配置" class="headerlink" title="logback配置"></a>logback配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=<span class="string">&quot;console&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;HH:mm:ss&#125; %-5level [%thread] %logger&#123;<span class="number">30</span>&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-<span class="number">8</span>&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;root level=<span class="string">&quot;debug&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;console&quot;</span>/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>在spring中添加tx的schema：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        ...</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!--    声明式事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Mybatis-Plus整合"><a href="#Mybatis-Plus整合" class="headerlink" title="Mybatis-Plus整合"></a>Mybatis-Plus整合</h4><ul><li>pom引入mybatis-plus依赖</li><li>spring-xml更改配置SqlSessionFactory实现类</li><li>mybatis-config.xml增加<strong>Mp分页插件</strong>，适用3.2.0以上版本</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    会基于配置信息创建sqlsessionFactory，交给ioc容器管理--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--原生spring与mybatis整合--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    mybatisPlus整合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mappers/*.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--        指定mybatis配置文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--         分页插件配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;mybatisPlusInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    整合分页器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mybatisPlusInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptors&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;paginationInnerInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;paginationInnerInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 对于单一数据库类型来说,都建议配置该值,避免每次分页都去抓取数据库类型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dbType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;H2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;countSqlParser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置为 true 可以优化部分 left join 的sql --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;optimizeJoin&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="MyBatis-Plus操作"><a href="#MyBatis-Plus操作" class="headerlink" title="MyBatis-Plus操作"></a>MyBatis-Plus操作</h4><ul><li><p>创建实体类，@TableName/@TableId/@TableField实现映射，如果开启了驼峰映射的话，TableField可以省略</p></li><li><p>创建Mapper接口继承BaseMapper，创建MapperXML</p><p>首先新建数据库对应实体类，并映射；新建Mapper接口继承BaseMapper并将范型定为实体类，这个mapper中可以新建自定义方法，方法名对应xml文件中curd的id名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">TestTable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.booker.mapper.TestMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertTest&quot;</span>&gt;</span></span><br><span class="line">        SQL syntax</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>service中使用常规写法，<strong>注入Mapper对象，通过内置API实现CRUD</strong></p><p>也可以选择创建mapper后不写xml。通过继承mybatis的IService和ServiceImpl方法获得基本的数据库操作方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">Category</span>&gt; </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">CategoryMapper</span>,<span class="title">Category</span>&gt; <span class="keyword">implements</span> <span class="title">CategoryService</span></span></span><br></pre></td></tr></table></figure></li><li><p>对于复杂的查询可以使用第一种xml写法，也可以直接在mapper类中通过@Select(“SELECT XXXXX FROM XXXX JOIN XXXX”)注解实现</p></li></ul><h3 id="图书类别实现"><a href="#图书类别实现" class="headerlink" title="图书类别实现"></a>图书类别实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 括号内指的是在spring容器中这个类的bean id为xxx，符合面向接口编程规则</span></span><br><span class="line"><span class="meta">@Service(&quot;CategoryService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryServiceImpl</span> <span class="keyword">implements</span> <span class="title">CategoryService</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>@Autowired 对比@Resource：autowired只会根据type去进行注入，找不到报错，resource会根据type和name进行匹配，然后注入。推荐使用@Service(“指定名称”) 然后@Resource的方法注入</em></p><p>事务传播性：propagation参数，propagation配置的就是一个事务的传播性问题。所谓事务传播性，就是被调用者的事务与调用者的事务之间的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示对数据只读操作，默认不开启事务。如果需要写操作则需要手动在方法上开启事务机制</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED,read_only = true)</span></span><br><span class="line"><span class="keyword">public</span> CategoryServiceImpl implements CateogoryService&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller中绑定视图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showCategories</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 绑定视图文件的名字 一定要这样写 否则报错找不到资源</span></span><br><span class="line">  ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">  List&lt;Category&gt; allCategories = categoryService.getAllCategories();</span><br><span class="line">  <span class="comment">// 添加属性名</span></span><br><span class="line">  mv.addObject(<span class="string">&quot;categories&quot;</span>,allCategories);</span><br><span class="line">  <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>freemaker中的展示方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list categories as categories&gt;</span><br><span class="line">  &lt;a style=<span class="string">&quot;cursor: pointer&quot;</span> data-category=<span class="string">&quot;$&#123;categories.categoryId&#125;&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;text-black-50 font-weight-bold category&quot;</span>&gt;$&#123;categories.categoryName&#125;&lt;/a&gt;</span><br><span class="line">    &lt;#--存在下一处则展示--&gt;</span><br><span class="line">    &lt;#<span class="keyword">if</span> categories_has_next&gt;|&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br></pre></td></tr></table></figure><h3 id="关于首页出现异常内容的事件（编译过程中没有自动删除之前的文件）"><a href="#关于首页出现异常内容的事件（编译过程中没有自动删除之前的文件）" class="headerlink" title="关于首页出现异常内容的事件（编译过程中没有自动删除之前的文件）"></a>关于首页出现异常内容的事件（编译过程中没有自动删除之前的文件）</h3><p>我在启动项目后，首页出现了之前清理掉的html文件。在多次重启服务、clean、compile、仍然无效，command+shift+r 全局项目搜索页面内容也没有找到文件所在，继续检查了每一个api都无果。后来在build出来的out文件夹中发现了它的踪影，原来是之前误把文件放错了位置，项目运行进入之后，而每次启动项目的编译过程，并没有被去掉该文件。</p><p>手动清理好，build，ok。</p><p>War exploded Artifects</p><img src="/2021/12/06/springmvc/image-20220121010335967.png" alt="image-20220121010335967" style="zoom:50%;"><h3 id="分页查询实现"><a href="#分页查询实现" class="headerlink" title="分页查询实现"></a>分页查询实现</h3><p>首先要配置好mybatis plus插件（xml配置见上面，非常重要！！！），然后分页可以通过以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IPage&lt;Book&gt; <span class="title">selectBookPage</span><span class="params">(Integer page, Integer rows)</span></span>&#123;</span><br><span class="line">  Page&lt;Book&gt; bookPage = <span class="keyword">new</span> Page&lt;Book&gt;(page,rows);</span><br><span class="line">  <span class="comment">// 第二个参数为数据库查询参数</span></span><br><span class="line">  <span class="keyword">return</span> bookMapper.selectPage(bookPage,<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ajax-模版引擎动态加载图书信息"><a href="#ajax-模版引擎动态加载图书信息" class="headerlink" title="ajax+模版引擎动态加载图书信息"></a>ajax+模版引擎动态加载图书信息</h3><p>写好加载图书信息接口api后，前端页面使用ajax动态调用图书信息</p><p>其中使用的是腾讯art-template对图书信息html片段进行渲染，使用<code>&#123;&#123;param&#125;&#125;</code>对数据进行加载，通过script 的id和template方法绑定模板到html片段（见上）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tpl&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/book/</span></span></span><span class="template-variable">&#123;&#123;<span class="name">bookId</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: inherit&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            ...</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-8  mb-2 pl-0&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                    ...</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;stars&quot;</span> <span class="attr">data-score</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">score</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">title</span>=<span class="string">&quot;gorgeous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">...</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于评分显示星星，使用raty组件进行渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 引入本地组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./resources/raty/lib/jquery.raty.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 指定图片位置</span></span></span><br><span class="line"><span class="javascript">  $.fn.raty.defaults.path =<span class="string">&quot;./resources/raty/lib/images&quot;</span></span></span><br><span class="line"><span class="javascript">  ...</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 绑定class 添加星星 只读</span></span></span><br><span class="line"><span class="javascript">      $(<span class="string">&quot;.stars&quot;</span>).raty(&#123;<span class="attr">readOnly</span>:<span class="literal">true</span>&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js绑定加载更多按钮单击事件，并且封装加载不定页数的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadMore</span>(<span class="params">isReset</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isReset == <span class="literal">true</span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#nextPage&quot;</span>).val(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> nextPage = $(<span class="string">&quot;#nextPage&quot;</span>).val();</span><br><span class="line">  <span class="comment">// ajax 请求分页信息</span></span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/books&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;<span class="attr">page</span>: nextPage, <span class="attr">size</span>: <span class="number">10</span>&#125;,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> list = json.records;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 加载模版</span></span><br><span class="line">        <span class="keyword">var</span> html = template(<span class="string">&quot;tpl&quot;</span>,list[i])</span><br><span class="line">        $(<span class="string">&quot;#bookList&quot;</span>).append(html);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 绑定class选择器 添加星星 只读</span></span><br><span class="line">      $(<span class="string">&quot;.stars&quot;</span>).raty(&#123;<span class="attr">readOnly</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否为最后一页</span></span><br><span class="line">      <span class="keyword">if</span>(json.current &lt; json.pages)&#123;</span><br><span class="line">        $(<span class="string">&quot;#nextPage&quot;</span>).val(<span class="built_in">parseInt</span>(json.current)+<span class="number">1</span>);</span><br><span class="line">        $(<span class="string">&quot;#btnMore&quot;</span>).show();</span><br><span class="line">        $(<span class="string">&quot;#divNoMore&quot;</span>).hide();</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">&quot;#btnMore&quot;</span>).hide();</span><br><span class="line">        $(<span class="string">&quot;#divNoMore&quot;</span>).show();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动请求第一页的数据</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  loadMore(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//    加载更多</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;#btnMore&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    loadMore();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新建maven项目-》project structure中添加web的module-》添加xml路径 和webapp路径（同时create artifact）-》edit configuration添加tomcat路径-》deployment中添加artifact-》web</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>EndNote使用指南</title>
    <link href="http://123.57.158.5/2021/10/23/EndNoteForFHY/"/>
    <id>http://123.57.158.5/2021/10/23/EndNoteForFHY/</id>
    <published>2021-10-23T03:36:08.000Z</published>
    <updated>2021-10-23T03:51:43.480Z</updated>
    
    <content type="html"><![CDATA[<p>EndNote是一个文献管理软件，使用它可以方便的对文献进行管理，同时通过它的嵌入工具，可以方便的边书写论文边插入参考文献。</p><p>软件版本：</p><p>endnote x9</p><p>office 2016</p><h2 id="1-新建EndNote库"><a href="#1-新建EndNote库" class="headerlink" title="1.  新建EndNote库"></a>1.  新建EndNote库</h2><p><strong>介绍建立文献库基本操作</strong></p><p>首先，打开endnote新建库，这就是你以后的文献库，用于存放并管理你阅读的文献。如果C盘空间不够大的话可以放在其他盘上，默认在C盘文档文件夹下。</p><img src="/2021/10/23/EndNoteForFHY/image-20211022235039187-4960420.png" alt="image-20211022235039187" style="zoom: 50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023000045172-4960420.png" alt="image-20211023000045172" style="zoom:50%;"><p>打开endnote库后，在我的分组中右击可以新建组，可以像这样：综述、研究方法、研究背景…等等新建组，对不同类型文献进行区分。还可以新建组集，例如毕业论文一个组集，小论文一个组集等等。当然可以后期调整，whatever。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023001655965-4960420.png" alt="image-20211023001655965" style="zoom: 50%;"><h3 id="导入样式"><a href="#导入样式" class="headerlink" title="导入样式"></a>导入样式</h3><p>样式指的是文献的引用格式，例如常见的有国标的作者年份格式，和数字编号格式。同时endnote还支持许多期刊的引用格式，可以在各种样式之间方便的进行切换。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023005911004-4960420.png" alt="image-20211023005911004" style="zoom:50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023005955736-4960420.png" alt="image-20211023005955736" style="zoom:50%;"><p>对于endnote样式，我们可以通过[endnote官网](<a href="https://endnote.com/downloads/styles/">Output Styles | EndNote</a>)进行查找和下载</p><p>下载完成后导入endnote中：</p><p>直接使用endnote打开下载好的ens格式文件，另存之后关闭，随后样式就导入成功了</p><img src="/2021/10/23/EndNoteForFHY/image-20211023011341993-4960420.png" alt="image-20211023011341993" style="zoom:50%;"><p>选择该样式，之后就可以愉快使用这个样式进行文件的自动引用了。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023011539175-4960420.png" alt="image-20211023011539175" style="zoom: 50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023011721575.png" alt="image-20211023011721575" style="zoom:50%;"><h2 id="2-文献管理"><a href="#2-文献管理" class="headerlink" title="2. 文献管理"></a>2. 文献管理</h2><p><strong>介绍文献的导入与管理</strong></p><p>在阅读文献之前，通常我们会在文献网站上进行关键词检索，找到所需文献后下载，同时对其引用格式进行保存，最后将引用格式与文献pdf进行关联。</p><ol><li><p><em>知网</em></p><p>首先找到目标文献进行下载，将pdf文件保存到本地，没有pdf的下载caj</p><img src="/2021/10/23/EndNoteForFHY/image-20211023014102030-4960420.png" alt="image-20211023014224938" style="zoom:50%;"><p>然后右上的引用图标下载该文献的endnote格式的引用，在弹出的窗口中选择更多格式的引用，找到endnote 导出txt文件</p><img src="/2021/10/23/EndNoteForFHY/image-20211023014942996-4960420.png" alt="image-20211023014942996" style="zoom:50%;"><p>在endnote中导入该txt文件</p><img src="/2021/10/23/EndNoteForFHY/image-20211023015340063-4960420.png" alt="image-20211023015340063" style="zoom:50%;"><p>然后你就在导入的文献中看到了导入的文献(๑¯㉨¯๑)   你可以对他进行分组等等</p><img src="/2021/10/23/EndNoteForFHY/image-20211023101434637-4960420.png" alt="image-20211023101434637" style="zoom:50%;"><p>但是需要注意的是，插入文献经常存在格式不对的情况，比如上图中的期刊名没有正确显示，双击这篇文献，进行修改，将期刊名进行补充，注意去掉%J等不需要的字符，随后保存。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023101709406-4960420.png" alt="image-20211023101709406" style="zoom:50%;"><p>如果你有这篇文章的pdf的话将其添加到附件，endnote就会将文献移动到你的库中。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023102157451-4960420.png" alt="image-20211023102157451" style="zoom:50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023102549686-4960420.png" alt="image-20211023102549686" style="zoom:50%;"></li><li><p><em>爱思唯尔（ScienceDirect）</em></p><p>如果你们学校购买了爱思唯尔的库的话，通过校网检索文献的方式找到需要的文献（各种文献网站下载引用的逻辑基本都是想通的），先进行下载。然后同样导入库中，需要注意的是endnote同时支持多种格式，enl ris也可以，在这里我们下载ris格式。可以直接打开ris文件，endnote就进行了导入 </p><img src="/2021/10/23/EndNoteForFHY/image-20211023103858485-4960420.png" alt="image-20211023103858485" style="zoom:50%;"><p>导入之后同样进行关联文献的操作，同上，略。</p></li><li><p><em>谷歌学术/百度学术</em></p><p>这两个网站最重要的作用不是进行文献下载的，而是有海量的文献引用资源。如果仅仅需要下载些文献的引用，可以用上（偶尔一些文献也可以通过这些网站直接下载）。</p><p>以谷歌学术（国内需要翻墙访问，当然也可以搜索谷歌学术镜像网站使用）为例：</p><img src="/2021/10/23/EndNoteForFHY/image-20211023104744862-4960420.png" alt="image-20211023104744862" style="zoom:50%;"><p>找到文献点击引用图标，下载enl格式文件打开，就将引用导入了endnote中。之后的操作同</p><p>百度学术同理</p></li><li><p><em>快捷绑定和导入文献的方法</em></p><p>还有一个快捷绑定文献及导入文献的方法，但是只对较新的英文文献的pdf起作用（中文文献支持不太好）。</p><p>下载一篇pdf文献 ，打开方式使用endnote打开，神奇的事情发生了，endnote会自动进行检索！！！并将该文件绑定到库中。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023105929726-4960420.png" alt="image-20211023105929726" style="zoom:50%;"></li></ol><img src="/2021/10/23/EndNoteForFHY/image-20211023110151334-4960420.png" alt="image-20211023110151334" style="zoom:50%;"><ol start="5"><li><p><em>手动新建文献（是在没找到引用的时候用）</em></p><img src="/2021/10/23/EndNoteForFHY/image-20211023110312620-4960420.png" alt="image-20211023110312620" style="zoom:50%;"><p>将文献类型、作者、年份、卷号等等重要的内容一一填入即可</p></li></ol><p>到这里我们就可以方便进行平时文献的管理和阅读了。</p><h2 id="3-文献的引用"><a href="#3-文献的引用" class="headerlink" title="3. 文献的引用"></a>3. 文献的引用</h2><p>到了要写论文的时候，自然是要引用各种文献。</p><p>如果正确安装了endnote后，Word会出现endnote插件，它与endnote软件关联着。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023111138549-4960420.png" alt="image-20211023111138549" style="zoom:50%;"><p>在我们一边写论文时候，一边就可以插入引用。首先将光标停留在文档中需要插入引用的位置，切换到endnote，选择被引用的文献，选择格式，点击引用。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023111515675-4960420.png" alt="image-20211023111515675" style="zoom:50%;"><p>然后文档栋光标位置就自动插入了文献的引用。他是动态进行变化的，如果在文档中进行了删除引用、更新引用的操作，相应的需要，及下文的详情都会变更。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023111747955-4960420.png" alt="image-20211023111747955" style="zoom:50%;"><p>也许你注意到了文档中演示的格式，其实并不那么完美，比如中文文献引用，也加入et al的英文引用规则，所以在文章定稿之后一个非常重要的操作就是，将文献转为纯文本格式，然后进行手动修改。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023112056977-4960420.png" alt="image-20211023112056977" style="zoom:50%;"><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>所以endnote最基本的操作到这里就结束了，它的功能非常强大，也希望你慢慢去摸索其他更好玩更好用的功能，写出好文章！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;EndNote是一个文献管理软件，使用它可以方便的对文献进行管理，同时通过它的嵌入工具，可以方便的边书写论文边插入参考文献。&lt;/p&gt;
&lt;p&gt;软件版本：&lt;/p&gt;
&lt;p&gt;endnote x9&lt;/p&gt;
&lt;p&gt;office 2016&lt;/p&gt;
&lt;h2 id=&quot;1-新建EndNote库</summary>
      
    
    
    
    <category term="生活" scheme="http://123.57.158.5/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="EndNote" scheme="http://123.57.158.5/tags/EndNote/"/>
    
  </entry>
  
  <entry>
    <title>由@Valid注解校验引发的问题之Integer与int的比较</title>
    <link href="http://123.57.158.5/2021/10/10/java-lang/"/>
    <id>http://123.57.158.5/2021/10/10/java-lang/</id>
    <published>2021-10-10T14:39:01.000Z</published>
    <updated>2021-10-10T14:58:20.522Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习spring boot过程中遇到的一个问题</p><p>我在一个请求体model中将需要校验的字段写成了这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateCategoryReq</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;商品分类id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>同时在controller中对该请求体进行了@Valid校验，最后发现，<strong>校验没有生效</strong>，且自动对id进行了填充（？？？）。最后发现@Valid校验本质是校验java.lang中的包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Valid &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而定义变量时候，int类型不允许为空，而integer是可以为null。所以请求体中会对id自动赋值为0。</p><p>所以需要将字段改为包装类定义，才能进行校验。</p><p>扩展 Integer与int的区别：</p><blockquote><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习spring boot过程中遇到的一个问题&lt;/p&gt;
&lt;p&gt;我在一个请求体model中将需要校验的字段写成了这样&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>java流处理</title>
    <link href="http://123.57.158.5/2021/10/06/java-stream/"/>
    <id>http://123.57.158.5/2021/10/06/java-stream/</id>
    <published>2021-10-06T02:27:30.000Z</published>
    <updated>2021-10-10T14:37:45.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li><strong>stream()</strong> − 为集合创建串行流。</li><li><strong>parallelStream()</strong> − 为集合创建并行流。拆分成小任务，使用线程来执行，当数量十分大时候，效率更高</li></ul><p>很容易理解对于需要串行依次执行的一般使用串行流，对于可以并发不需要按顺序执行的可以使用并行流。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;dsf&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;gjw&quot;</span>, <span class="string">&quot;persimmon&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉为空的字符串，保持原有顺序 使用串行流</span></span><br><span class="line">List&lt;String&gt; filteredString = strings.stream()</span><br><span class="line">  .filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 分别打印</span></span><br><span class="line">filteredString.forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计为空字符串的数量 可以使用并行流</span></span><br><span class="line">Long count = strings.parallelStream().filter(String::isEmpty).count();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>此外流还提供了很多limit map sort 方法等等，可以查看文档或者<a href="https://www.runoob.com/java/java8-streams.html">菜鸟教程</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除空字符串，用逗号将所有元素合并起来</span></span><br><span class="line">String combinedStrings = strings.stream().filter(string -&gt; !string.isEmpty()).</span><br><span class="line">  collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">System.out.println(combinedStrings);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素去重去空字符 前后加上减号输出</span></span><br><span class="line">List&lt;String&gt; handledStrings = strings.stream().filter(string -&gt; !string.isEmpty()).distinct()</span><br><span class="line">  .map(string -&gt; <span class="string">&quot;-&quot;</span>+string+<span class="string">&quot;-&quot;</span>).collect(Collectors.toList());</span><br><span class="line">handledStrings.forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取十个5以内的随机整数排序并平方处理后输出</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints(<span class="number">10</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  .map(x -&gt; x * x).forEach(System.out::println);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight pl</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring MongoTemplate踩坑</title>
    <link href="http://123.57.158.5/2021/09/14/springProject/"/>
    <id>http://123.57.158.5/2021/09/14/springProject/</id>
    <published>2021-09-14T15:29:08.000Z</published>
    <updated>2021-10-06T02:30:57.567Z</updated>
    
    <content type="html"><![CDATA[<p>在使用spring的MongoTemplate进行mongodb操作时候踩了许多坑，记录一下<a href="https://www.springcloud.cc/spring-data-mongodb.html#mongo-template">MongoTemplate</a>的一些操作。</p><h3 id="Criteria类"><a href="#Criteria类" class="headerlink" title="Criteria类"></a>Criteria类</h3><p>用于创建mongodb数据查询条件，这些criteria查询条件之间可以进行相互拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = Criteria.where(<span class="string">&quot;city&quot;</span>).is(<span class="string">&quot;Yichun&quot;</span>)</span><br><span class="line">  .and(<span class="string">&quot;age&quot;</span>).gte(<span class="number">18</span>);</span><br><span class="line">criteria.and(<span class="string">&quot;sex&quot;</span>).is(<span class="string">&quot;male&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是同一个查询字段不可以重复进行拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">if</span>(query.startTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">  criteria.and(<span class="string">&quot;create_time&quot;</span>).gt(startTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(query.endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">  criteria.and(<span class="string">&quot;create_time&quot;</span>).lt(endTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参考写法</span></span><br><span class="line"><span class="keyword">if</span>(query.startTime != <span class="keyword">null</span> &amp;&amp; query.endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">  criteria.and(<span class="string">&quot;create_time&quot;</span>).gt(startTime).lt(endTime);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(query.startTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">    criteria.and(<span class="string">&quot;create_time&quot;</span>).gt(startTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(query.endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">    criteria.and(<span class="string">&quot;create_time&quot;</span>).lt(endTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Criteria类中的 andOperator、orOperator可以对criteria查询条件进行组合使用，但是不可以重复拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = Criteria.where(<span class="string">&quot;city&quot;</span>).is(<span class="string">&quot;Shenzhen&quot;</span>);</span><br><span class="line">Criteria criteria1 = Criteria.where(<span class="string">&quot;age&quot;</span>).gt(<span class="number">18</span>);</span><br><span class="line">Criteria.andOperator(criteria,criteria1);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">criteria.andOperator(criteria1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果此时继续对criteria再次使用andOperator组合，查询条件将不可用</span></span><br><span class="line"><span class="comment">// 报错Due to limitations of the com.mongodb.BasicDocument, you can&#x27;t add a second ...</span></span><br><span class="line">criteria.andOperator(Criteria.where(<span class="string">&quot;gender&quot;</span>).is(<span class="string">&quot;male&quot;</span>));</span><br></pre></td></tr></table></figure><p>使用查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line">  </span><br><span class="line">Query query = <span class="keyword">new</span> Query(criteria);</span><br><span class="line">mongoTemplate.count(query,xxxDocument.class);</span><br><span class="line">mongoTemplate.findOne(query.xxxDocuent.class);</span><br></pre></td></tr></table></figure><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><blockquote><p>MongoDB 中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果。</p></blockquote><p>通过<a href="https://www.runoob.com/mongodb/mongodb-aggregate.html">聚合查询</a>可以对数据进行分组，统计等等。</p><p>聚合查询的条件由一个个管道（管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数）组成。</p><h4 id="example1"><a href="#example1" class="headerlink" title="example1"></a>example1</h4><p><code>unwind</code> 是对符合匹配出的内容按照data数组中每个字段进行分解，分解成一个个文档</p><p><code>getMappedResults</code>以map形式返回查询结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;xxDTO&gt; <span class="title">mongodbExample</span><span class="params">(xxQuery query)</span> </span>&#123;</span><br><span class="line">      Criteria criteria = Criteria.where(<span class="string">&quot;xx_column&quot;</span>).in(query.getxxList())</span><br><span class="line">              .and(<span class="string">&quot;xx&quot;</span>).in(query.getxxList())</span><br><span class="line">              .and(<span class="string">&quot;xxx&quot;</span>).is(query.getxx())</span><br><span class="line">              .and(<span class="string">&quot;xxxx&quot;</span>).is(query.getxx());</span><br><span class="line"></span><br><span class="line">      Aggregation aggregation = newAggregation(</span><br><span class="line">              match(criteria),</span><br><span class="line">              unwind(<span class="string">&quot;data&quot;</span>),</span><br><span class="line">              match(Criteria.where(<span class="string">&quot;data.y_name&quot;</span>).is(query.getxxName())),</span><br><span class="line">              project()</span><br><span class="line">                      .and(<span class="string">&quot;limit_id&quot;</span>).as(<span class="string">&quot;limit_id&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.x_name&quot;</span>).as(<span class="string">&quot;x_name&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.x_unit&quot;</span>).as(<span class="string">&quot;x_unit&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.x_value&quot;</span>).as(<span class="string">&quot;x_value&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_name&quot;</span>).as(<span class="string">&quot;y_name&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_unit&quot;</span>).as(<span class="string">&quot;y_unit&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_low&quot;</span>).as(<span class="string">&quot;y_low&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_high&quot;</span>).as(<span class="string">&quot;y_high&quot;</span>)</span><br><span class="line">                      .andExclude(<span class="string">&quot;_id&quot;</span>)</span><br><span class="line">      );</span><br><span class="line">      AggregationResults&lt;xxDTO&gt; aggregate = mongoTemplate.aggregate(aggregation, <span class="string">&quot;INPUT_COLLECTION_NAME&quot;</span>, xxxDTO.class);</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">return</span> aggregate.getMappedResults();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h4><blockquote><p>此示例基于MongoDB聚合框架文档中的“ <a href="http://docs.mongodb.org/manual/tutorial/aggregation-examples/#largest-and-smallest-cities-by-state">最大和最小城市”</a>示例。我们添加了额外的排序，以使用不同的MongoDB版本生成稳定的结果。在这里，我们希望通过使用聚合框架按每个州的人口返回最小和最大的城市。此示例演示分组，排序和投影（选择）。</p></blockquote><p><code>nested</code>用于在聚合查询过程中创建一个次级文档，在这里面分别是“biggestCity”和“samllestCity”，同时将”biggestCity”，”biggestPop”字段名分别绑定为”name”, “population”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipInfo</span> </span>&#123;</span><br><span class="line">   String id;</span><br><span class="line">   String city;</span><br><span class="line">   String state;</span><br><span class="line">   <span class="meta">@Field(&quot;pop&quot;)</span> <span class="keyword">int</span> population;</span><br><span class="line">   <span class="meta">@Field(&quot;loc&quot;)</span> <span class="keyword">double</span>[] location;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   <span class="keyword">int</span> population;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipInfoStats</span> </span>&#123;</span><br><span class="line">   String id;</span><br><span class="line">   String state;</span><br><span class="line">   City biggestCity;</span><br><span class="line">   City smallestCity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.data.mongodb.core.aggregation.Aggregation.*;</span><br><span class="line"></span><br><span class="line">TypedAggregation&lt;ZipInfo&gt; aggregation = newAggregation(ZipInfo.class,</span><br><span class="line">    group(<span class="string">&quot;state&quot;</span>, <span class="string">&quot;city&quot;</span>)</span><br><span class="line">       .sum(<span class="string">&quot;population&quot;</span>).as(<span class="string">&quot;pop&quot;</span>),</span><br><span class="line">    sort(ASC, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;state&quot;</span>, <span class="string">&quot;city&quot;</span>),</span><br><span class="line">    group(<span class="string">&quot;state&quot;</span>)</span><br><span class="line">       .last(<span class="string">&quot;city&quot;</span>).as(<span class="string">&quot;biggestCity&quot;</span>)</span><br><span class="line">       .last(<span class="string">&quot;pop&quot;</span>).as(<span class="string">&quot;biggestPop&quot;</span>)</span><br><span class="line">       .first(<span class="string">&quot;city&quot;</span>).as(<span class="string">&quot;smallestCity&quot;</span>)</span><br><span class="line">       .first(<span class="string">&quot;pop&quot;</span>).as(<span class="string">&quot;smallestPop&quot;</span>),</span><br><span class="line">    project()</span><br><span class="line">       .and(<span class="string">&quot;state&quot;</span>).previousOperation()</span><br><span class="line">       .and(<span class="string">&quot;biggestCity&quot;</span>)</span><br><span class="line">          .nested(bind(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;biggestCity&quot;</span>).and(<span class="string">&quot;population&quot;</span>, <span class="string">&quot;biggestPop&quot;</span>))</span><br><span class="line">       .and(<span class="string">&quot;smallestCity&quot;</span>)</span><br><span class="line">          .nested(bind(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;smallestCity&quot;</span>).and(<span class="string">&quot;population&quot;</span>, <span class="string">&quot;smallestPop&quot;</span>)),</span><br><span class="line">    sort(ASC, <span class="string">&quot;state&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">AggregationResults&lt;ZipInfoStats&gt; result = mongoTemplate.aggregate(aggregation, ZipInfoStats.class);</span><br><span class="line">ZipInfoStats firstZipInfoStats = result.getMappedResults().get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>请注意，<code>ZipInfo</code>类映射给定输入集合的结构。<code>ZipInfoStats</code>类以所需的输出格式定义结构。</p><p>上述列表使用以下算法：</p><ol><li>使用<code>group</code>操作从输入集合中定义组。分组标准是<code>state</code>和<code>city</code>字段的组合，它们形成组的ID结构。我们使用<code>sum</code>运算符从分组元素聚合<code>population</code>属性的值，并将结果保存在<code>pop</code>字段中。</li><li>使用<code>sort</code>操作按<code>pop</code>，<code>state</code>和<code>city</code>字段按升序对中间结果进行排序，以便最小的城市位于顶部，最大的城市位于结果的底部。请注意，<code>state</code>和<code>city</code>上的排序是针对组ID字段（MongoDB处理的Spring Data）隐式执行的。</li><li>再次使用<code>group</code>操作将中间结果分组为<code>state</code>。请注意，<code>state</code>再次隐式引用组ID字段。我们在<code>project</code>操作中分别调用<code>last(…)</code>和<code>first(…)</code>运算符来选择最大和最小城市的名称和人口数。</li><li>从上一个<code>group</code>操作中选择<code>state</code>字段。请注意，<code>state</code>再次隐式引用组ID字段。由于我们不希望显示隐式生成的ID，因此我们使用<code>and(previousOperation()).exclude()</code>从上一个操作中排除ID。因为我们想要在输出类中填充嵌套的<code>City</code>结构，所以我们必须使用嵌套方法发出适当的子文档。</li><li>在<code>sort</code>操作中按升序对<code>StateStats</code>的结果列表按其状态名称进行排序。</li></ol><p>请注意，我们将作为第一个参数传递的<code>ZipInfo</code>类的输入集合的名称派生到<code>newAggregation</code>方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用spring的MongoTemplate进行mongodb操作时候踩了许多坑，记录一下&lt;a href=&quot;https://www.springcloud.cc/spring-data-mongodb.html#mongo-template&quot;&gt;MongoTemplate&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="实战" scheme="http://123.57.158.5/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="Mongo" scheme="http://123.57.158.5/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>AOP环绕通知</title>
    <link href="http://123.57.158.5/2021/08/30/aop-round-advice/"/>
    <id>http://123.57.158.5/2021/08/30/aop-round-advice/</id>
    <published>2021-08-29T16:26:20.000Z</published>
    <updated>2021-09-01T12:51:33.986Z</updated>
    
    <content type="html"><![CDATA[<p>简单演示aop中的环绕通知的作用实例，用于打印方法执行的时间进行排查，优化项目效率。</p><p>项目结构：</p><p><img src="/2021/08/30/aop-round-advice/image-20210831004102587.png" alt="image-20210831004102587"></p><p>UserDao、UserService等略</p><p>MethodChecker：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodChecker</span> </span>&#123;</span><br><span class="line"><span class="comment">//    ProceedingJoinPoint在原有JoinPoint基础上可以控制目标方法是否执行</span></span><br><span class="line"><span class="comment">//    环绕通知 需要将目标方法返回值返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">check</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//        执行方法，执行proceed方法之前的就相当于前置通知，后面的相当于后置通知，其本身还可以处理通知返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">            Object ret = proceedingJoinPoint.proceed();</span><br><span class="line">            <span class="keyword">long</span> endTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">            <span class="keyword">long</span> durationTime = endTime-startTime;</span><br><span class="line">            SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH-mm-ss SSS&quot;</span>);</span><br><span class="line">            String now = simpleDateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">            String className = proceedingJoinPoint.getTarget().getClass().getName();</span><br><span class="line">            String methodName = proceedingJoinPoint.getSignature().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;---&gt;&quot;</span>+now+<span class="string">&quot;  &quot;</span>+className+<span class="string">&quot;.&quot;</span>+methodName+<span class="string">&quot;(&quot;</span>+durationTime+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.orange.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.orange.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodChecker&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.orange.aspect.MethodChecker&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.orange..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;methodChecker&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;check&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringApplication:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.orange.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">        UserService userService = applicationContext.getBean(<span class="string">&quot;userService&quot;</span>,UserService.class);</span><br><span class="line">        userService.createUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解AOP"><a href="#注解AOP" class="headerlink" title="注解AOP"></a>注解AOP</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    使用ioc注解式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.orange&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用aop注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>给UserDao、UserService添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>给切面方法添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodChecker</span> </span>&#123;</span><br><span class="line"><span class="comment">//    ProceedingJoinPoint在原有JoinPoint基础上可以控制目标方法是否执行</span></span><br><span class="line"><span class="comment">//    环绕通知 需要将目标方法返回值返回</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.orange..*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">check</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单演示aop中的环绕通知的作用实例，用于打印方法执行的时间进行排查，优化项目效率。&lt;/p&gt;
&lt;p&gt;项目结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/08/30/aop-round-advice/image-20210831004102587.png&quot; alt=&quot;i</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="AOP" scheme="http://123.57.158.5/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>使用反射简单模拟spring的ioc容器</title>
    <link href="http://123.57.158.5/2021/08/27/spring-ioc/"/>
    <id>http://123.57.158.5/2021/08/27/spring-ioc/</id>
    <published>2021-08-26T16:12:59.000Z</published>
    <updated>2021-08-26T16:23:03.161Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用反射简单模拟Spring的ioc容器</span><br><span class="line">使用依赖dom4j</span><br></pre></td></tr></table></figure><p>项目结构：</p><p><img src="/2021/08/27/spring-ioc/image-20210827001816735.png" alt="image-20210827001816735"></p><h2 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruits</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象，添加getset方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String origin;</span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString方法方便进行输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fruits&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, origin=&#x27;&quot;</span> + origin + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrigin</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.origin = origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Float price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!--关联entity中对象进行配置，property指的是通过对象getset方法进行初始化--&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;durian&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.orange.entity.Fruits&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;durian&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;origin&quot;</span> value=<span class="string">&quot;Thailand&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;price&quot;</span> value=<span class="string">&quot;99.0&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.context;</span><br><span class="line"><span class="comment">// 创建接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Node;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="comment">//    使用hashmap保存ioc容器的数据，数据以beanid 和 Fruits对象形式保存</span></span><br><span class="line">    Map&lt;String, Object&gt; iocContainer = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            使用dom4j读取配置文件</span></span><br><span class="line">            String filePath = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;/applicationContext.xml&quot;</span>).getPath();</span><br><span class="line">            filePath = <span class="keyword">new</span> URLDecoder().decode(filePath, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            Document document = <span class="keyword">new</span> SAXReader().read(<span class="keyword">new</span> File(filePath));</span><br><span class="line"><span class="comment">//            获取配置文件下的bean</span></span><br><span class="line">            List&lt;Node&gt; nodes = document.getRootElement().selectNodes(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line"><span class="comment">//                获取到beanid和class，使用反射创建对象</span></span><br><span class="line">                Element el = (Element) node;</span><br><span class="line">                String beanId = el.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String className = el.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                Class c = Class.forName(className);</span><br><span class="line">                Object obj = c.getConstructor().newInstance();</span><br><span class="line"><span class="comment">//                获取每一个bean下的property 获取name和value 反射给对象注入属性</span></span><br><span class="line">                List&lt;Node&gt; props = el.selectNodes(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Node prop : props) &#123;</span><br><span class="line">                    Element pro = (Element) prop;</span><br><span class="line">                    String propertyName = pro.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                    Object propertyValue = pro.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    String setMethodName = <span class="string">&quot;set&quot;</span> + propertyName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">                    Type fieldType = c.getDeclaredField(propertyName).getGenericType();</span><br><span class="line">                    Method setMethod = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (fieldType.toString().equals(<span class="string">&quot;class java.lang.String&quot;</span>)) &#123;</span><br><span class="line">                        setMethod = c.getMethod(setMethodName, String.class);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fieldType.toString().equals(<span class="string">&quot;class java.lang.Float&quot;</span>)) &#123;</span><br><span class="line">                        setMethod = c.getMethod(setMethodName, Float.class);</span><br><span class="line">                        propertyValue = Float.parseFloat((String) propertyValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setMethod.invoke(obj, propertyValue);</span><br><span class="line">                &#125;</span><br><span class="line">                iocContainer.put(beanId, obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">        Object obj = iocContainer.get(beanId);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="IocApplication-java"><a href="#IocApplication-java" class="headerlink" title="IocApplication.java"></a>IocApplication.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.orange.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.orange.context.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.orange.entity.Fruits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IocApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">        Fruits durian = (Fruits) context.getBean(<span class="string">&quot;durian&quot;</span>);</span><br><span class="line">        System.out.println(durian);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="IOC" scheme="http://123.57.158.5/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>ssm部分笔记</title>
    <link href="http://123.57.158.5/2021/08/15/ssm/"/>
    <id>http://123.57.158.5/2021/08/15/ssm/</id>
    <published>2021-08-15T02:26:30.000Z</published>
    <updated>2021-08-26T16:15:09.078Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis 默认开启一级缓存，只在一个sqlsession中使用，不论进行多少次相同的sql查询，结果都在同一个内存地址中。</p><p>commit操作会强制清空一二级缓存</p><p>二次缓存在mapper的namespace中生效，二级缓存的设置：</p><p><img src="/2021/08/15/ssm/image-20210815103904479.png" alt="image-20210815103904479"></p><p>对于列表中存储多个查询对象的，会被当作一个对象存储进缓存，缓存命中率低，所以不推荐使用缓存。</p><p><img src="/2021/08/15/ssm/image-20210815104627699.png" alt="image-20210815104627699"></p><p>一对多（one to many）的one表的xml配置</p><p><img src="/2021/08/15/ssm/image-20210815202133723.png" alt="image-20210815202133723"></p><p>多对一查询（many to one） many表的xml配置</p><p><img src="/2021/08/15/ssm/image-20210815223023718.png" alt="image-20210815223023718"></p><p>xxxx 略，暂时不更新笔记内容了</p><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><p>尤其注意xml的配置问题，特别容易导致错误</p><p>例如xml中mysql数据库的引入，注意是在cj.jdbc包下面，引用错误会导致NoClassDefFoundError</p><h3 id="bean-scope中的单例与多例模式对比"><a href="#bean-scope中的单例与多例模式对比" class="headerlink" title="bean scope中的单例与多例模式对比"></a>bean scope中的单例与多例模式对比</h3><p><img src="/2021/08/15/ssm/Snipaste_2021-08-25_15-13-31.png" alt="Snipaste_2021-08-25_15-13-31"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mybatis 默认开启一级缓存，只在一个sqlsession中使用，不论进行多少次相同的sql查询，结果都在同一个内存地址中。&lt;/p&gt;
&lt;p&gt;commit操作会强制清空一二级缓存&lt;/p&gt;
&lt;p&gt;二次缓存在mapper的namespace中生效，二级缓存的设置：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="MyBatis" scheme="http://123.57.158.5/tags/MyBatis/"/>
    
  </entry>
  
</feed>
