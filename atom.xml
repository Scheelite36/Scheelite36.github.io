<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只柑の博客</title>
  
  
  <link href="http://123.57.158.5/atom.xml" rel="self"/>
  
  <link href="http://123.57.158.5/"/>
  <updated>2022-02-24T16:47:18.703Z</updated>
  <id>http://123.57.158.5/</id>
  
  <author>
    <name>一只柑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="http://123.57.158.5/2022/02/23/java-threadLocal/"/>
    <id>http://123.57.158.5/2022/02/23/java-threadLocal/</id>
    <published>2022-02-23T15:40:03.000Z</published>
    <updated>2022-02-24T16:47:18.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal两大使用场景"><a href="#ThreadLocal两大使用场景" class="headerlink" title="ThreadLocal两大使用场景"></a>ThreadLocal两大使用场景</h2><ul><li>每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random，他们都是线程不安全的类）</li><li>每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦</li></ul><h3 id="每个线程需要一个独享的对象"><a href="#每个线程需要一个独享的对象" class="headerlink" title="每个线程需要一个独享的对象"></a>每个线程需要一个独享的对象</h3><p>例如我们需要用创建一个打印时间的线程，可以这样做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUsage0</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一个获取时间的工具类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDate</span><span class="params">(<span class="keyword">int</span> seconds)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 转化为毫秒</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span>*seconds);</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个打印时间的线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(ThreadLocalUsage0.getDate(<span class="number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要1000个线程来打印时间，可以将打印日期的任务提交到线程池中。同时为了不重复创建<code>SimpleDateFormat</code>对象，则让所有线程使用了同一个<code>SimpleDateFormat</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUsage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDate</span><span class="params">(<span class="keyword">int</span> seconds)</span></span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span>*seconds);</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(getDate(finalI));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是因为<code>SimpleDateFormat</code>类是线程不安全的，以上代码中使用同一个<code>SimpleDateFormat</code>对象后会导致部分打印出来的结果是一致的。解决办法是给线程加锁，防止出现访问同一个线程导致的线程安全问题。排队执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUsage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDate</span><span class="params">(<span class="keyword">int</span> seconds)</span></span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span>*seconds);</span><br><span class="line">        String dateString = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(ThreadLocalUsage2.class)&#123;</span><br><span class="line">            dateString = dateFormat.format(date);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dateString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(getDate(finalI));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁之后，打印日期的线程依次使用<code>SimpleDateFormat</code>，但是此时效率变低了。终极办法就是使用<code>ThreadLocal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUsage3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDate</span><span class="params">(<span class="keyword">int</span> seconds)</span></span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span>*seconds);</span><br><span class="line">        <span class="comment">// 使用threadLocal中的变量</span></span><br><span class="line">        <span class="keyword">return</span> ThreadSafeFormat.sdfl.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(getDate(finalI));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeFormat</span></span>&#123;</span><br><span class="line">    <span class="comment">// 普通写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; sdf = <span class="keyword">new</span> ThreadLocal&lt;&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//lambada表达式写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; sdfl = ThreadLocal.withInitial(</span><br><span class="line">            ()-&gt;<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YY-MM-dd hh:mm:ss&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每个线程内需要保存全局变量"><a href="#每个线程内需要保存全局变量" class="headerlink" title="每个线程内需要保存全局变量"></a>每个线程内需要保存全局变量</h3><p>典型场景如前端请求时候，需要判断每次用户信息，用户信息也经常需要层层传递。如果将用户信息放在一个对象中供所有线程使用，可以使用<code>Sychronized</code> 也可以用<code>ConcurrentHashMap</code>进行加锁，但是会对性能有所影响。</p><p>比如用户的信息一但生成后需要被很多线程的服务共享：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * threadLocal应用场景2</span></span><br><span class="line"><span class="comment"> * 当前用户需要被所有服务共享</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLcoalUsage10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service1.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name: &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadUserHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; user = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 生成当前用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;giao&quot;</span>);</span><br><span class="line">        ThreadUserHolder.user.set(user);</span><br><span class="line">        Service2.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get from Service2: &quot;</span> + ThreadUserHolder.user.get());</span><br><span class="line">        Service3.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get from Service3: &quot;</span> + ThreadUserHolder.user.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>让某个需要用的对象在<strong>线程间隔离</strong>（每个线程都有自己独立的对象）</li><li>在任何方法中都可以<strong>轻松获取</strong>到该对象</li></ol><p><font color="red">根据对象的生成时机的不同，选择initialValue或set来保存对象</font></p><h4 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a>initialValue</h4><p>在ThreadLocal第一次get的时候把对象给初始化处理啊，对像的初始化时机可以由我们控制</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>如果需要保存到ThreadLocal里的对象的生成时机不由我们随意控制，例如拦截器生成的用户信息</p><p>用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用</p><h4 id="ThreadLocal带来的好处"><a href="#ThreadLocal带来的好处" class="headerlink" title="ThreadLocal带来的好处"></a>ThreadLocal带来的好处</h4><ol><li>达到线程安全</li><li>不需要加锁，提高执行效率</li><li>更高效的利用内存，节省开销</li><li>避免了多次传参的繁琐，代码耦合度低，优雅</li></ol><h2 id="ThreadLocal主要方法介绍"><a href="#ThreadLocal主要方法介绍" class="headerlink" title="ThreadLocal主要方法介绍"></a>ThreadLocal主要方法介绍</h2><h3 id="T-initialValue-初始化"><a href="#T-initialValue-初始化" class="headerlink" title="T initialValue() 初始化"></a>T initialValue() 初始化</h3><ol><li>该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用<code>get</code>的时候，才会触发</li><li>当线程第一次使用<code>get</code>方法访问变量时，将调用此方法。（如果已经是set方法写入过的，直接返回<code>set</code>的value</li><li>每个线程最多调用一次此方法，但是如果已经调用了<code>remove()</code>后，再调用<code>get()</code></li><li>如果不重写本方法，这个方法会返回null，一般使用匿名内部类方法来重写<code>initialValue()</code>方法</li></ol><p>void set(T t) 为线程设置一个新值</p><p>T get() 得到线程对应的value，如果首次调用会通过initalValue得到值</p><p>void remove() 删除对应这个线程的值</p><h2 id="ThreadLocal详解"><a href="#ThreadLocal详解" class="headerlink" title="ThreadLocal详解"></a>ThreadLocal详解</h2><p>每个Thread对象中都持有一个ThreadLcoalMap成员对象，但是ThreadLocalMap中可以有许多个ThreadLocal对象</p><p><img src="/2022/02/23/java-threadLocal/image-20220224235821950.png" alt="image-20220224235821950"></p><p><code>get</code>方法是先取出当前线程的ThreadLocalMap，然后调用<code>map.getEntry</code>方法，把本ThreadLocal的引用作为参数传入</p><p>取出map中属于本ThreadLocal的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>注意：这个map以及map中的key和value都是<font color="red">保存在线程</font>中的，而不是保存在threadLocal中</em></p><p><code>intialValue</code>方法 没有默认实现，如果要用initialValue方法，需要自己实现，通常使用匿名内部类的方法实现</p><h4 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h4><p>也就是Thread.threadLocals</p><p>ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个<font color="red">键值对数组<code>Entry[] </code>table</font>，可以认为是一个map，键值对：</p><p>key： ThreadLocal</p><p>value：实际需要的成员变量 比如user或者simpleDateFormat对象</p><p>？但是解决Hash冲突的方式与HashMap不同：</p><p>ThreadLocal使用的是链表拉链和红黑树，ThreadLocalMap这里采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置，而不是链表拉链。</p><h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>指某个对象不再有用，但是占用的内存却不能被回收 最终导致OOM</p><p><strong>弱引用</strong>特点：如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">      <span class="keyword">super</span>(k);</span><br><span class="line">      value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Value的泄漏：</p><p>ThreedLocalMap的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用。正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有扔河强引用了。但是，如果线程不终止（比如线程需要保持很久），那么key对应的value久不能被回收，因为有以下的调用链：</p><p><font color="red">Thread -&gt; ThreadLocalMap -&gt; Entry(key为null) -&gt;Value</font></p><p>因为vlaue和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能出现OOM</p><p>但是在jdk的设计中 扫描到key为null的Entry，会把对应的value设置为null。比如LocalThread中的很多方法都会对key进行判断。</p><p>但是如果一个ThreadLocal不被使用，它的很多方法也不调用，就可能导致value的内存泄漏</p><h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>调用<code>remove()</code>方法，就会删除对应的Entry对象，可以避免内存泄漏，所以使用完ThreadLocal后，应该调用该方法。（比如用户的退出登陆操作）</p><h3 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h3><p>在get之前，必须先set，否则会报空指针异常？不是的，如果不进行set，也会在get时候会直接返回null，不会报空指针。注意可能在包装类型转基本类型时候发生空指针异常</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ThreadLocal两大使用场景&quot;&gt;&lt;a href=&quot;#ThreadLocal两大使用场景&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal两大使用场景&quot;&gt;&lt;/a&gt;ThreadLocal两大使用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个线程</summary>
      
    
    
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO操作笔记</title>
    <link href="http://123.57.158.5/2022/02/06/java-io/"/>
    <id>http://123.57.158.5/2022/02/06/java-io/</id>
    <published>2022-02-06T05:58:15.000Z</published>
    <updated>2022-02-10T13:43:00.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件输入输出流"><a href="#文件输入输出流" class="headerlink" title="文件输入输出流"></a>文件输入输出流</h3><p><code>FileInputStream</code></p><ul><li>从文件系统中某个文件中获得输入字节</li><li>用于读取诸如图像数据之类的原始字节流</li></ul><p><code>read</code>方法读取数据字节（逐字节），可选参数 <code>byte[] b</code> <em>从输入流中最多b.length个字节的数据读取一个byte数组中</em>，<code>int off,int len</code>从off位置开始读取最多len个字节</p><p><code>close</code>方法释放资源</p><p>返回值-1表示读到文件末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用文本数据演示，但是实际使用中不推荐使用字节流读取，而用字符流读取。</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;io/fileStream.txt&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 逐个字节读取，然后转化为字符</span></span><br><span class="line"><span class="keyword">while</span> ((n = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.print((<span class="keyword">char</span>) n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">fis.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取指定数量的字节流输出</span></span><br><span class="line">FileInputStream fis2 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;io/fileStream.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 指定读取36个字节的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">36</span>];</span><br><span class="line">fis2.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">fis2.close();</span><br></pre></td></tr></table></figure><p><code>FileOutputStream</code></p><p><code>write</code>方法写入字节数据 </p><p>可选参数 <code>int b</code>写入指定的字节（ascii），<code>byte[] b</code>写入指定字节流的数据 </p><p><code>close</code>释放系统资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加模式写入</span></span><br><span class="line">FileOutputStream fos= <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;io/fileStream.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">fos.write(<span class="number">13</span>);</span><br><span class="line"><span class="comment">// 写入字符g</span></span><br><span class="line">fos.write(<span class="number">103</span>);</span><br><span class="line"><span class="comment">// 字符串转字节数组输入</span></span><br><span class="line">fos.write(<span class="string">&quot;iao&quot;</span>.getBytes());</span><br><span class="line">fos.write(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p><strong>文件复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis  = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;io/fileStream.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;io/temp.txt&quot;</span>);</span><br><span class="line"><span class="comment">//一次性读取1024个字节</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((fis.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">  fos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p>值得注意的是使用这样的方法拷贝时候可能会导致复制后的文件比原来稍大，因为最后一次读取的实际内容可能小于1024；可以改按实际长度读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((n = fis.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">  fos.write(b,<span class="number">0</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>前面的输入输出流是直接从ROM中读取，如果直接从内存中读取，那么速度则大大提高。这就是<strong>缓冲流</strong></p><p><code>BufferedInputStream</code>和<code>BufferedOutputStream</code></p><p>在文件写入过程中，缓冲区的数据如果没有满不会被写入到文件中，需要有<code>flush</code>清空操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;io/temp.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">bos.write(<span class="string">&quot;\n20220206, on the train...&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 清空缓冲区操作</span></span><br><span class="line">bos.flush();</span><br><span class="line">bos.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p><code>close</code>其实也会自动将缓冲区情况，但是习惯flush和close都写</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><code>InputStreamReader</code>和<code>OutputStreamWriter</code>。<strong>字节字符转化流</strong></p><p><code>BufferedReader/BufferedWriter</code> 缓冲读写方法，可配合输入输出流使用，增加读写速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;io/fileStream.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 构建fos对象，文件不存在会自动创建</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line"><span class="comment">// osw对象 将输入的字符流转换字节流对象fos进行写操作</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 使用缓冲，增加文件读写速度</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line"><span class="comment">// 写入缓冲区</span></span><br><span class="line">bw.append(<span class="string">&quot;随便输入一些东西&quot;</span>);</span><br><span class="line">bw.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">bw.append(<span class="string">&quot;write something&quot;</span>);</span><br><span class="line"><span class="comment">// 关闭写入流 缓冲区内容写入文件</span></span><br><span class="line">osw.close();</span><br><span class="line"><span class="comment">//关闭输出流，释放系统资源</span></span><br><span class="line">fos.close();</span><br><span class="line"><span class="comment">// 关闭缓冲</span></span><br><span class="line">bw.close();</span><br><span class="line"><span class="comment">// 构建fip对象</span></span><br><span class="line">FileInputStream fip = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="comment">// 构建isr对象读取字节流 转换为字符流</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fip,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//使用缓冲，增加文件读写速度</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span>(br.ready())&#123;</span><br><span class="line">  <span class="comment">//转化为char对象添加到string中</span></span><br><span class="line">  sb.append((<span class="keyword">char</span>)br.read());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line"><span class="comment">// 关闭读取流</span></span><br><span class="line">isr.close();</span><br><span class="line"><span class="comment">// 关闭输入流，释放系统资源</span></span><br><span class="line">fip.close();</span><br><span class="line"><span class="comment">// 关闭缓冲</span></span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><p>把java对象转化为字节序列的过程</p><p>创建类 继承Serializable接口；创建对象；将对象进行序列化，反序列化读取对象信息。</p><p><code>ObjectInputStream</code>, <code>ObjectOutputStream</code> 对象的序列化类</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文件输入输出流&quot;&gt;&lt;a href=&quot;#文件输入输出流&quot; class=&quot;headerlink&quot; title=&quot;文件输入输出流&quot;&gt;&lt;/a&gt;文件输入输出流&lt;/h3&gt;&lt;p&gt;&lt;code&gt;FileInputStream&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从文件系统中某个</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法之next数组代码理解</title>
    <link href="http://123.57.158.5/2021/12/29/kmp-next-list/"/>
    <id>http://123.57.158.5/2021/12/29/kmp-next-list/</id>
    <published>2021-12-29T14:49:53.000Z</published>
    <updated>2021-12-30T16:17:38.175Z</updated>
    
    <content type="html"><![CDATA[<p>kmp算法中next数组指的是当模式串某个位置匹配失败的情况下，应该跳转到模式串的哪个位置继续匹配。</p><p>next数组求法：</p><p><img src="/2021/12/29/kmp-next-list/image-20211229225226560.png" alt="image-20211229225226560"></p><p>就是找前缀和后缀相同的个数：</p><p><img src="/2021/12/29/kmp-next-list/image-20211231000830448.png" alt="image-20211231000830448"></p><p>代码求next数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] ch) &#123;</span><br><span class="line">  <span class="keyword">int</span> len = ch.length;</span><br><span class="line">  <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">  <span class="comment">// 模式串序号，第一个序号为1</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 模式串第i位匹配失败后跳转序号，第一个为0</span></span><br><span class="line">  <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">  next[i] = j;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span> || ch[i] == ch[j])</span><br><span class="line">      next[++i] = ++j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      j = next[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nextVal数组是next数组的优化，如果<code>ch[i]==ch[j]</code>成立就可以令<code>next[i]=next[j]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextVal(<span class="keyword">char</span>[] ch) &#123;</span><br><span class="line">  <span class="keyword">int</span> len = ch.length;</span><br><span class="line">  <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">  next[i] = j;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span> || ch[i] == ch[j]) &#123;</span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      <span class="keyword">if</span> (ch[i] != ch[j])</span><br><span class="line">        next[i] = j;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        next[i] = next[j];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      j = next[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pattern</span><span class="params">(String main, String model)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] m = main.toCharArray();</span><br><span class="line">  <span class="keyword">char</span>[] mo = model.toCharArray();</span><br><span class="line">  <span class="keyword">int</span>[] nextval = getNextVal(mo);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 逐个匹配，使用nextval数组减少匹配次数，跳到对应位置</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; mo.length &amp;&amp; ans &lt; m.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m[ans] == mo[i]) &#123;</span><br><span class="line">      ++ans;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        ++ans;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        i = nextval[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果带匹配的字符串index等于长度的话</span></span><br><span class="line">  <span class="keyword">if</span> (i == mo.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> ans - i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;kmp算法中next数组指的是当模式串某个位置匹配失败的情况下，应该跳转到模式串的哪个位置继续匹配。&lt;/p&gt;
&lt;p&gt;next数组求法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/12/29/kmp-next-list/image-20211229225226560.pn</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识补充</title>
    <link href="http://123.57.158.5/2021/12/26/java-thread/"/>
    <id>http://123.57.158.5/2021/12/26/java-thread/</id>
    <published>2021-12-26T15:26:12.000Z</published>
    <updated>2022-02-10T14:17:21.303Z</updated>
    
    <content type="html"><![CDATA[<img src="/2021/12/26/java-thread/image-20211226233842837.png" alt="image-20211226233842837" style="zoom:50%;"><h3 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h3><ol><li>创建继承Thread类的方法，重写run方法；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">xxxx;</span><br><span class="line">System.out.println(getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><ol><li>实现runnable接口方法</li></ol><p>因为java不支持多继承；同时也不打算重写Thread类其他方法时候可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">xxx;</span><br><span class="line">System.out.println(Thread.currentThread.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyRunnable run = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(run);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h3 id="线程的几个主要方法"><a href="#线程的几个主要方法" class="headerlink" title="线程的几个主要方法"></a>线程的几个主要方法</h3><p><code>sleep()</code>和<code>yield()</code>都是线程类的静态方法，<code>join()</code>是线程对象的调用方法</p><p><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>这三个都是Object对象方法，用于协调多个线程对共享数据的读取。</p><p>它们都是用于协调多个线程对共享数据的存取，所以必须在Synchronized语句块内使用这三个方法。Synchronized这个关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出Synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。 </p><p>(1) wait()方法使当前线程暂停执行并<strong>释放对象锁</strong>标志，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。</p><p>(2) 当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。<br>(3) notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中</p><p><code>sleep()</code>释放cpu资源，不释放锁资源了；<code>wait()</code>释放cpu资源和锁资源</p><p>1.sleep：Thread类的方法，必须带一个时间参数。<strong>会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段）</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。</p><p>2.yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是<strong>不能由用户指定暂停多长时间 ，</strong>并且yield()方法<strong>只能让同优先级的线程</strong>有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入<strong>到可执行状态后</strong>马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</p><p>3.wait：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒 (notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒) 即放入锁池中竞争同步锁 </p><p>4.join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。</p><p>等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p><h3 id="线程同步-通信"><a href="#线程同步-通信" class="headerlink" title="线程同步/通信"></a>线程同步/通信</h3><p>解决多线程运行的问题：</p><img src="/2021/12/26/java-thread/image-20220210215810109.png" alt="image-20220210215810109" style="zoom:50%;"><p>sychronized关键字 可用于成员方法、静态方法、语句块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">svaeAccount</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;&#125;</span><br></pre></td></tr></table></figure><p>关于线程相关方法的使用参见github上关于线程的学习代码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2021/12/26/java-thread/image-20211226233842837.png&quot; alt=&quot;image-20211226233842837&quot; style=&quot;zoom:50%;&quot;&gt;

&lt;h3 id=&quot;创建线程的方法&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池解析</title>
    <link href="http://123.57.158.5/2021/12/21/java-thread-pool/"/>
    <id>http://123.57.158.5/2021/12/21/java-thread-pool/</id>
    <published>2021-12-21T14:08:54.000Z</published>
    <updated>2021-12-26T13:38:35.622Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线程池</strong>就是为了处理避免反复创建并销毁县城所带来的开销问题</p><p><strong>corePoolsize</strong> 核心线程数</p><p><strong>maxPoolSize</strong>在核心线程数之上，最大的线程数量</p><p>达到核心线程数之后，会将任务放入队列，队列满了，创建线程直到最大线程数，再大于之后则拒绝</p><img src="/2021/12/21/java-thread-pool/image-20211221221954658.png" alt="image-20211221221954658" style="zoom:50%;"><p><strong>workQueye</strong>任务存储队列</p><p>常见队列类型</p><ul><li>直接交接：<strong>SynchronousQueue</strong>，队列无容量，直接创建线程</li><li>无界队列：<strong>LinkedBlockingQueue</strong>，队列放不满，最大线程数失效。容易导致OOM异常</li><li>有界队列：<strong>ArrayBlockingQueue</strong>，队列满了，才创建线程</li></ul><p><strong>keepAliveTime</strong>当超过核心线程的多余线程空闲时间超过了这个数，线程被回收</p><p><strong>TreadFactory</strong>用于创建线程，默认使用Executors.defaultThreadFactory()，创建出来的线程都在一个线程组，优先级都是5，都不是守护线程。这个参数可自定义线程名，线程组，优先级和是否为守护线程（服务其他线程的线程，比如垃圾回收线程）等。</p><h3 id="自动创建线程池的风险"><a href="#自动创建线程池的风险" class="headerlink" title="自动创建线程池的风险"></a>自动创建线程池的风险</h3><p>自动创建的常见方法：</p><p>例如我们通过Executors.newFixedThreadPool(n)自动创建线程，执行的线程数最大就是n</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// ExecutorService executorService = Executors.newFixedThreadPool(3);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> FixedThreadDemo.Task());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个线程用于演示固定大小的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们的执行任务不停的创建，单固定线程数有限，执行时间非常长的时候，此时任务队列不停增大容易导致OOM异常，<code>newSingleThreadPool</code>同理，使用的也都是<strong>无界队列</strong></p><p><img src="/2021/12/21/java-thread-pool/image-20211222002400912.png" alt="image-20211222002400912"></p><p><code>newCachedThreadPool</code>可缓存线程池，使用<strong>直接交换</strong>队列。特点是具有自动回收多余线程的功能。弊端在于最大线程数量设置为了Integer.MAX_VALUE，这可能导致创建非常多的线程数量，同样可能导致OOM异常。</p><p><img src="/2021/12/21/java-thread-pool/image-20211222002431567.png" alt="image-20211222002431567"></p><p><code>newScheduledThreadPool</code>支持定时及周期任务执行的线程池。可以进行定时运行线程，或者以一定频率执行线程任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 定时5s之后执行</span></span><br><span class="line">executorService.schedule(<span class="keyword">new</span> FixedThreadDemo.Task(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 定时1s后执行，每隔2s执行一次</span></span><br><span class="line">executorService.scheduleAtFixedRate(<span class="keyword">new</span> FixedThreadDemo.Task(), <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>正确的创建线程的方法：</p><ul><li>根据不同的业务场景，设置线程池参数</li><li>比如：内存有多大，给线程取什么名字等等</li></ul><p><img src="/2021/12/21/java-thread-pool/image-20211222002620100.png" alt="image-20211222002620100"></p><h3 id="线程池的数量设定为多少合适"><a href="#线程池的数量设定为多少合适" class="headerlink" title="线程池的数量设定为多少合适"></a>线程池的数量设定为多少合适</h3><ul><li><p>CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右</p></li><li><p>耗时IO型（读写数据库、文件、网络读写等等）：最佳线程数一般大于CPU线程核心数很多倍</p><p>参考Brain Goetz推荐计算方法：<br>线程数=CPU核心数*（1+平均等待时间/平均工作时间）</p><p>2实际应该根据不同的程序进行压测</p></li></ul><h3 id="阻塞队列分析"><a href="#阻塞队列分析" class="headerlink" title="阻塞队列分析"></a>阻塞队列分析</h3><p><img src="/2021/12/21/java-thread-pool/image-20211222003214514.png" alt="image-20211222003214514"></p><ol><li>固定大小线程池，因为线程数固定，新来任务数未知，必须使用无限大的队列去存储</li><li>可缓存线程池目的为了执行效率最高，直接去新增线程</li><li>延时队列就是方便让任务延时进行</li></ol><p><code>workStealingPool</code>适用于容易产生子任务（比如递归）的线程；窃取，让线程之间“互相帮助”并发执行，线程之间不能加锁。</p><h3 id="关闭线程池的正确方法"><a href="#关闭线程池的正确方法" class="headerlink" title="关闭线程池的正确方法"></a>关闭线程池的正确方法</h3><p><code>shutdown</code> 存量任务执行完毕，新任务不增加</p><p><code>isShutdown</code>判断线程是否关闭</p><p><code>isTerminated</code>判断线程任务是否执行完毕</p><p><code>awaitTerminated</code>判断是否在规定时间内执行完毕</p><p><code>shutdownNow</code>正在执行的线程会立刻被终止，队列中的不执行，返回队列中的任务列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// ExecutorService executorService = Executors.newCachedThreadPool();</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> FixedThreadDemo.Task());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// System.out.println(&quot;thread service is shutdown or not ?&quot; + executorService.isShutdown());</span></span><br><span class="line">        <span class="comment">// executorService.shutdown();</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;thread service is shutdown or not ?&quot; + executorService.isShutdown());</span></span><br><span class="line">        <span class="comment">// Thread.sleep(2000);</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;thread service is terminated or not ?&quot; + executorService.isTerminated());</span></span><br><span class="line">        <span class="comment">// System.out.println( &quot;thread service is terminated or not ?&quot; + executorService.awaitTermination(2, TimeUnit.SECONDS));</span></span><br><span class="line">        <span class="comment">// 强制关闭在执行线程，队列中任务不执行，保存在list中</span></span><br><span class="line">        List&lt;Runnable&gt; list = executorService.shutdownNow();</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个线程用于演示固定大小的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; is interrupted.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程池暂停和恢复"><a href="#线程池暂停和恢复" class="headerlink" title="线程池暂停和恢复"></a>线程池暂停和恢复</h3><p>线程拒绝时机：</p><ul><li>当Executor关闭时，提交新任务会被拒绝</li><li>当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时</li></ul><p><img src="/2021/12/21/java-thread-pool/Untitled.png" alt="Untitled"></p><p>四种拒绝策略：</p><ol><li>AbortPolicy</li><li>DiscardPolicy</li><li>DiscardOldestPolicy</li><li>CallerRunsPolicy</li></ol><p>通过钩子函数给线程池添加功能，比如添加日志等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PausableThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 比synchronized更安全，因为需要考虑异常情况，一般不会导致死锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PausableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">true</span>;</span><br><span class="line">            unpaused.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isPaused) &#123;</span><br><span class="line">                unpaused.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">false</span>;</span><br><span class="line">            unpaused.notifyAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                Thread thread = Thread.currentThread();</span><br><span class="line">                System.out.println(thread.getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PausableThreadPool pausableThreadPool = <span class="keyword">new</span> PausableThreadPool(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br><span class="line">        <span class="comment">// ExecutorService pausableThreadPool = Executors.newFixedThreadPool(10);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            pausableThreadPool.execute(<span class="keyword">new</span> Task());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            pausableThreadPool.pause();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread is paused.....&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            pausableThreadPool.resume();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread is now released.....&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><p><em>继承改写ThreadPoolExecutor过程中运行时候一直显示一个线程在执行</em></p><p>发现是重写<code>beforeExecutor</code>方法时候没有解锁<code>lock.unlock()</code>导致</p><p><em>运行报错java.lang.IllegalMonitorStateException<br>        at java.base/java.lang.Object.notifyAll(Native Method)</em></p><p>发现是添加线程并没有被暂停<code>await</code>，导致不能被恢复<code>notifyAll</code></p><p>其他可能原因：</p><p>1&gt;当前线程不含有当前对象的锁资源的时候，调用obj.wait()方法;<br> 2&gt;当前线程不含有当前对象的锁资源的时候，调用obj.notify()方法。<br> 3&gt;当前线程不含有当前对象的锁资源的时候，调用obj.notifyAll()方法。</p><h3 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h3><p>线程池的组成部分：</p><ul><li>线程池管理器</li><li>工作线程</li><li>任务队列</li><li>任务接口</li></ul><img src="/2021/12/21/java-thread-pool/image-20211226130932071.png" alt="image-20211226130932071" style="zoom:50%;"><p><code>Executor</code>作为接口只有一个<code>void execute(Runnable commad)</code>方法</p><p><code>ExecutorService</code>继承了上一个方法，有了线程开启 停止等方法，详情可见api文档</p><img src="/2021/12/21/java-thread-pool/image-20211226131420571.png" alt="image-20211226131420571" style="zoom:20%;"><p><code>Executors</code> 则是一个工具类，可以方便的创建线程池等（详见api文档）</p><p>另外两个则是<code>ExecutorService</code>的继承和实现类， 方法内返回的仍然是<code>ExecutorService</code></p><h4 id="线程池实现任务复用的原理"><a href="#线程池实现任务复用的原理" class="headerlink" title="线程池实现任务复用的原理"></a>线程池实现任务复用的原理</h4><p>让我们看看线程池的执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment">     * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment">     * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment">     * the task is handled by the current &#123;<span class="doctag">@link</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment">     *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">// 小于核心数 创建</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 如果线程池在运行状态就放入工作队列中</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">          <span class="comment">// 再次检查如果线程池不在运行了则移除任务</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">          <span class="comment">// 防止任务提交到队列却没有被执行 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 其他情况如线程池停止，线程数大于核心数等</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>线程池的状态</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits 截取自ThreadPoolExecutor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p><strong>线程池使用注意点</strong>：</p><ul><li>避免任务堆积。比如在使用newFixedThreadPool时候</li><li>避免线程数量过度增加。比如在使用newCachedThreadPool时候</li><li>排查线程泄漏</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;线程池&lt;/strong&gt;就是为了处理避免反复创建并销毁县城所带来的开销问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;corePoolsize&lt;/strong&gt; 核心线程数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;maxPoolSize&lt;/strong&gt;在核心线程数之上，最大的线</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java判定2的方幂和2方幂取法</title>
    <link href="http://123.57.158.5/2021/12/13/java-power2/"/>
    <id>http://123.57.158.5/2021/12/13/java-power2/</id>
    <published>2021-12-13T14:02:18.000Z</published>
    <updated>2021-12-13T15:56:19.104Z</updated>
    
    <content type="html"><![CDATA[<p>判断是不是2的方幂可以通过按位与是否等于0来判定，很容易可以推出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个数获取包含它在内的最近额2的方幂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// numberOfLeadingZeros就是1前面0的个数，int总位数这里是32</span></span><br><span class="line">  <span class="comment">// 负数的非符号位在计算机中就是它对应正数的补码（反码加一）</span></span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;是忽略符号位右移（左边直接补0）</span></span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>例如 输入值为 9 我们来找方幂，为了方便观看假定int为8位。</p><p>8二进制为00001000 numberOfLeadingZeros方法返回4，-1非符号位补码表示为11111111右移4位，填充0，00001111</p><p>所以n = 15 最终返回16，即要找的2方幂</p><p>对于numberOfLeadingZeros方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个处理逻辑很符合二分搜索树。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// HD, Figure 5-6</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">        <span class="comment">// 为什么是1呢？因为如果i不是0，那么就表明在二进制表示中其至少有一位为1。</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果 i 无符号右移 16位成立，那么就表示i的前16为0，这是就可以对n进行+16(32-16)的操作，然后</span></span><br><span class="line">        <span class="comment">// 再将i左移16位，这个主要是将低位的数值移到高位去进行处理 </span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">16</span> == <span class="number">0</span>) &#123; n += <span class="number">16</span>; i &lt;&lt;= <span class="number">16</span>; &#125;</span><br><span class="line">        <span class="comment">// 如果 i 无符号右移 24位成立，那么就表示前24位为0，这时就可以对n进行+8操作(加8操作的来源是：</span></span><br><span class="line">        <span class="comment">// 32 - 24 得来的)，接着将i左移8位，这样就把24位的0覆盖掉，将低位数字移到高位来进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">24</span> == <span class="number">0</span>) &#123; n +=  <span class="number">8</span>; i &lt;&lt;=  <span class="number">8</span>; &#125;</span><br><span class="line">        <span class="comment">// 一样的逻辑来进行处理（加4的来源是：32-28）</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">28</span> == <span class="number">0</span>) &#123; n +=  <span class="number">4</span>; i &lt;&lt;=  <span class="number">4</span>; &#125;</span><br><span class="line">        <span class="comment">// 一样的逻辑（加2的来源是：32-30）</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">30</span> == <span class="number">0</span>) &#123; n +=  <span class="number">2</span>; i &lt;&lt;=  <span class="number">2</span>; &#125;</span><br><span class="line">       </span><br><span class="line">        n -= i &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;判断是不是2的方幂可以通过按位与是否等于0来判定，很容易可以推出。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java实现pythonzip方法</title>
    <link href="http://123.57.158.5/2021/12/12/java-zip-function/"/>
    <id>http://123.57.158.5/2021/12/12/java-zip-function/</id>
    <published>2021-12-12T15:36:27.000Z</published>
    <updated>2021-12-12T16:24:18.103Z</updated>
    
    <content type="html"><![CDATA[<p>工作中遇见一个问题需要将x轴和y轴的数据拼合起来，类似于python的zip函数，但是java中没有原生方法，随即根据zip的源码封装了一个类似的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  合并arrays，类似于python的zip方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrys &#123;1.1, 3.3, 2.6&#125;、&#123;1.3, 3.3, 7.7, 4.3&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> [[1.1,1.3],[3.3,3.3],[2.6,7.7]]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Collection&lt;Object&gt;&gt; zip(Double[]... arrys) &#123;</span><br><span class="line">        Collection&lt;Collection&lt;Object&gt;&gt; zips = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 将每个数组保存为迭代器list</span></span><br><span class="line">        List&lt;Iterator&lt;Double&gt;&gt; iterators = Arrays.stream(arrys).map(a -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.stream(a).iterator();</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        loop:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!iterators.isEmpty()) &#123;</span><br><span class="line">              <span class="comment">// 遍历每个迭代器依次添加集合</span></span><br><span class="line">                Collection&lt;Object&gt; zip = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (Iterator it : iterators</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (it.hasNext()) &#123;</span><br><span class="line">                        Double ele = (Double) it.next();</span><br><span class="line">                        zip.add(ele);</span><br><span class="line">                        <span class="keyword">continue</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span> loop;</span><br><span class="line">                &#125;</span><br><span class="line">                zips.add(zip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zips;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工作中遇见一个问题需要将x轴和y轴的数据拼合起来，类似于python的zip函数，但是java中没有原生方法，随即根据zip的源码封装了一个类似的&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC的一些配置</title>
    <link href="http://123.57.158.5/2021/12/06/springmvc/"/>
    <id>http://123.57.158.5/2021/12/06/springmvc/</id>
    <published>2021-12-06T14:59:39.000Z</published>
    <updated>2022-02-20T14:48:33.982Z</updated>
    
    <content type="html"><![CDATA[<p>新建maven项目-》project structure中添加web的module-》添加xml路径 和webapp路径（同时create artifact）-》edit configuration添加tomcat路径-》deployment中添加artifact-》webapp下添加的html可以正常访问。</p><p>配置好web应用和资源目录</p><p><img src="/2021/12/06/springmvc/image-20220120005840229.png" alt="image-20220120005840229"></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ol><li><p>配置依赖</p><p>pom.xml 包括spring-webmvc/freemarker/spring-context-support/jackson-core/jackson-annotations/jackson-databind/</p><p>Project structure中artifact将包推进WEB-INF的lib中</p></li><li><p>配置DispatcherServlet 及请求中文乱码问题</p><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    解决请求中的中文乱码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>开启springmvc注解模式 配置freemarker模版引擎</p><p>需要注意的是context:component-scan中use-default-filter设置为true代表将对包中的所有Component注解（包括controller srevice 等等注解进行扫描），如果是false会导致各种注解失效（血的教训）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:task</span>=<span class="string">&quot;http://www.springframework.org/schema/task&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/task</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/task/spring-task.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启springmvc注解模式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example.booker&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json;charset=utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置freemarker模版引擎--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;freemarkerConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateLoaderPath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/ftl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;freemarkerSettings&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;defaultEncoding&quot;</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;contentType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.ftl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="SSM-MyBatis-整合配置"><a href="#SSM-MyBatis-整合配置" class="headerlink" title="SSM-MyBatis 整合配置"></a>SSM-MyBatis 整合配置</h3><p>在spring启动时创建sqlsessionfactory对象 方便进行管理</p><img src="/2021/12/06/springmvc/image-20211206235834963.png" alt="image-20211206235834963" style="zoom:50%;"><p>添加依赖 spring-jdbc、mybatis、mybatis- Spring、mysql-connector-java、druid</p><p>mybatis与spring的整合配置之配置数据源。涉及到的classpath需要有对应文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    mybatis与spring的整合配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/book_reader?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>allowPublicKeyRetrieval=true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        一般可设置为用户使用上限--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    会基于配置信息创建sqlsessionFactory，交给ioc容器管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mappers/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        指定mybatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    mapper扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.example.booker.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mybatis-config.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Logback、声明式事务、junit单元测试</strong></p><h4 id="junit单元测试"><a href="#junit单元测试" class="headerlink" title="junit单元测试"></a>junit单元测试</h4><p>spring-text、junit依赖 但<strong>单元测试需要servlet接口</strong>，引入javax.servlet-api依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        单元测试依赖--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis操作数据库一般结构： 添加mapper接口，resource的mappers中添加对应的xml文件 通过namespace指向对应接口。crud的id指向接口的方法名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.booker.mapper.TestMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">        insert into book_reader (content) values (&quot;test content&quot;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service/serviceImpl中写curd业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    TestMapper testMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        testMapper.insert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Junit4测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestService testService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testService.insert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="logback配置"><a href="#logback配置" class="headerlink" title="logback配置"></a>logback配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=<span class="string">&quot;console&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;HH:mm:ss&#125; %-5level [%thread] %logger&#123;<span class="number">30</span>&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-<span class="number">8</span>&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;root level=<span class="string">&quot;debug&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;console&quot;</span>/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>在spring中添加tx的schema：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        ...</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!--    声明式事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Mybatis-Plus整合"><a href="#Mybatis-Plus整合" class="headerlink" title="Mybatis-Plus整合"></a>Mybatis-Plus整合</h4><ul><li>pom引入mybatis-plus依赖</li><li>spring-xml更改配置SqlSessionFactory实现类</li><li>mybatis-config.xml增加<strong>Mp分页插件</strong>，适用3.2.0以上版本</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    会基于配置信息创建sqlsessionFactory，交给ioc容器管理--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--原生spring与mybatis整合--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    mybatisPlus整合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mappers/*.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--        指定mybatis配置文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--         分页插件配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;mybatisPlusInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    整合分页器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mybatisPlusInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptors&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;paginationInnerInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;paginationInnerInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 对于单一数据库类型来说,都建议配置该值,避免每次分页都去抓取数据库类型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dbType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;H2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;countSqlParser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置为 true 可以优化部分 left join 的sql --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;optimizeJoin&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="MyBatis-Plus操作"><a href="#MyBatis-Plus操作" class="headerlink" title="MyBatis-Plus操作"></a>MyBatis-Plus操作</h4><ul><li><p>创建实体类，@TableName/@TableId/@TableField实现映射，如果开启了驼峰映射的话，TableField可以省略</p></li><li><p>创建Mapper接口继承BaseMapper，创建MapperXML</p><p>首先新建数据库对应实体类，并映射；新建Mapper接口继承BaseMapper并将范型定为实体类，这个mapper中可以新建自定义方法，方法名对应xml文件中curd的id名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">TestTable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.booker.mapper.TestMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertTest&quot;</span>&gt;</span></span><br><span class="line">        SQL syntax</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>service中使用常规写法，<strong>注入Mapper对象，通过内置API实现CRUD</strong></p><p>也可以选择创建mapper后不写xml。通过继承mybatis的IService和ServiceImpl方法获得基本的数据库操作方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">Category</span>&gt; </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">CategoryMapper</span>,<span class="title">Category</span>&gt; <span class="keyword">implements</span> <span class="title">CategoryService</span></span></span><br></pre></td></tr></table></figure></li><li><p>对于复杂的查询可以使用第一种xml写法，也可以直接在mapper类中通过@Select(“SELECT XXXXX FROM XXXX JOIN XXXX”)注解实现</p></li></ul><h3 id="图书类别实现"><a href="#图书类别实现" class="headerlink" title="图书类别实现"></a>图书类别实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 括号内指的是在spring容器中这个类的bean id为xxx，符合面向接口编程规则</span></span><br><span class="line"><span class="meta">@Service(&quot;CategoryService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryServiceImpl</span> <span class="keyword">implements</span> <span class="title">CategoryService</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>@Autowired 对比@Resource：autowired只会根据type去进行注入，找不到报错，resource会根据type和name进行匹配，然后注入。推荐使用@Service(“指定名称”) 然后@Resource的方法注入</em></p><p>事务传播性：propagation参数，propagation配置的就是一个事务的传播性问题。所谓事务传播性，就是被调用者的事务与调用者的事务之间的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示对数据只读操作，默认不开启事务。如果需要写操作则需要手动在方法上开启事务机制</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED,read_only = true)</span></span><br><span class="line"><span class="keyword">public</span> CategoryServiceImpl implements CateogoryService&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller中绑定视图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showCategories</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 绑定视图文件的名字 一定要这样写 否则报错找不到资源</span></span><br><span class="line">  ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">  List&lt;Category&gt; allCategories = categoryService.getAllCategories();</span><br><span class="line">  <span class="comment">// 添加属性名</span></span><br><span class="line">  mv.addObject(<span class="string">&quot;categories&quot;</span>,allCategories);</span><br><span class="line">  <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>freemaker中的展示方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list categories as categories&gt;</span><br><span class="line">  &lt;a style=<span class="string">&quot;cursor: pointer&quot;</span> data-category=<span class="string">&quot;$&#123;categories.categoryId&#125;&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;text-black-50 font-weight-bold category&quot;</span>&gt;$&#123;categories.categoryName&#125;&lt;/a&gt;</span><br><span class="line">    &lt;#--存在下一处则展示--&gt;</span><br><span class="line">    &lt;#<span class="keyword">if</span> categories_has_next&gt;|&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br></pre></td></tr></table></figure><h3 id="关于首页出现异常内容的事件（编译过程中没有自动删除之前的文件）"><a href="#关于首页出现异常内容的事件（编译过程中没有自动删除之前的文件）" class="headerlink" title="关于首页出现异常内容的事件（编译过程中没有自动删除之前的文件）"></a>关于首页出现异常内容的事件（编译过程中没有自动删除之前的文件）</h3><p>我在启动项目后，首页出现了之前清理掉的html文件。在多次重启服务、clean、compile、仍然无效，command+shift+r 全局项目搜索页面内容也没有找到文件所在，继续检查了每一个api都无果。后来在build出来的out文件夹中发现了它的踪影，原来是之前误把文件放错了位置，项目运行进入之后，而每次启动项目的编译过程，并没有被去掉该文件。</p><p>手动清理好，build，ok。</p><p>War exploded Artifects</p><img src="/2021/12/06/springmvc/image-20220121010335967.png" alt="image-20220121010335967" style="zoom:50%;"><h3 id="分页查询实现"><a href="#分页查询实现" class="headerlink" title="分页查询实现"></a>分页查询实现</h3><p>首先要配置好mybatis plus插件（xml配置见上面，非常重要！！！），然后分页可以通过以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IPage&lt;Book&gt; <span class="title">selectBookPage</span><span class="params">(Integer page, Integer rows)</span></span>&#123;</span><br><span class="line">  Page&lt;Book&gt; bookPage = <span class="keyword">new</span> Page&lt;Book&gt;(page,rows);</span><br><span class="line">  <span class="comment">// 第二个参数为数据库查询参数</span></span><br><span class="line">  <span class="keyword">return</span> bookMapper.selectPage(bookPage,<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ajax-模版引擎动态加载图书信息"><a href="#ajax-模版引擎动态加载图书信息" class="headerlink" title="ajax+模版引擎动态加载图书信息"></a>ajax+模版引擎动态加载图书信息</h3><p>写好加载图书信息接口api后，前端页面使用ajax动态调用图书信息</p><p>其中使用的是腾讯art-template对图书信息html片段进行渲染，使用<code>&#123;&#123;param&#125;&#125;</code>对数据进行加载，通过script 的id和template方法绑定模板到html片段（见上）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tpl&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/book/</span></span></span><span class="template-variable">&#123;&#123;<span class="name">bookId</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: inherit&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">            ...</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-8  mb-2 pl-0&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                    ...</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;stars&quot;</span> <span class="attr">data-score</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">score</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">title</span>=<span class="string">&quot;gorgeous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">...</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于评分显示星星，使用raty组件进行渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 引入本地组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./resources/raty/lib/jquery.raty.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 指定图片位置</span></span></span><br><span class="line"><span class="javascript">  $.fn.raty.defaults.path =<span class="string">&quot;./resources/raty/lib/images&quot;</span></span></span><br><span class="line"><span class="javascript">  ...</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 绑定class 添加星星 只读</span></span></span><br><span class="line"><span class="javascript">      $(<span class="string">&quot;.stars&quot;</span>).raty(&#123;<span class="attr">readOnly</span>:<span class="literal">true</span>&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js绑定加载更多按钮单击事件，并且封装加载不定页数的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadMore</span>(<span class="params">isReset</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isReset == <span class="literal">true</span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#nextPage&quot;</span>).val(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> nextPage = $(<span class="string">&quot;#nextPage&quot;</span>).val();</span><br><span class="line">  <span class="comment">// ajax 请求分页信息</span></span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/books&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;<span class="attr">page</span>: nextPage, <span class="attr">size</span>: <span class="number">10</span>&#125;,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> list = json.records;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 加载模版</span></span><br><span class="line">        <span class="keyword">var</span> html = template(<span class="string">&quot;tpl&quot;</span>,list[i])</span><br><span class="line">        $(<span class="string">&quot;#bookList&quot;</span>).append(html);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 绑定class选择器 添加星星 只读</span></span><br><span class="line">      $(<span class="string">&quot;.stars&quot;</span>).raty(&#123;<span class="attr">readOnly</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否为最后一页</span></span><br><span class="line">      <span class="keyword">if</span>(json.current &lt; json.pages)&#123;</span><br><span class="line">        $(<span class="string">&quot;#nextPage&quot;</span>).val(<span class="built_in">parseInt</span>(json.current)+<span class="number">1</span>);</span><br><span class="line">        $(<span class="string">&quot;#btnMore&quot;</span>).show();</span><br><span class="line">        $(<span class="string">&quot;#divNoMore&quot;</span>).hide();</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">&quot;#btnMore&quot;</span>).hide();</span><br><span class="line">        $(<span class="string">&quot;#divNoMore&quot;</span>).show();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动请求第一页的数据</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  loadMore(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//    加载更多</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">&quot;#btnMore&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    loadMore();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新建maven项目-》project structure中添加web的module-》添加xml路径 和webapp路径（同时create artifact）-》edit configuration添加tomcat路径-》deployment中添加artifact-》web</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>EndNote使用指南</title>
    <link href="http://123.57.158.5/2021/10/23/EndNoteForFHY/"/>
    <id>http://123.57.158.5/2021/10/23/EndNoteForFHY/</id>
    <published>2021-10-23T03:36:08.000Z</published>
    <updated>2021-10-23T03:51:43.480Z</updated>
    
    <content type="html"><![CDATA[<p>EndNote是一个文献管理软件，使用它可以方便的对文献进行管理，同时通过它的嵌入工具，可以方便的边书写论文边插入参考文献。</p><p>软件版本：</p><p>endnote x9</p><p>office 2016</p><h2 id="1-新建EndNote库"><a href="#1-新建EndNote库" class="headerlink" title="1.  新建EndNote库"></a>1.  新建EndNote库</h2><p><strong>介绍建立文献库基本操作</strong></p><p>首先，打开endnote新建库，这就是你以后的文献库，用于存放并管理你阅读的文献。如果C盘空间不够大的话可以放在其他盘上，默认在C盘文档文件夹下。</p><img src="/2021/10/23/EndNoteForFHY/image-20211022235039187-4960420.png" alt="image-20211022235039187" style="zoom: 50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023000045172-4960420.png" alt="image-20211023000045172" style="zoom:50%;"><p>打开endnote库后，在我的分组中右击可以新建组，可以像这样：综述、研究方法、研究背景…等等新建组，对不同类型文献进行区分。还可以新建组集，例如毕业论文一个组集，小论文一个组集等等。当然可以后期调整，whatever。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023001655965-4960420.png" alt="image-20211023001655965" style="zoom: 50%;"><h3 id="导入样式"><a href="#导入样式" class="headerlink" title="导入样式"></a>导入样式</h3><p>样式指的是文献的引用格式，例如常见的有国标的作者年份格式，和数字编号格式。同时endnote还支持许多期刊的引用格式，可以在各种样式之间方便的进行切换。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023005911004-4960420.png" alt="image-20211023005911004" style="zoom:50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023005955736-4960420.png" alt="image-20211023005955736" style="zoom:50%;"><p>对于endnote样式，我们可以通过[endnote官网](<a href="https://endnote.com/downloads/styles/">Output Styles | EndNote</a>)进行查找和下载</p><p>下载完成后导入endnote中：</p><p>直接使用endnote打开下载好的ens格式文件，另存之后关闭，随后样式就导入成功了</p><img src="/2021/10/23/EndNoteForFHY/image-20211023011341993-4960420.png" alt="image-20211023011341993" style="zoom:50%;"><p>选择该样式，之后就可以愉快使用这个样式进行文件的自动引用了。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023011539175-4960420.png" alt="image-20211023011539175" style="zoom: 50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023011721575.png" alt="image-20211023011721575" style="zoom:50%;"><h2 id="2-文献管理"><a href="#2-文献管理" class="headerlink" title="2. 文献管理"></a>2. 文献管理</h2><p><strong>介绍文献的导入与管理</strong></p><p>在阅读文献之前，通常我们会在文献网站上进行关键词检索，找到所需文献后下载，同时对其引用格式进行保存，最后将引用格式与文献pdf进行关联。</p><ol><li><p><em>知网</em></p><p>首先找到目标文献进行下载，将pdf文件保存到本地，没有pdf的下载caj</p><img src="/2021/10/23/EndNoteForFHY/image-20211023014102030-4960420.png" alt="image-20211023014224938" style="zoom:50%;"><p>然后右上的引用图标下载该文献的endnote格式的引用，在弹出的窗口中选择更多格式的引用，找到endnote 导出txt文件</p><img src="/2021/10/23/EndNoteForFHY/image-20211023014942996-4960420.png" alt="image-20211023014942996" style="zoom:50%;"><p>在endnote中导入该txt文件</p><img src="/2021/10/23/EndNoteForFHY/image-20211023015340063-4960420.png" alt="image-20211023015340063" style="zoom:50%;"><p>然后你就在导入的文献中看到了导入的文献(๑¯㉨¯๑)   你可以对他进行分组等等</p><img src="/2021/10/23/EndNoteForFHY/image-20211023101434637-4960420.png" alt="image-20211023101434637" style="zoom:50%;"><p>但是需要注意的是，插入文献经常存在格式不对的情况，比如上图中的期刊名没有正确显示，双击这篇文献，进行修改，将期刊名进行补充，注意去掉%J等不需要的字符，随后保存。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023101709406-4960420.png" alt="image-20211023101709406" style="zoom:50%;"><p>如果你有这篇文章的pdf的话将其添加到附件，endnote就会将文献移动到你的库中。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023102157451-4960420.png" alt="image-20211023102157451" style="zoom:50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023102549686-4960420.png" alt="image-20211023102549686" style="zoom:50%;"></li><li><p><em>爱思唯尔（ScienceDirect）</em></p><p>如果你们学校购买了爱思唯尔的库的话，通过校网检索文献的方式找到需要的文献（各种文献网站下载引用的逻辑基本都是想通的），先进行下载。然后同样导入库中，需要注意的是endnote同时支持多种格式，enl ris也可以，在这里我们下载ris格式。可以直接打开ris文件，endnote就进行了导入 </p><img src="/2021/10/23/EndNoteForFHY/image-20211023103858485-4960420.png" alt="image-20211023103858485" style="zoom:50%;"><p>导入之后同样进行关联文献的操作，同上，略。</p></li><li><p><em>谷歌学术/百度学术</em></p><p>这两个网站最重要的作用不是进行文献下载的，而是有海量的文献引用资源。如果仅仅需要下载些文献的引用，可以用上（偶尔一些文献也可以通过这些网站直接下载）。</p><p>以谷歌学术（国内需要翻墙访问，当然也可以搜索谷歌学术镜像网站使用）为例：</p><img src="/2021/10/23/EndNoteForFHY/image-20211023104744862-4960420.png" alt="image-20211023104744862" style="zoom:50%;"><p>找到文献点击引用图标，下载enl格式文件打开，就将引用导入了endnote中。之后的操作同</p><p>百度学术同理</p></li><li><p><em>快捷绑定和导入文献的方法</em></p><p>还有一个快捷绑定文献及导入文献的方法，但是只对较新的英文文献的pdf起作用（中文文献支持不太好）。</p><p>下载一篇pdf文献 ，打开方式使用endnote打开，神奇的事情发生了，endnote会自动进行检索！！！并将该文件绑定到库中。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023105929726-4960420.png" alt="image-20211023105929726" style="zoom:50%;"></li></ol><img src="/2021/10/23/EndNoteForFHY/image-20211023110151334-4960420.png" alt="image-20211023110151334" style="zoom:50%;"><ol start="5"><li><p><em>手动新建文献（是在没找到引用的时候用）</em></p><img src="/2021/10/23/EndNoteForFHY/image-20211023110312620-4960420.png" alt="image-20211023110312620" style="zoom:50%;"><p>将文献类型、作者、年份、卷号等等重要的内容一一填入即可</p></li></ol><p>到这里我们就可以方便进行平时文献的管理和阅读了。</p><h2 id="3-文献的引用"><a href="#3-文献的引用" class="headerlink" title="3. 文献的引用"></a>3. 文献的引用</h2><p>到了要写论文的时候，自然是要引用各种文献。</p><p>如果正确安装了endnote后，Word会出现endnote插件，它与endnote软件关联着。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023111138549-4960420.png" alt="image-20211023111138549" style="zoom:50%;"><p>在我们一边写论文时候，一边就可以插入引用。首先将光标停留在文档中需要插入引用的位置，切换到endnote，选择被引用的文献，选择格式，点击引用。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023111515675-4960420.png" alt="image-20211023111515675" style="zoom:50%;"><p>然后文档栋光标位置就自动插入了文献的引用。他是动态进行变化的，如果在文档中进行了删除引用、更新引用的操作，相应的需要，及下文的详情都会变更。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023111747955-4960420.png" alt="image-20211023111747955" style="zoom:50%;"><p>也许你注意到了文档中演示的格式，其实并不那么完美，比如中文文献引用，也加入et al的英文引用规则，所以在文章定稿之后一个非常重要的操作就是，将文献转为纯文本格式，然后进行手动修改。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023112056977-4960420.png" alt="image-20211023112056977" style="zoom:50%;"><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>所以endnote最基本的操作到这里就结束了，它的功能非常强大，也希望你慢慢去摸索其他更好玩更好用的功能，写出好文章！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;EndNote是一个文献管理软件，使用它可以方便的对文献进行管理，同时通过它的嵌入工具，可以方便的边书写论文边插入参考文献。&lt;/p&gt;
&lt;p&gt;软件版本：&lt;/p&gt;
&lt;p&gt;endnote x9&lt;/p&gt;
&lt;p&gt;office 2016&lt;/p&gt;
&lt;h2 id=&quot;1-新建EndNote库</summary>
      
    
    
    
    <category term="生活" scheme="http://123.57.158.5/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="EndNote" scheme="http://123.57.158.5/tags/EndNote/"/>
    
  </entry>
  
  <entry>
    <title>由@Valid注解校验引发的问题之Integer与int的比较</title>
    <link href="http://123.57.158.5/2021/10/10/java-lang/"/>
    <id>http://123.57.158.5/2021/10/10/java-lang/</id>
    <published>2021-10-10T14:39:01.000Z</published>
    <updated>2021-10-10T14:58:20.522Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习spring boot过程中遇到的一个问题</p><p>我在一个请求体model中将需要校验的字段写成了这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateCategoryReq</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;商品分类id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>同时在controller中对该请求体进行了@Valid校验，最后发现，<strong>校验没有生效</strong>，且自动对id进行了填充（？？？）。最后发现@Valid校验本质是校验java.lang中的包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Valid &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而定义变量时候，int类型不允许为空，而integer是可以为null。所以请求体中会对id自动赋值为0。</p><p>所以需要将字段改为包装类定义，才能进行校验。</p><p>扩展 Integer与int的区别：</p><blockquote><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习spring boot过程中遇到的一个问题&lt;/p&gt;
&lt;p&gt;我在一个请求体model中将需要校验的字段写成了这样&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>java流处理</title>
    <link href="http://123.57.158.5/2021/10/06/java-stream/"/>
    <id>http://123.57.158.5/2021/10/06/java-stream/</id>
    <published>2021-10-06T02:27:30.000Z</published>
    <updated>2021-10-10T14:37:45.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li><strong>stream()</strong> − 为集合创建串行流。</li><li><strong>parallelStream()</strong> − 为集合创建并行流。拆分成小任务，使用线程来执行，当数量十分大时候，效率更高</li></ul><p>很容易理解对于需要串行依次执行的一般使用串行流，对于可以并发不需要按顺序执行的可以使用并行流。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;dsf&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;gjw&quot;</span>, <span class="string">&quot;persimmon&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉为空的字符串，保持原有顺序 使用串行流</span></span><br><span class="line">List&lt;String&gt; filteredString = strings.stream()</span><br><span class="line">  .filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 分别打印</span></span><br><span class="line">filteredString.forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计为空字符串的数量 可以使用并行流</span></span><br><span class="line">Long count = strings.parallelStream().filter(String::isEmpty).count();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>此外流还提供了很多limit map sort 方法等等，可以查看文档或者<a href="https://www.runoob.com/java/java8-streams.html">菜鸟教程</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除空字符串，用逗号将所有元素合并起来</span></span><br><span class="line">String combinedStrings = strings.stream().filter(string -&gt; !string.isEmpty()).</span><br><span class="line">  collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">System.out.println(combinedStrings);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素去重去空字符 前后加上减号输出</span></span><br><span class="line">List&lt;String&gt; handledStrings = strings.stream().filter(string -&gt; !string.isEmpty()).distinct()</span><br><span class="line">  .map(string -&gt; <span class="string">&quot;-&quot;</span>+string+<span class="string">&quot;-&quot;</span>).collect(Collectors.toList());</span><br><span class="line">handledStrings.forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取十个5以内的随机整数排序并平方处理后输出</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints(<span class="number">10</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  .map(x -&gt; x * x).forEach(System.out::println);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight pl</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring MongoTemplate踩坑</title>
    <link href="http://123.57.158.5/2021/09/14/springProject/"/>
    <id>http://123.57.158.5/2021/09/14/springProject/</id>
    <published>2021-09-14T15:29:08.000Z</published>
    <updated>2021-10-06T02:30:57.567Z</updated>
    
    <content type="html"><![CDATA[<p>在使用spring的MongoTemplate进行mongodb操作时候踩了许多坑，记录一下<a href="https://www.springcloud.cc/spring-data-mongodb.html#mongo-template">MongoTemplate</a>的一些操作。</p><h3 id="Criteria类"><a href="#Criteria类" class="headerlink" title="Criteria类"></a>Criteria类</h3><p>用于创建mongodb数据查询条件，这些criteria查询条件之间可以进行相互拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = Criteria.where(<span class="string">&quot;city&quot;</span>).is(<span class="string">&quot;Yichun&quot;</span>)</span><br><span class="line">  .and(<span class="string">&quot;age&quot;</span>).gte(<span class="number">18</span>);</span><br><span class="line">criteria.and(<span class="string">&quot;sex&quot;</span>).is(<span class="string">&quot;male&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是同一个查询字段不可以重复进行拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">if</span>(query.startTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">  criteria.and(<span class="string">&quot;create_time&quot;</span>).gt(startTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(query.endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">  criteria.and(<span class="string">&quot;create_time&quot;</span>).lt(endTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参考写法</span></span><br><span class="line"><span class="keyword">if</span>(query.startTime != <span class="keyword">null</span> &amp;&amp; query.endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">  criteria.and(<span class="string">&quot;create_time&quot;</span>).gt(startTime).lt(endTime);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(query.startTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">    criteria.and(<span class="string">&quot;create_time&quot;</span>).gt(startTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(query.endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">    criteria.and(<span class="string">&quot;create_time&quot;</span>).lt(endTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Criteria类中的 andOperator、orOperator可以对criteria查询条件进行组合使用，但是不可以重复拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = Criteria.where(<span class="string">&quot;city&quot;</span>).is(<span class="string">&quot;Shenzhen&quot;</span>);</span><br><span class="line">Criteria criteria1 = Criteria.where(<span class="string">&quot;age&quot;</span>).gt(<span class="number">18</span>);</span><br><span class="line">Criteria.andOperator(criteria,criteria1);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">criteria.andOperator(criteria1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果此时继续对criteria再次使用andOperator组合，查询条件将不可用</span></span><br><span class="line"><span class="comment">// 报错Due to limitations of the com.mongodb.BasicDocument, you can&#x27;t add a second ...</span></span><br><span class="line">criteria.andOperator(Criteria.where(<span class="string">&quot;gender&quot;</span>).is(<span class="string">&quot;male&quot;</span>));</span><br></pre></td></tr></table></figure><p>使用查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line">  </span><br><span class="line">Query query = <span class="keyword">new</span> Query(criteria);</span><br><span class="line">mongoTemplate.count(query,xxxDocument.class);</span><br><span class="line">mongoTemplate.findOne(query.xxxDocuent.class);</span><br></pre></td></tr></table></figure><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><blockquote><p>MongoDB 中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果。</p></blockquote><p>通过<a href="https://www.runoob.com/mongodb/mongodb-aggregate.html">聚合查询</a>可以对数据进行分组，统计等等。</p><p>聚合查询的条件由一个个管道（管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数）组成。</p><h4 id="example1"><a href="#example1" class="headerlink" title="example1"></a>example1</h4><p><code>unwind</code> 是对符合匹配出的内容按照data数组中每个字段进行分解，分解成一个个文档</p><p><code>getMappedResults</code>以map形式返回查询结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;xxDTO&gt; <span class="title">mongodbExample</span><span class="params">(xxQuery query)</span> </span>&#123;</span><br><span class="line">      Criteria criteria = Criteria.where(<span class="string">&quot;xx_column&quot;</span>).in(query.getxxList())</span><br><span class="line">              .and(<span class="string">&quot;xx&quot;</span>).in(query.getxxList())</span><br><span class="line">              .and(<span class="string">&quot;xxx&quot;</span>).is(query.getxx())</span><br><span class="line">              .and(<span class="string">&quot;xxxx&quot;</span>).is(query.getxx());</span><br><span class="line"></span><br><span class="line">      Aggregation aggregation = newAggregation(</span><br><span class="line">              match(criteria),</span><br><span class="line">              unwind(<span class="string">&quot;data&quot;</span>),</span><br><span class="line">              match(Criteria.where(<span class="string">&quot;data.y_name&quot;</span>).is(query.getxxName())),</span><br><span class="line">              project()</span><br><span class="line">                      .and(<span class="string">&quot;limit_id&quot;</span>).as(<span class="string">&quot;limit_id&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.x_name&quot;</span>).as(<span class="string">&quot;x_name&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.x_unit&quot;</span>).as(<span class="string">&quot;x_unit&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.x_value&quot;</span>).as(<span class="string">&quot;x_value&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_name&quot;</span>).as(<span class="string">&quot;y_name&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_unit&quot;</span>).as(<span class="string">&quot;y_unit&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_low&quot;</span>).as(<span class="string">&quot;y_low&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_high&quot;</span>).as(<span class="string">&quot;y_high&quot;</span>)</span><br><span class="line">                      .andExclude(<span class="string">&quot;_id&quot;</span>)</span><br><span class="line">      );</span><br><span class="line">      AggregationResults&lt;xxDTO&gt; aggregate = mongoTemplate.aggregate(aggregation, <span class="string">&quot;INPUT_COLLECTION_NAME&quot;</span>, xxxDTO.class);</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">return</span> aggregate.getMappedResults();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h4><blockquote><p>此示例基于MongoDB聚合框架文档中的“ <a href="http://docs.mongodb.org/manual/tutorial/aggregation-examples/#largest-and-smallest-cities-by-state">最大和最小城市”</a>示例。我们添加了额外的排序，以使用不同的MongoDB版本生成稳定的结果。在这里，我们希望通过使用聚合框架按每个州的人口返回最小和最大的城市。此示例演示分组，排序和投影（选择）。</p></blockquote><p><code>nested</code>用于在聚合查询过程中创建一个次级文档，在这里面分别是“biggestCity”和“samllestCity”，同时将”biggestCity”，”biggestPop”字段名分别绑定为”name”, “population”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipInfo</span> </span>&#123;</span><br><span class="line">   String id;</span><br><span class="line">   String city;</span><br><span class="line">   String state;</span><br><span class="line">   <span class="meta">@Field(&quot;pop&quot;)</span> <span class="keyword">int</span> population;</span><br><span class="line">   <span class="meta">@Field(&quot;loc&quot;)</span> <span class="keyword">double</span>[] location;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   <span class="keyword">int</span> population;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipInfoStats</span> </span>&#123;</span><br><span class="line">   String id;</span><br><span class="line">   String state;</span><br><span class="line">   City biggestCity;</span><br><span class="line">   City smallestCity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.data.mongodb.core.aggregation.Aggregation.*;</span><br><span class="line"></span><br><span class="line">TypedAggregation&lt;ZipInfo&gt; aggregation = newAggregation(ZipInfo.class,</span><br><span class="line">    group(<span class="string">&quot;state&quot;</span>, <span class="string">&quot;city&quot;</span>)</span><br><span class="line">       .sum(<span class="string">&quot;population&quot;</span>).as(<span class="string">&quot;pop&quot;</span>),</span><br><span class="line">    sort(ASC, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;state&quot;</span>, <span class="string">&quot;city&quot;</span>),</span><br><span class="line">    group(<span class="string">&quot;state&quot;</span>)</span><br><span class="line">       .last(<span class="string">&quot;city&quot;</span>).as(<span class="string">&quot;biggestCity&quot;</span>)</span><br><span class="line">       .last(<span class="string">&quot;pop&quot;</span>).as(<span class="string">&quot;biggestPop&quot;</span>)</span><br><span class="line">       .first(<span class="string">&quot;city&quot;</span>).as(<span class="string">&quot;smallestCity&quot;</span>)</span><br><span class="line">       .first(<span class="string">&quot;pop&quot;</span>).as(<span class="string">&quot;smallestPop&quot;</span>),</span><br><span class="line">    project()</span><br><span class="line">       .and(<span class="string">&quot;state&quot;</span>).previousOperation()</span><br><span class="line">       .and(<span class="string">&quot;biggestCity&quot;</span>)</span><br><span class="line">          .nested(bind(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;biggestCity&quot;</span>).and(<span class="string">&quot;population&quot;</span>, <span class="string">&quot;biggestPop&quot;</span>))</span><br><span class="line">       .and(<span class="string">&quot;smallestCity&quot;</span>)</span><br><span class="line">          .nested(bind(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;smallestCity&quot;</span>).and(<span class="string">&quot;population&quot;</span>, <span class="string">&quot;smallestPop&quot;</span>)),</span><br><span class="line">    sort(ASC, <span class="string">&quot;state&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">AggregationResults&lt;ZipInfoStats&gt; result = mongoTemplate.aggregate(aggregation, ZipInfoStats.class);</span><br><span class="line">ZipInfoStats firstZipInfoStats = result.getMappedResults().get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>请注意，<code>ZipInfo</code>类映射给定输入集合的结构。<code>ZipInfoStats</code>类以所需的输出格式定义结构。</p><p>上述列表使用以下算法：</p><ol><li>使用<code>group</code>操作从输入集合中定义组。分组标准是<code>state</code>和<code>city</code>字段的组合，它们形成组的ID结构。我们使用<code>sum</code>运算符从分组元素聚合<code>population</code>属性的值，并将结果保存在<code>pop</code>字段中。</li><li>使用<code>sort</code>操作按<code>pop</code>，<code>state</code>和<code>city</code>字段按升序对中间结果进行排序，以便最小的城市位于顶部，最大的城市位于结果的底部。请注意，<code>state</code>和<code>city</code>上的排序是针对组ID字段（MongoDB处理的Spring Data）隐式执行的。</li><li>再次使用<code>group</code>操作将中间结果分组为<code>state</code>。请注意，<code>state</code>再次隐式引用组ID字段。我们在<code>project</code>操作中分别调用<code>last(…)</code>和<code>first(…)</code>运算符来选择最大和最小城市的名称和人口数。</li><li>从上一个<code>group</code>操作中选择<code>state</code>字段。请注意，<code>state</code>再次隐式引用组ID字段。由于我们不希望显示隐式生成的ID，因此我们使用<code>and(previousOperation()).exclude()</code>从上一个操作中排除ID。因为我们想要在输出类中填充嵌套的<code>City</code>结构，所以我们必须使用嵌套方法发出适当的子文档。</li><li>在<code>sort</code>操作中按升序对<code>StateStats</code>的结果列表按其状态名称进行排序。</li></ol><p>请注意，我们将作为第一个参数传递的<code>ZipInfo</code>类的输入集合的名称派生到<code>newAggregation</code>方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用spring的MongoTemplate进行mongodb操作时候踩了许多坑，记录一下&lt;a href=&quot;https://www.springcloud.cc/spring-data-mongodb.html#mongo-template&quot;&gt;MongoTemplate&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="实战" scheme="http://123.57.158.5/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="Mongo" scheme="http://123.57.158.5/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>AOP环绕通知</title>
    <link href="http://123.57.158.5/2021/08/30/aop-round-advice/"/>
    <id>http://123.57.158.5/2021/08/30/aop-round-advice/</id>
    <published>2021-08-29T16:26:20.000Z</published>
    <updated>2021-09-01T12:51:33.986Z</updated>
    
    <content type="html"><![CDATA[<p>简单演示aop中的环绕通知的作用实例，用于打印方法执行的时间进行排查，优化项目效率。</p><p>项目结构：</p><p><img src="/2021/08/30/aop-round-advice/image-20210831004102587.png" alt="image-20210831004102587"></p><p>UserDao、UserService等略</p><p>MethodChecker：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodChecker</span> </span>&#123;</span><br><span class="line"><span class="comment">//    ProceedingJoinPoint在原有JoinPoint基础上可以控制目标方法是否执行</span></span><br><span class="line"><span class="comment">//    环绕通知 需要将目标方法返回值返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">check</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//        执行方法，执行proceed方法之前的就相当于前置通知，后面的相当于后置通知，其本身还可以处理通知返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">            Object ret = proceedingJoinPoint.proceed();</span><br><span class="line">            <span class="keyword">long</span> endTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">            <span class="keyword">long</span> durationTime = endTime-startTime;</span><br><span class="line">            SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH-mm-ss SSS&quot;</span>);</span><br><span class="line">            String now = simpleDateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">            String className = proceedingJoinPoint.getTarget().getClass().getName();</span><br><span class="line">            String methodName = proceedingJoinPoint.getSignature().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;---&gt;&quot;</span>+now+<span class="string">&quot;  &quot;</span>+className+<span class="string">&quot;.&quot;</span>+methodName+<span class="string">&quot;(&quot;</span>+durationTime+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.orange.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.orange.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodChecker&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.orange.aspect.MethodChecker&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.orange..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;methodChecker&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;check&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringApplication:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.orange.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">        UserService userService = applicationContext.getBean(<span class="string">&quot;userService&quot;</span>,UserService.class);</span><br><span class="line">        userService.createUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解AOP"><a href="#注解AOP" class="headerlink" title="注解AOP"></a>注解AOP</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    使用ioc注解式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.orange&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用aop注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>给UserDao、UserService添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>给切面方法添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodChecker</span> </span>&#123;</span><br><span class="line"><span class="comment">//    ProceedingJoinPoint在原有JoinPoint基础上可以控制目标方法是否执行</span></span><br><span class="line"><span class="comment">//    环绕通知 需要将目标方法返回值返回</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.orange..*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">check</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单演示aop中的环绕通知的作用实例，用于打印方法执行的时间进行排查，优化项目效率。&lt;/p&gt;
&lt;p&gt;项目结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/08/30/aop-round-advice/image-20210831004102587.png&quot; alt=&quot;i</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="AOP" scheme="http://123.57.158.5/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>使用反射简单模拟spring的ioc容器</title>
    <link href="http://123.57.158.5/2021/08/27/spring-ioc/"/>
    <id>http://123.57.158.5/2021/08/27/spring-ioc/</id>
    <published>2021-08-26T16:12:59.000Z</published>
    <updated>2021-08-26T16:23:03.161Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用反射简单模拟Spring的ioc容器</span><br><span class="line">使用依赖dom4j</span><br></pre></td></tr></table></figure><p>项目结构：</p><p><img src="/2021/08/27/spring-ioc/image-20210827001816735.png" alt="image-20210827001816735"></p><h2 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruits</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象，添加getset方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String origin;</span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString方法方便进行输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fruits&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, origin=&#x27;&quot;</span> + origin + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrigin</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.origin = origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Float price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!--关联entity中对象进行配置，property指的是通过对象getset方法进行初始化--&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;durian&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.orange.entity.Fruits&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;durian&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;origin&quot;</span> value=<span class="string">&quot;Thailand&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;price&quot;</span> value=<span class="string">&quot;99.0&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.context;</span><br><span class="line"><span class="comment">// 创建接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Node;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="comment">//    使用hashmap保存ioc容器的数据，数据以beanid 和 Fruits对象形式保存</span></span><br><span class="line">    Map&lt;String, Object&gt; iocContainer = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            使用dom4j读取配置文件</span></span><br><span class="line">            String filePath = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;/applicationContext.xml&quot;</span>).getPath();</span><br><span class="line">            filePath = <span class="keyword">new</span> URLDecoder().decode(filePath, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            Document document = <span class="keyword">new</span> SAXReader().read(<span class="keyword">new</span> File(filePath));</span><br><span class="line"><span class="comment">//            获取配置文件下的bean</span></span><br><span class="line">            List&lt;Node&gt; nodes = document.getRootElement().selectNodes(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line"><span class="comment">//                获取到beanid和class，使用反射创建对象</span></span><br><span class="line">                Element el = (Element) node;</span><br><span class="line">                String beanId = el.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String className = el.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                Class c = Class.forName(className);</span><br><span class="line">                Object obj = c.getConstructor().newInstance();</span><br><span class="line"><span class="comment">//                获取每一个bean下的property 获取name和value 反射给对象注入属性</span></span><br><span class="line">                List&lt;Node&gt; props = el.selectNodes(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Node prop : props) &#123;</span><br><span class="line">                    Element pro = (Element) prop;</span><br><span class="line">                    String propertyName = pro.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                    Object propertyValue = pro.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    String setMethodName = <span class="string">&quot;set&quot;</span> + propertyName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">                    Type fieldType = c.getDeclaredField(propertyName).getGenericType();</span><br><span class="line">                    Method setMethod = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (fieldType.toString().equals(<span class="string">&quot;class java.lang.String&quot;</span>)) &#123;</span><br><span class="line">                        setMethod = c.getMethod(setMethodName, String.class);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fieldType.toString().equals(<span class="string">&quot;class java.lang.Float&quot;</span>)) &#123;</span><br><span class="line">                        setMethod = c.getMethod(setMethodName, Float.class);</span><br><span class="line">                        propertyValue = Float.parseFloat((String) propertyValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setMethod.invoke(obj, propertyValue);</span><br><span class="line">                &#125;</span><br><span class="line">                iocContainer.put(beanId, obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">        Object obj = iocContainer.get(beanId);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="IocApplication-java"><a href="#IocApplication-java" class="headerlink" title="IocApplication.java"></a>IocApplication.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.orange.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.orange.context.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.orange.entity.Fruits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IocApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">        Fruits durian = (Fruits) context.getBean(<span class="string">&quot;durian&quot;</span>);</span><br><span class="line">        System.out.println(durian);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="IOC" scheme="http://123.57.158.5/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>ssm部分笔记</title>
    <link href="http://123.57.158.5/2021/08/15/ssm/"/>
    <id>http://123.57.158.5/2021/08/15/ssm/</id>
    <published>2021-08-15T02:26:30.000Z</published>
    <updated>2021-08-26T16:15:09.078Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis 默认开启一级缓存，只在一个sqlsession中使用，不论进行多少次相同的sql查询，结果都在同一个内存地址中。</p><p>commit操作会强制清空一二级缓存</p><p>二次缓存在mapper的namespace中生效，二级缓存的设置：</p><p><img src="/2021/08/15/ssm/image-20210815103904479.png" alt="image-20210815103904479"></p><p>对于列表中存储多个查询对象的，会被当作一个对象存储进缓存，缓存命中率低，所以不推荐使用缓存。</p><p><img src="/2021/08/15/ssm/image-20210815104627699.png" alt="image-20210815104627699"></p><p>一对多（one to many）的one表的xml配置</p><p><img src="/2021/08/15/ssm/image-20210815202133723.png" alt="image-20210815202133723"></p><p>多对一查询（many to one） many表的xml配置</p><p><img src="/2021/08/15/ssm/image-20210815223023718.png" alt="image-20210815223023718"></p><p>xxxx 略，暂时不更新笔记内容了</p><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><p>尤其注意xml的配置问题，特别容易导致错误</p><p>例如xml中mysql数据库的引入，注意是在cj.jdbc包下面，引用错误会导致NoClassDefFoundError</p><h3 id="bean-scope中的单例与多例模式对比"><a href="#bean-scope中的单例与多例模式对比" class="headerlink" title="bean scope中的单例与多例模式对比"></a>bean scope中的单例与多例模式对比</h3><p><img src="/2021/08/15/ssm/Snipaste_2021-08-25_15-13-31.png" alt="Snipaste_2021-08-25_15-13-31"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mybatis 默认开启一级缓存，只在一个sqlsession中使用，不论进行多少次相同的sql查询，结果都在同一个内存地址中。&lt;/p&gt;
&lt;p&gt;commit操作会强制清空一二级缓存&lt;/p&gt;
&lt;p&gt;二次缓存在mapper的namespace中生效，二级缓存的设置：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="MyBatis" scheme="http://123.57.158.5/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>IDEA下新建Servlet项目与Tomcat10不兼容问题</title>
    <link href="http://123.57.158.5/2021/08/03/servlet-tomcat-problem/"/>
    <id>http://123.57.158.5/2021/08/03/servlet-tomcat-problem/</id>
    <published>2021-08-03T14:28:13.000Z</published>
    <updated>2021-08-03T14:54:58.004Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习java后端，在使用IDEA新建Servlet+Tomcat项目的时候，碰到了问题。tomcat是通过<code>brew install tomcat</code>安装的。启动项目后可以看到首页内容，但是首页出现的所有超链接页面全部报错404。</p><p>花了一个晚上没查明白，第二天切换为了tomcat@9的最新版，就解决了！太离谱了</p><p><code>brew install tomcat</code>安装的是最新版Tomcat10最新版，但是可能是与Servlet不兼容。后使用<code>brew install tomact@9</code>安装了9的最新版9.0.46，然后将其添加到idea的tomcat路径中</p><p><img src="/2021/08/03/servlet-tomcat-problem/image-20210803225349780.png" alt="image-20210803225349780"></p><p><img src="/2021/08/03/servlet-tomcat-problem/image-20210803225439855.png" alt="image-20210803225439855"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习java后端，在使用IDEA新建Servlet+Tomcat项目的时候，碰到了问题。tomcat是通过&lt;code&gt;brew install tomcat&lt;/code&gt;安装的。启动项目后可以看到首页内容，但是首页出现的所有超链接页面全部报错404。&lt;/p&gt;
&lt;p&gt;花</summary>
      
    
    
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Servlet" scheme="http://123.57.158.5/tags/Servlet/"/>
    
    <category term="Tomcat" scheme="http://123.57.158.5/tags/Tomcat/"/>
    
    <category term="IDEA" scheme="http://123.57.158.5/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Java部分学习笔记3（接口、继承、多态到异常处理）</title>
    <link href="http://123.57.158.5/2021/07/14/java3/"/>
    <id>http://123.57.158.5/2021/07/14/java3/</id>
    <published>2021-07-13T16:26:15.000Z</published>
    <updated>2021-07-18T05:13:13.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口、继承与多态"><a href="#接口、继承与多态" class="headerlink" title="接口、继承与多态"></a>接口、继承与多态</h2><p>继承中重写父类的方法时候，修饰权限只能从小的范围到大的范围，比如父方法的protected权限，子方法不可以为private，可以为public。</p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中所有的类都继承于Object</p><p>几个重要方法：</p><ul><li><p><code>getClass()</code>方法</p><p>返回对象执行时的Class实例，使用此实例可以调用<code>getClass().getName()</code>获得类的名称。</p></li><li><p><code>toString()</code>方法</p><p>将对象以字符串形式返回，可以通过重写为对象提供一个特定的输出模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">reWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;重写函数&quot;</span>+getClass().getName()+<span class="string">&quot;toStrring方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> reWrite());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>equals()</code>方法</p><p>当两个自定义类的对象进行比较时候，返回的是false。因为此处默认实现的是“==”方法比较引用地址。这点<strong>不同于</strong>字符串、整型等对象的比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">overW m = <span class="keyword">new</span> overW();</span><br><span class="line">overW n = <span class="keyword">new</span> overW();</span><br><span class="line">System.out.println(m.equals(n));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>转换注意理解向上转型（父类引用指向子类实例）和向下转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Birds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Seagull</span> <span class="keyword">extends</span> <span class="title">Birds</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        Birds smallSeagull = <span class="keyword">new</span> Seagull();</span><br><span class="line">        <span class="comment">// 向下转型（显式类型转换）</span></span><br><span class="line">        Seagull sg = (Seagull) smallSeagull;</span><br><span class="line">        sg.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意的是，向下转型时候如果父类对象不是子类对象的实例，就会发生ClassCastException异常。</p><p>向上转型不可以调用子类特有的方法没法调用的。</p><p><code>instanceof</code>java关键字，用于判断一个对象实例是否属于某个类。</p><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>在一个类中允许多个重名方法存在，只要参数不同即可，这就是方法的重载。参数类型不同，或参数个数不同，或参数顺序不同都可以构成参数重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...表示不定长参数 相当于a[]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>...a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m:a)&#123;</span><br><span class="line">            sum += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 调用的其实是第一个add方法</span></span><br><span class="line">        System.out.println(add(<span class="number">1</span>));</span><br><span class="line">      <span class="comment">// 重载 调用的是第二个add</span></span><br><span class="line">        System.out.println(add(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是继承父类的方法，方便子类进行调用，同时也方便后期维护。子类也可以对父类方法进行重写，使得程序具有良好的可扩展性。</p><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p>略。因为个人原因暂停更新笔记。。。</p><p>重更时间待定</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;接口、继承与多态&quot;&gt;&lt;a href=&quot;#接口、继承与多态&quot; class=&quot;headerlink&quot; title=&quot;接口、继承与多态&quot;&gt;&lt;/a&gt;接口、继承与多态&lt;/h2&gt;&lt;p&gt;继承中重写父类的方法时候，修饰权限只能从小的范围到大的范围，比如父方法的protected权</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java部分学习笔记（类和对象——数字处理类）</title>
    <link href="http://123.57.158.5/2021/07/04/java2/"/>
    <id>http://123.57.158.5/2021/07/04/java2/</id>
    <published>2021-07-04T04:47:42.000Z</published>
    <updated>2021-10-06T03:55:34.408Z</updated>
    
    <content type="html"><![CDATA[<p>主要做自我知识点的补充，不是全面系统的笔记</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">//定义一个String类型的成员变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="comment">//定义一个getName方法</span></span><br><span class="line">      <span class="keyword">int</span> id = <span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">      setName(<span class="string">&quot;Java&quot;</span>);<span class="comment">//调用类中其他方法</span></span><br><span class="line">      <span class="keyword">return</span> id + <span class="keyword">this</span>.name;<span class="comment">//设置方法的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;<span class="comment">//定义一个setName方法</span></span><br><span class="line">      <span class="keyword">this</span>.name = name;<span class="comment">//将参数数值赋予类中的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Book <span class="title">getBook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//返回Book类引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>主要控制着对类和类的成员变量及成员方法的访问。</p><ul><li><strong>private</strong>：这个类将隐藏其内的所有数据，以免用户直接访问它。</li><li><strong>public</strong>：这个类中的数据可以被子类或其他包中的类使用。</li><li><strong>protected</strong>：只有本包内该类的子类或者其他类可以访问此类中的成员变量和成员方法。</li></ul><p>如果不使用修饰，则预设为protected，即只有一个包中的类可以调用这个类的成员变量或成员方法。同时<strong>类的权限设定会约束类成员的权限和设定</strong>。</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>例子中<code>this.name = name</code>this代表的是本类中的一个对象，第一个name就是成员变量，第二个则是传入的数值参数。</p><p><code>public Book getBook()&#123;return this;&#125;</code>例子中定义了Book类的方法，返回值为Book类对象。</p><h3 id="Java类的构造方法"><a href="#Java类的构造方法" class="headerlink" title="Java类的构造方法"></a>Java类的构造方法</h3><ul><li>每次实例化一个对象，都会调用构造方法</li><li>构造方法没有返回值</li><li>构造方法的名称要与本类的名称相同</li><li>无参的构造方法可以用this调用有参的构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Orange</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="string">&quot;this 调用了有参数的构造方法&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;这是无参的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Orange</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是有参的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>可用于定义静态变量、常量和方法，目的是为了方便<strong>共享数据</strong>和<strong>共享方法</strong>。便于将不同类需要使用的成员分配到一个<strong>固定的内存位置</strong>中。</p><p>一般通过<code>类名.静态类成员</code>调用，而不建议通过<code>对象.静态类成员</code>调用，避免混淆静态成员和非静态成员。</p><p>静态成员同样收到权限修饰符（pbulic、protected、private）的约束。</p><p>静态方法中不可以使用this关键字</p><p>在静态方法中不可以<strong>直接</strong>调用非静态方法</p><p>不能将方法体内的局部变量声明为static</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static method1 initiated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(StaticTest.PI);<span class="comment">//调用静态常量</span></span><br><span class="line">        System.out.println(StaticTest.id);<span class="comment">//调用静态变量</span></span><br><span class="line">        StaticTest.method1();<span class="comment">//调用静态方法</span></span><br><span class="line">      method1();<span class="comment">//调用静态方法（因为该静态方法在该类内部）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips（类的初始化）：</p><p>执行类的时候如果希望先执行类的初始化操作，可以用static定义一个静态区域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的主方法"><a href="#类的主方法" class="headerlink" title="类的主方法"></a>类的主方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主方法是静态的，所以如要<strong>直接</strong>在主方法中调用其他方法，则该方法必须也是静态的。</li><li>主方法没有返回值</li><li>主方法的形参为数组。其中args[0]~args[n]分别带代表程序的第一个参数到第n个参数，可以使用args.length获取参数的个数。</li></ul><p>通过下面这个例子，我们可以来理解该类和对象的属性和行为，静态对象等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessProperty</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义静态成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">36</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用call()方法&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        AccessProperty obj1 = <span class="keyword">new</span> AccessProperty();</span><br><span class="line">        AccessProperty obj2 = <span class="keyword">new</span> AccessProperty();</span><br><span class="line">        <span class="comment">// 使用第二个对象调用静态变量</span></span><br><span class="line">        obj2.i = <span class="number">63</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个实例调用变量i的结果：&quot;</span>+obj1.i++);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个实例调用变量i的结果：&quot;</span>+obj2.i);</span><br><span class="line">        obj1.call();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个实例调用变量i的结果为：&quot;</span>+obj1.i);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个实例调用变量i的结果为：&quot;</span>+obj2.i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">第一个实例调用变量i的结果：63</span></span><br><span class="line"><span class="comment">第二个实例调用变量i的结果：64</span></span><br><span class="line"><span class="comment">调用call()方法</span></span><br><span class="line"><span class="comment">0 1 2 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第一个实例调用变量i的结果为：3</span></span><br><span class="line"><span class="comment">第二个实例调用变量i的结果为：3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>创建的两个对象位于不同的内存空间，但是他们都共享了静态变量i，所以两个对象调用的都死同一个变量i。第一个输出语句中i++会在调用obj1.i后执行，所以之后的变量i变成了64。调用call方法对i进行了重新的赋值，所以i最后变成了3。</p><h3 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h3><p>被java虚拟机视为“垃圾”：</p><ul><li>对象引用超过其作用范围，这个对象将被视为垃圾</li><li>将对象赋值为null</li></ul><p>但是对于不是通过new操作符创建的对象，java提供了<code>finalize()</code>方法，是Object类的方法，它被声明为protected，用户可以在自己的类中定义这个方法。</p><p>但是如过java虚拟机内存耗尽，也不会发生垃圾回收处理。因此java还提供了<code>System.gc()</code>方法来强制启动垃圾回收器</p><p><em>尝试编写一个类，定义一个修饰符为private的成员变量，并定义两个成员方法，一个方法实现为此成员变量赋值，另一个成员方法获取这个成员变量的值，保证其他类继承该类时能获取该类的成员变量的值。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 test = <span class="keyword">new</span> Test2();</span><br><span class="line">        test.setAge(<span class="number">100</span>);</span><br><span class="line">        System.out.println(test.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>可以将int、boolean等基本类型转化为对象来进行处理</p><table><thead><tr><th>Integer方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>byteValue()</td><td>byte</td><td>以 byte 类型返回该 Integer 的值</td></tr><tr><td>Integer.CompareTo( anotherInteger)</td><td>int</td><td>在数字上比较 Integer 对象。如果这两个值相等，则返回0；如果调用对象的数值小于anotherInteger 的数值，则返回负值；如果调用对象的数值大于anotherInteger 的数值，则返回正值</td></tr><tr><td>equals(Object IntegerObj)</td><td>boolean</td><td>比较此对象与指定对象是否相等</td></tr><tr><td>intValue()</td><td>int</td><td>以 int 型返回此 Integer 对象</td></tr><tr><td>shortValue()</td><td>short</td><td>以 int 型返回此 Integer 对象</td></tr><tr><td>longValue()</td><td>long</td><td>以 long 型返回此 Integer 对象</td></tr><tr><td>floatValue()</td><td>float</td><td>以 float 型返回此 Integer 对象</td></tr><tr><td>doubleValue()</td><td>double</td><td>以 double 型返回此 Integer 对象</td></tr><tr><td>toString()</td><td>String</td><td>返回一个表示该 Integer 值的 String 对象</td></tr><tr><td>valueOf(String str)</td><td>Integer</td><td>返回保存指定的 String 值的 Integer 对象</td></tr><tr><td>parseInt(String str)</td><td>int</td><td>返回包含在由 str 指定的字符串中的数字的等价数值，如“1010101”返回1010101</td></tr><tr><td>parseInt(String str , int radix)</td><td>int</td><td>实现将字符串按照参数 radix 指定的进制转换为 int，如parseInt(1010 , 2)返回,将1010看做二进制返回十进制数10</td></tr></tbody></table><p>除此之外，Integer类还提供了4个常量。</p><ul><li><code>MAX_VALUE</code>：表示int类型可取的最大值，即2<sup>31</sup>-1。</li><li><code>MIN_VALUE</code>：表示int类型可取的最小值，即-2<sup>31</sup></li><li><code>SIZE</code>：用来以二进制补码形式表示int值的位数</li><li><code>TYPE</code>：表示基本类型int的Class实例</li></ul><table><thead><tr><th>Boolean方法</th><th>返回值</th><th>功能</th></tr></thead><tbody><tr><td>booleanValue()</td><td>boolean</td><td>将 Boolean 对象的值以对应的 boolean 值返回</td></tr><tr><td>equals(Object obj)</td><td>boolean</td><td>判断调用该方法的对象与 obj 是否相等。当且仅当参数不是 null，且与调用该 方法的对象一样都表示同一个 boolean 值的 Boolean 对象时，才返回 true</td></tr><tr><td>parseBoolean(String s)</td><td>boolean</td><td>将字符串参数解析为 boolean 值</td></tr><tr><td>toString()</td><td>string</td><td>返回表示该 boolean 值的 String 对象</td></tr><tr><td>valueOf(String s)</td><td>boolean</td><td>返回一个用指定的字符串表示的 boolean 值</td></tr></tbody></table><p><em><code>booleanValue()</code>和<code>valueOf(String s)</code>最大区别在于后者是静态方法，可以不用开辟新的内存空间</em></p><p>boolean的3个常量：</p><ul><li><code>TRUE</code>：表示对应基值true的Boolean对象。</li><li><code>FALSE</code>：表示对应基值false的Boolean对象</li><li><code>TYPE</code>：基本类型boolean的Class对象</li></ul><p>其他Character、Double、Number等等包装类的方法略，自行查询。</p><h2 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h2><h3 id="DecimalFormat类"><a href="#DecimalFormat类" class="headerlink" title="DecimalFormat类"></a>DecimalFormat类</h3><p>在Java中没有格式化的数据遵循以下原则：</p><ul><li>绝对值大雨0.001且小于10000000，使用常规小数形式表示。</li><li>其他使用科学记数法形式表示。</li></ul><p>DecimalFormat是NumberFormat的一个子类，用于格式化十进制数字。通过该类的<code>applyPattern()</code>方法来实现数字格式化。</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>代表阿拉伯数字，该位不存在则显示0</td></tr><tr><td>#</td><td>代表阿拉伯数字，该不存在则不显示</td></tr><tr><td>.</td><td>小数分隔符</td></tr><tr><td>-</td><td>负号</td></tr><tr><td>,</td><td>组分隔符</td></tr><tr><td>E</td><td>分隔科学记数法中的尾数和指数，E后面一般接0，不可接#</td></tr><tr><td>%</td><td>将数字转化为百分数</td></tr><tr><td>\u2030</td><td>转化为千分数</td></tr><tr><td>\u00A4</td><td>作为货币记号</td></tr><tr><td>‘</td><td>为特殊字符添加单引号，系统会将此符号视为普通符号处理</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecimalFormatDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个用于打印输出的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DecimalForamtMode</span><span class="params">(String pattern, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        DecimalFormat myFormat = <span class="keyword">new</span> DecimalFormat(pattern);</span><br><span class="line">        String output = myFormat.format(value);</span><br><span class="line">        System.out.println(value + <span class="string">&quot;,  &quot;</span> + pattern + <span class="string">&quot;,  &quot;</span> + output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;000,000&quot;</span>, <span class="number">12331</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;##,#####&quot;</span>, <span class="number">12331</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#,###$&quot;</span>, <span class="number">12331</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#.##E0&quot;</span>, <span class="number">123310000</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#.##%&quot;</span>, <span class="number">0.44</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#.##\u2030&quot;</span>, <span class="number">0.44</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#.##\u00A4&quot;</span>, <span class="number">0.44</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">12331.0,  000,000,  012,331</span></span><br><span class="line"><span class="comment">12331.0,  ##,#####,  12331</span></span><br><span class="line"><span class="comment">12331.0,  #,###$,  12,331$</span></span><br><span class="line"><span class="comment">1.2331E8,  #.##E0,  1.23E8</span></span><br><span class="line"><span class="comment">0.44,  #.##%,  44%</span></span><br><span class="line"><span class="comment">0.44,  #.##‰,  440‰</span></span><br><span class="line"><span class="comment">0.44,  #.##¤,  0.44￥</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>该类中<code>setGroupSize(2)</code>可以设置数字分组大小，2表示两个数字为一组。</p><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>提供了众多数学常用函数方法，都被定义为了static形式。</p><p>例如<code>Math.sin(Math.PI/2)</code>求90度的正弦值，<code>Math.cos(0)</code>求0的余弦值。</p><p><code>Math.exp(6)</code>e的6次方,<code>Math.log(Math.E)</code>代表ln(e),<code>Math.pow(2,3)</code>2的3次方,sqrt平方根，sbrt立方根等.</p><p><strong>函数取整</strong>：<code>Math.ceil()</code>向上取整；<code>Math.floor()</code>向下取整；<code>Math.rint()</code>去最接近的整数，一样近取偶数；<code>Math.round(float a)</code>加上0.5返回最接近的整数数；<code>Math.round(double a)</code>加上0.5返回最接近的整数，并强制转化为长整型。</p><p>max、min、abs等略</p><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><ol><li><p><code>Math.random()</code>随机生成0~1之间的double型数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取1～10之间随机整数</span></span><br><span class="line">(<span class="keyword">int</span>)(Math.random()*<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>随机字符</strong>: <code>(char)(cha1 + Math.random()*(char2-char1+1));</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取随机a-z之间的字符</span></span><br><span class="line">(<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span>+Math.random()*(<span class="string">&#x27;z&#x27;</span>-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li><p>Random类</p><p><code>java.util.Random</code>。通过实例化一个Random对象创建一个随机数生成器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br></pre></td></tr></table></figure><p><code>nextInt()</code>, <code>nextFloat()</code>, <code>nextBoolean()</code>分别返回随机整数、浮点数和布尔值等</p><p><code>ints</code>方法返回随机整数，设置参数可以限制范围，取值数量等等。</p></li></ol><h3 id="大数字高精度运算"><a href="#大数字高精度运算" class="headerlink" title="大数字高精度运算"></a>大数字高精度运算</h3><p>java提供了BigInteger和BigDecimal分别针对大数字处理和大小数处理的类，精度很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数必须以字符串形式村子啊</span></span><br><span class="line">BigInteger demoInt = <span class="keyword">new</span> BigInteger(<span class="string">&quot;36&quot;</span>);</span><br><span class="line"><span class="comment">// 注意BigInteger对象的互相运算</span></span><br><span class="line">demoInt.add(<span class="keyword">new</span> BigInteger(<span class="string">&quot;8&quot;</span>));</span><br><span class="line">demoInt.multiply(<span class="keyword">new</span> BigInteger(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">demoInt.subtract(<span class="keyword">new</span> BigInteger(<span class="string">&quot;30&quot;</span>));</span><br><span class="line">demoInt.divide(<span class="keyword">new</span> BigInteger(<span class="string">&quot;3&quot;</span>));</span><br></pre></td></tr></table></figure><p><code>divideAndRemainder()</code>该除法方法返回数组，第一个为商，第二个为余数。</p><p>BigDecimal类的使用类似，但是构造参数除了string还可以是double：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal demoDec = <span class="keyword">new</span> BigDecimal(String val);</span><br><span class="line">BigDecimal demoDec = <span class="keyword">new</span> BigDecimal(<span class="keyword">double</span> val);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要做自我知识点的补充，不是全面系统的笔记&lt;/p&gt;
&lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Postman接口测试</title>
    <link href="http://123.57.158.5/2021/06/23/postman-test/"/>
    <id>http://123.57.158.5/2021/06/23/postman-test/</id>
    <published>2021-06-22T16:19:20.000Z</published>
    <updated>2021-07-04T17:37:11.447Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试流程：</p><ol><li><p>获取接口信息</p><p>通过接口文档和抓包获取接口基本调用方式和返回</p></li><li><p>接口测试用例设计</p><p>根据获取到的接口信息，按照接口测试用例设计方法，设计参数和预期返回结果</p></li><li><p>接口发包</p><p>使用工具或者编程想接口传递参数</p></li><li><p>返回信息验证</p><p>获取接口返回的结果，进行解析和验证</p></li></ol><p>接口测试用例的设计：</p><p>以高德地图的一个get请求的ip查询请求地址为例，在postman中新建一个get请求，将抓包到的request url添加进去，可以测试接口的各项功能。例如改变参数后接口是否正常使用，例如各个参数是否必填。</p><p><img src="/2021/06/23/postman-test/image-20210624004047302.png" alt="image-20210624004047302"></p><p>当不勾选key参数后：</p><p><img src="/2021/06/23/postman-test/image-20210624004406045.png" alt="image-20210624004406045"></p><p>当填写错误的ip地址：</p><p><img src="/2021/06/23/postman-test/image-20210624004335989.png" alt="image-20210624004335989"></p><p>可以验证该get接口是否符合设计需求。</p><p>可以在ip地址参数中按照<strong>等价类</strong>及<strong>边界值</strong>法进行测试</p><p>在postman发送请求过程中，已经默默带上了请求头（request headers）信息，如果是在浏览器中也会带有。</p><p><img src="/2021/06/23/postman-test/image-20210624010413171.png" alt="image-20210624010413171"></p><h2 id="接口收发包过程"><a href="#接口收发包过程" class="headerlink" title="接口收发包过程"></a>接口收发包过程</h2><p>postman接口请求过程：</p><p>获取地址（URL）——设置http方法（GET POST等）——设置请求头域（request headers）——填写请求参数</p><p>postman接口响应验证：</p><p>http状态码——收到接口响应——检查返回头域（response headers）——查看返回主体内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接口测试流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取接口信息&lt;/p&gt;
&lt;p&gt;通过接口文档和抓包获取接口基本调用方式和返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接口测试用例设计&lt;/p&gt;
&lt;p&gt;根据获取到的接口信息，按照接口测试用例设计方法，设计参数和预期返回结果&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    
    <category term="Postman" scheme="http://123.57.158.5/tags/Postman/"/>
    
    <category term="接口测试" scheme="http://123.57.158.5/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java初学部分笔记(从语言基础到数组)</title>
    <link href="http://123.57.158.5/2021/06/09/java1/"/>
    <id>http://123.57.158.5/2021/06/09/java1/</id>
    <published>2021-06-09T14:53:06.000Z</published>
    <updated>2021-07-04T17:00:04.846Z</updated>
    
    <content type="html"><![CDATA[<p>每一个java程序必须包含一个<code>main()</code>方法，含有<code>main()</code>方法的类被称为主类。与python不同，需要有分号，单双引号有区分，同时文件名必须和类名同名。</p><p>Terminal运行java程序，先进行编译，后运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac xxx.java</span><br><span class="line">java xxx</span><br></pre></td></tr></table></figure><h2 id="java语言基础"><a href="#java语言基础" class="headerlink" title="java语言基础"></a>java语言基础</h2><h3 id="自增减运算符"><a href="#自增减运算符" class="headerlink" title="自增减运算符"></a>自增减运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++a(--a)<span class="comment">//表示在使用变量a之前，先使a的值加（减）1</span></span><br><span class="line">a++(a++)<span class="comment">//表示在使用变量a之后，使a的值加（减）1</span></span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>；</span><br><span class="line">b = ++a;<span class="comment">//将a增加1，此时a为2，将a赋值给b，b为2</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">b = a++;<span class="comment">//将a赋值给b，此时b为1，再将a增加1，a为2</span></span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><strong>按位与</strong>：运算符<code>&amp;</code>，如果两个整型数据a、b对应位置都是1，则结果位才是1，否则为0</p><p><strong>按位或</strong>：运算符<code>|</code>，如果两个操作数对应位都是0，则结果才是0，否则为1</p><p><strong>按位取反</strong>：运算符<code>~</code>，对操作数二进制中的数取反</p><p><strong>按位异或</strong>：运算符<code>^</code>，当两个操作数的对应位相同（都为1或0），则结果为0，否则为1</p><p><strong>移位操作</strong>：<code>&lt;&lt;</code>：左移，右边移动的位补0。<code>&gt;&gt;</code>：右移，左边移空填入最高位的数。<code>&gt;&gt;&gt;</code>：无符号右移，左边移空位填入0</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件？值1:值2</span><br></pre></td></tr></table></figure><p>若条件为true，取值1，否则取值2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1&lt;2如果如果为真，返回true，否则返回false，最后赋值给a</span></span><br><span class="line"><span class="keyword">boolean</span> a = <span class="number">1</span>&lt;<span class="number">2</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="for语句-foreach语句"><a href="#for语句-foreach语句" class="headerlink" title="for语句\foreach语句"></a>for语句\foreach语句</h3><p>for语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach语句是for语句的变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量x: 遍历对象obj)&#123;</span><br><span class="line">  引用x的语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x: arr)&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;遍历arr输出&quot;</span>+x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p>break只会跳出所在位置的内层循环，如果需要通过break跳出外层循环，需要给外层循环指定名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Loop: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j = j + <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">break</span> Loop;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i + <span class="string">&quot;,&quot;</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continue跳过本次循环到下一次循环，continue生效了，后面的语句就不执行。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 等价于 String a = new String(&quot;hello&quot;);</span></span><br><span class="line"><span class="keyword">char</span> b = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">String c = <span class="keyword">new</span> String(b, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 3为截取3个字符。等价于 String c = &quot;cde&quot;;</span></span><br></pre></td></tr></table></figure><p>字符串查找方法中，<code>IndexOf()</code>/<code>LastIndexOf()</code>返回指定字符（串）（最后一次出现）的索引位置，值得注意的是<code>LastIndexOf()</code>中参数如果为<code>&quot;&quot;</code>，其结果等价于<code>length()</code>方法，返回字符串长度。</p><p><code>charAt()</code>返回指定位置字符串，<code>substring(int beginIndex, int endIndex)</code>截取字符串（结束字符串参数可省略）</p><p><code>trim()</code>返回字符串去除<strong>前后</strong>空格后的结果，<code>replace(&quot;old&quot;,&quot;new&quot;)</code>返回替换字符（串）后结果</p><p><code>startWith()</code>/<code>endsWith()</code>返回字符串是否以xx开头或结尾的布尔值。</p><p>java语言也有<code>equals()</code>方法比较字符串，不同于<code>==</code>比较内存地址。<code>equalsIngoreCase()</code>方法不区分大小写，返回布尔值</p><p><code>compareTo()</code>方法返回规则为，对比二者的第一个字符，如果不同返回字符的<strong>Unicode差值</strong>，结束；如果第一个字符相同，对比随后的字符，直到字符不同，返回差值结束。如果字符串完全相同（equal方法返回true），返回值为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">Sytem.out.println(a.compareTo(b));</span><br><span class="line"><span class="comment">// 返回的是o的Unicode值减去h的Unicode值,-7</span></span><br></pre></td></tr></table></figure><p><code>toLowerCase()</code>/<code>toUpperCase()</code>返回转换大小写之后的字符串。</p><p><code>split(String sign, int limit)</code>方法分割字符串，limit是最高分割次数（可选参数），如果有多个分隔符需要<code>|</code>分割。返回的是数组对象</p><p>注意：<code> | . &amp; * +</code> 是转义字符, 要加<code>\\</code>转义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String local_ip = <span class="string">&quot;192.168.0.1&quot;</span>;</span><br><span class="line">String[] ip_list = local_ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"><span class="comment">// 转换为列表显示</span></span><br><span class="line">System.out.println(Arrays.toString(ip_list));</span><br><span class="line"><span class="comment">// 逐个输出字符串数字</span></span><br><span class="line"><span class="keyword">for</span>(String num : ip_list)&#123;</span><br><span class="line">  System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>format()</code>方法实现对日期/时间的格式化转换，格式转换符可以自行搜索查询。</p><p>常见日期转换符：</p><table><thead><tr><th>转换符</th><th>说　　明</th><th>示　　例</th></tr></thead><tbody><tr><td>%tF</td><td>“年-月-日”格式（4位年份）</td><td>2021-03-20</td></tr><tr><td>%tD</td><td>“月/日/年”格式（2位年份）</td><td>03/20/21</td></tr><tr><td>%tr</td><td>“时：分：秒 PM（AM）”格式（12小时制）</td><td>03:22:06 下午</td></tr><tr><td>%tT</td><td>“时：分：秒”格式（24小时制）</td><td>15:23:50</td></tr><tr><td>%tR</td><td>“时：分”格式（24小时制）</td><td>15:23</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">String s = String.format(<span class="string">&quot;%tD&quot;</span>, date);</span><br></pre></td></tr></table></figure><p>常见类型转换符：</p><table><thead><tr><th align="center">转换符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">%s</td><td align="center">字符串类型</td></tr><tr><td align="center">%c</td><td align="center">字符类型</td></tr><tr><td align="center">%b</td><td align="center">布尔类型</td></tr><tr><td align="center">%d</td><td align="center">整数类型（十进制）</td></tr><tr><td align="center">%x</td><td align="center">整数类型（十六进制）</td></tr><tr><td align="center">%o</td><td align="center">整数类型（八进制）</td></tr><tr><td align="center">%f</td><td align="center">浮点类型</td></tr><tr><td align="center">%a</td><td align="center">十六进制浮点类型</td></tr><tr><td align="center">%e</td><td align="center">指数类型</td></tr><tr><td align="center">%g</td><td align="center">通用浮点类型（f和e类型中较短的）</td></tr><tr><td align="center">%h</td><td align="center">散列码</td></tr><tr><td align="center">%%</td><td align="center">百分比类型</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(<span class="string">&quot;%o&quot;</span>,<span class="number">100</span>));</span><br><span class="line"><span class="comment">//将100由十进制转化为8进制，输出144</span></span><br></pre></td></tr></table></figure><p>注意：不能将上面的方法用于字符串转化数字，字符串转化数字有<code>parseInt()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(<span class="string">&quot;100&quot;</span>,<span class="number">16</span>);</span><br><span class="line"><span class="comment">//将“100”转化为16进制</span></span><br></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><strong>正则表达式</strong>进行字符串匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String reg = <span class="string">&quot;^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;3&#125;)([0-9]|X)$&quot;</span>;</span><br><span class="line"><span class="comment">//匹配身份证号</span></span><br><span class="line">String str1 = <span class="string">&quot;36220119990101&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;362201199901015201&quot;</span>;</span><br><span class="line">System.out.println(str1.matches(reg));</span><br><span class="line">System.out.println(str3.matches(reg));</span><br></pre></td></tr></table></figure><h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><p>java对字符串进行“+”拼接等操作后，会创建新的字符串，占用内存；所以对于频繁的字符串修改操作时候，可以使用<strong>StringBuilder类</strong>，是一种可变字符序列，提高效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">  builder.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = endtime-starttime;</span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure><p>此外，该类还带有<code>append()/insert()/delete()</code>等方法。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 申明，再用new运算符进行内存分配</span></span><br><span class="line"><span class="keyword">int</span> arr[];</span><br><span class="line">String str[];</span><br><span class="line"><span class="comment">// 创建5个元素的整型数组</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 申明的同时为数组分配内存</span></span><br><span class="line"><span class="keyword">int</span> month[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br></pre></td></tr></table></figure><p>初始化一维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 常用</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>同理初始化二维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>使用二维数组<code>arr[0][0]</code>返回第一行第一列</p><p>使用foreach遍历二维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x[]:arr)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> num:x)&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Arrays.fill(int[] arr, int value)</code>方法将value值赋给arr数组中每个元素，也可以在两个参数中间增加指定范围的索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><code>Arrays.sort(object)</code>可对数组进行升序排序，结合了快速排序与归并排序的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将随机数放入数组后再排序</span></span><br><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  arr[i] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">  System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(<span class="string">&quot;====&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Arrays.copyOf(arr,int newlength)</code>方法拷贝数组，如果拷贝后长度大于被拷贝数组，则填充0，否则进行截取。<code>Arrays.copyOfRange(arr,int fromIndex,int toIndex)</code>截取长度复制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每一个java程序必须包含一个&lt;code&gt;main()&lt;/code&gt;方法，含有&lt;code&gt;main()&lt;/code&gt;方法的类被称为主类。与python不同，需要有分号，单双引号有区分，同时文件名必须和类名同名。&lt;/p&gt;
&lt;p&gt;Terminal运行java程序，先进行编译，后</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
</feed>
