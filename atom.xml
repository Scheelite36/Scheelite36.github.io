<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只柑の博客</title>
  
  
  <link href="http://123.57.158.5/atom.xml" rel="self"/>
  
  <link href="http://123.57.158.5/"/>
  <updated>2021-10-23T03:51:43.480Z</updated>
  <id>http://123.57.158.5/</id>
  
  <author>
    <name>一只柑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EndNote使用指南</title>
    <link href="http://123.57.158.5/2021/10/23/EndNoteForFHY/"/>
    <id>http://123.57.158.5/2021/10/23/EndNoteForFHY/</id>
    <published>2021-10-23T03:36:08.000Z</published>
    <updated>2021-10-23T03:51:43.480Z</updated>
    
    <content type="html"><![CDATA[<p>EndNote是一个文献管理软件，使用它可以方便的对文献进行管理，同时通过它的嵌入工具，可以方便的边书写论文边插入参考文献。</p><p>软件版本：</p><p>endnote x9</p><p>office 2016</p><h2 id="1-新建EndNote库"><a href="#1-新建EndNote库" class="headerlink" title="1.  新建EndNote库"></a>1.  新建EndNote库</h2><p><strong>介绍建立文献库基本操作</strong></p><p>首先，打开endnote新建库，这就是你以后的文献库，用于存放并管理你阅读的文献。如果C盘空间不够大的话可以放在其他盘上，默认在C盘文档文件夹下。</p><img src="/2021/10/23/EndNoteForFHY/image-20211022235039187-4960420.png" alt="image-20211022235039187" style="zoom: 50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023000045172-4960420.png" alt="image-20211023000045172" style="zoom:50%;"><p>打开endnote库后，在我的分组中右击可以新建组，可以像这样：综述、研究方法、研究背景…等等新建组，对不同类型文献进行区分。还可以新建组集，例如毕业论文一个组集，小论文一个组集等等。当然可以后期调整，whatever。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023001655965-4960420.png" alt="image-20211023001655965" style="zoom: 50%;"><h3 id="导入样式"><a href="#导入样式" class="headerlink" title="导入样式"></a>导入样式</h3><p>样式指的是文献的引用格式，例如常见的有国标的作者年份格式，和数字编号格式。同时endnote还支持许多期刊的引用格式，可以在各种样式之间方便的进行切换。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023005911004-4960420.png" alt="image-20211023005911004" style="zoom:50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023005955736-4960420.png" alt="image-20211023005955736" style="zoom:50%;"><p>对于endnote样式，我们可以通过[endnote官网](<a href="https://endnote.com/downloads/styles/">Output Styles | EndNote</a>)进行查找和下载</p><p>下载完成后导入endnote中：</p><p>直接使用endnote打开下载好的ens格式文件，另存之后关闭，随后样式就导入成功了</p><img src="/2021/10/23/EndNoteForFHY/image-20211023011341993-4960420.png" alt="image-20211023011341993" style="zoom:50%;"><p>选择该样式，之后就可以愉快使用这个样式进行文件的自动引用了。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023011539175-4960420.png" alt="image-20211023011539175" style="zoom: 50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023011721575.png" alt="image-20211023011721575" style="zoom:50%;"><h2 id="2-文献管理"><a href="#2-文献管理" class="headerlink" title="2. 文献管理"></a>2. 文献管理</h2><p><strong>介绍文献的导入与管理</strong></p><p>在阅读文献之前，通常我们会在文献网站上进行关键词检索，找到所需文献后下载，同时对其引用格式进行保存，最后将引用格式与文献pdf进行关联。</p><ol><li><p><em>知网</em></p><p>首先找到目标文献进行下载，将pdf文件保存到本地，没有pdf的下载caj</p><img src="/2021/10/23/EndNoteForFHY/image-20211023014102030-4960420.png" alt="image-20211023014224938" style="zoom:50%;"><p>然后右上的引用图标下载该文献的endnote格式的引用，在弹出的窗口中选择更多格式的引用，找到endnote 导出txt文件</p><img src="/2021/10/23/EndNoteForFHY/image-20211023014942996-4960420.png" alt="image-20211023014942996" style="zoom:50%;"><p>在endnote中导入该txt文件</p><img src="/2021/10/23/EndNoteForFHY/image-20211023015340063-4960420.png" alt="image-20211023015340063" style="zoom:50%;"><p>然后你就在导入的文献中看到了导入的文献(๑¯㉨¯๑)   你可以对他进行分组等等</p><img src="/2021/10/23/EndNoteForFHY/image-20211023101434637-4960420.png" alt="image-20211023101434637" style="zoom:50%;"><p>但是需要注意的是，插入文献经常存在格式不对的情况，比如上图中的期刊名没有正确显示，双击这篇文献，进行修改，将期刊名进行补充，注意去掉%J等不需要的字符，随后保存。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023101709406-4960420.png" alt="image-20211023101709406" style="zoom:50%;"><p>如果你有这篇文章的pdf的话将其添加到附件，endnote就会将文献移动到你的库中。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023102157451-4960420.png" alt="image-20211023102157451" style="zoom:50%;"><img src="/2021/10/23/EndNoteForFHY/image-20211023102549686-4960420.png" alt="image-20211023102549686" style="zoom:50%;"></li><li><p><em>爱思唯尔（ScienceDirect）</em></p><p>如果你们学校购买了爱思唯尔的库的话，通过校网检索文献的方式找到需要的文献（各种文献网站下载引用的逻辑基本都是想通的），先进行下载。然后同样导入库中，需要注意的是endnote同时支持多种格式，enl ris也可以，在这里我们下载ris格式。可以直接打开ris文件，endnote就进行了导入 </p><img src="/2021/10/23/EndNoteForFHY/image-20211023103858485-4960420.png" alt="image-20211023103858485" style="zoom:50%;"><p>导入之后同样进行关联文献的操作，同上，略。</p></li><li><p><em>谷歌学术/百度学术</em></p><p>这两个网站最重要的作用不是进行文献下载的，而是有海量的文献引用资源。如果仅仅需要下载些文献的引用，可以用上（偶尔一些文献也可以通过这些网站直接下载）。</p><p>以谷歌学术（国内需要翻墙访问，当然也可以搜索谷歌学术镜像网站使用）为例：</p><img src="/2021/10/23/EndNoteForFHY/image-20211023104744862-4960420.png" alt="image-20211023104744862" style="zoom:50%;"><p>找到文献点击引用图标，下载enl格式文件打开，就将引用导入了endnote中。之后的操作同</p><p>百度学术同理</p></li><li><p><em>快捷绑定和导入文献的方法</em></p><p>还有一个快捷绑定文献及导入文献的方法，但是只对较新的英文文献的pdf起作用（中文文献支持不太好）。</p><p>下载一篇pdf文献 ，打开方式使用endnote打开，神奇的事情发生了，endnote会自动进行检索！！！并将该文件绑定到库中。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023105929726-4960420.png" alt="image-20211023105929726" style="zoom:50%;"></li></ol><img src="/2021/10/23/EndNoteForFHY/image-20211023110151334-4960420.png" alt="image-20211023110151334" style="zoom:50%;"><ol start="5"><li><p><em>手动新建文献（是在没找到引用的时候用）</em></p><img src="/2021/10/23/EndNoteForFHY/image-20211023110312620-4960420.png" alt="image-20211023110312620" style="zoom:50%;"><p>将文献类型、作者、年份、卷号等等重要的内容一一填入即可</p></li></ol><p>到这里我们就可以方便进行平时文献的管理和阅读了。</p><h2 id="3-文献的引用"><a href="#3-文献的引用" class="headerlink" title="3. 文献的引用"></a>3. 文献的引用</h2><p>到了要写论文的时候，自然是要引用各种文献。</p><p>如果正确安装了endnote后，Word会出现endnote插件，它与endnote软件关联着。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023111138549-4960420.png" alt="image-20211023111138549" style="zoom:50%;"><p>在我们一边写论文时候，一边就可以插入引用。首先将光标停留在文档中需要插入引用的位置，切换到endnote，选择被引用的文献，选择格式，点击引用。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023111515675-4960420.png" alt="image-20211023111515675" style="zoom:50%;"><p>然后文档栋光标位置就自动插入了文献的引用。他是动态进行变化的，如果在文档中进行了删除引用、更新引用的操作，相应的需要，及下文的详情都会变更。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023111747955-4960420.png" alt="image-20211023111747955" style="zoom:50%;"><p>也许你注意到了文档中演示的格式，其实并不那么完美，比如中文文献引用，也加入et al的英文引用规则，所以在文章定稿之后一个非常重要的操作就是，将文献转为纯文本格式，然后进行手动修改。</p><img src="/2021/10/23/EndNoteForFHY/image-20211023112056977-4960420.png" alt="image-20211023112056977" style="zoom:50%;"><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>所以endnote最基本的操作到这里就结束了，它的功能非常强大，也希望你慢慢去摸索其他更好玩更好用的功能，写出好文章！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;EndNote是一个文献管理软件，使用它可以方便的对文献进行管理，同时通过它的嵌入工具，可以方便的边书写论文边插入参考文献。&lt;/p&gt;
&lt;p&gt;软件版本：&lt;/p&gt;
&lt;p&gt;endnote x9&lt;/p&gt;
&lt;p&gt;office 2016&lt;/p&gt;
&lt;h2 id=&quot;1-新建EndNote库</summary>
      
    
    
    
    <category term="生活" scheme="http://123.57.158.5/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="EndNote" scheme="http://123.57.158.5/tags/EndNote/"/>
    
  </entry>
  
  <entry>
    <title>由@Valid注解校验引发的问题之Integer与int的比较</title>
    <link href="http://123.57.158.5/2021/10/10/java-lang/"/>
    <id>http://123.57.158.5/2021/10/10/java-lang/</id>
    <published>2021-10-10T14:39:01.000Z</published>
    <updated>2021-10-10T14:58:20.522Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习spring boot过程中遇到的一个问题</p><p>我在一个请求体model中将需要校验的字段写成了这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateCategoryReq</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;商品分类id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>同时在controller中对该请求体进行了@Valid校验，最后发现，<strong>校验没有生效</strong>，且自动对id进行了填充（？？？）。最后发现@Valid校验本质是校验java.lang中的包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Valid &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而定义变量时候，int类型不允许为空，而integer是可以为null。所以请求体中会对id自动赋值为0。</p><p>所以需要将字段改为包装类定义，才能进行校验。</p><p>扩展 Integer与int的区别：</p><blockquote><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习spring boot过程中遇到的一个问题&lt;/p&gt;
&lt;p&gt;我在一个请求体model中将需要校验的字段写成了这样&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>java流处理</title>
    <link href="http://123.57.158.5/2021/10/06/java-stream/"/>
    <id>http://123.57.158.5/2021/10/06/java-stream/</id>
    <published>2021-10-06T02:27:30.000Z</published>
    <updated>2021-10-10T14:37:45.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li><strong>stream()</strong> − 为集合创建串行流。</li><li><strong>parallelStream()</strong> − 为集合创建并行流。拆分成小任务，使用线程来执行，当数量十分大时候，效率更高</li></ul><p>很容易理解对于需要串行依次执行的一般使用串行流，对于可以并发不需要按顺序执行的可以使用并行流。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;dsf&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;gjw&quot;</span>, <span class="string">&quot;persimmon&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉为空的字符串，保持原有顺序 使用串行流</span></span><br><span class="line">List&lt;String&gt; filteredString = strings.stream()</span><br><span class="line">  .filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 分别打印</span></span><br><span class="line">filteredString.forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计为空字符串的数量 可以使用并行流</span></span><br><span class="line">Long count = strings.parallelStream().filter(String::isEmpty).count();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>此外流还提供了很多limit map sort 方法等等，可以查看文档或者<a href="https://www.runoob.com/java/java8-streams.html">菜鸟教程</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除空字符串，用逗号将所有元素合并起来</span></span><br><span class="line">String combinedStrings = strings.stream().filter(string -&gt; !string.isEmpty()).</span><br><span class="line">  collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">System.out.println(combinedStrings);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素去重去空字符 前后加上减号输出</span></span><br><span class="line">List&lt;String&gt; handledStrings = strings.stream().filter(string -&gt; !string.isEmpty()).distinct()</span><br><span class="line">  .map(string -&gt; <span class="string">&quot;-&quot;</span>+string+<span class="string">&quot;-&quot;</span>).collect(Collectors.toList());</span><br><span class="line">handledStrings.forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取十个5以内的随机整数排序并平方处理后输出</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints(<span class="number">10</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  .map(x -&gt; x * x).forEach(System.out::println);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight pl</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring MongoTemplate踩坑</title>
    <link href="http://123.57.158.5/2021/09/14/springProject/"/>
    <id>http://123.57.158.5/2021/09/14/springProject/</id>
    <published>2021-09-14T15:29:08.000Z</published>
    <updated>2021-10-06T02:30:57.567Z</updated>
    
    <content type="html"><![CDATA[<p>在使用spring的MongoTemplate进行mongodb操作时候踩了许多坑，记录一下<a href="https://www.springcloud.cc/spring-data-mongodb.html#mongo-template">MongoTemplate</a>的一些操作。</p><h3 id="Criteria类"><a href="#Criteria类" class="headerlink" title="Criteria类"></a>Criteria类</h3><p>用于创建mongodb数据查询条件，这些criteria查询条件之间可以进行相互拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = Criteria.where(<span class="string">&quot;city&quot;</span>).is(<span class="string">&quot;Yichun&quot;</span>)</span><br><span class="line">  .and(<span class="string">&quot;age&quot;</span>).gte(<span class="number">18</span>);</span><br><span class="line">criteria.and(<span class="string">&quot;sex&quot;</span>).is(<span class="string">&quot;male&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是同一个查询字段不可以重复进行拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">if</span>(query.startTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">  criteria.and(<span class="string">&quot;create_time&quot;</span>).gt(startTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(query.endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">  criteria.and(<span class="string">&quot;create_time&quot;</span>).lt(endTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参考写法</span></span><br><span class="line"><span class="keyword">if</span>(query.startTime != <span class="keyword">null</span> &amp;&amp; query.endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">  criteria.and(<span class="string">&quot;create_time&quot;</span>).gt(startTime).lt(endTime);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(query.startTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">    criteria.and(<span class="string">&quot;create_time&quot;</span>).gt(startTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(query.endTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">    criteria.and(<span class="string">&quot;create_time&quot;</span>).lt(endTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Criteria类中的 andOperator、orOperator可以对criteria查询条件进行组合使用，但是不可以重复拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Criteria criteria = Criteria.where(<span class="string">&quot;city&quot;</span>).is(<span class="string">&quot;Shenzhen&quot;</span>);</span><br><span class="line">Criteria criteria1 = Criteria.where(<span class="string">&quot;age&quot;</span>).gt(<span class="number">18</span>);</span><br><span class="line">Criteria.andOperator(criteria,criteria1);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">criteria.andOperator(criteria1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果此时继续对criteria再次使用andOperator组合，查询条件将不可用</span></span><br><span class="line"><span class="comment">// 报错Due to limitations of the com.mongodb.BasicDocument, you can&#x27;t add a second ...</span></span><br><span class="line">criteria.andOperator(Criteria.where(<span class="string">&quot;gender&quot;</span>).is(<span class="string">&quot;male&quot;</span>));</span><br></pre></td></tr></table></figure><p>使用查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line">  </span><br><span class="line">Query query = <span class="keyword">new</span> Query(criteria);</span><br><span class="line">mongoTemplate.count(query,xxxDocument.class);</span><br><span class="line">mongoTemplate.findOne(query.xxxDocuent.class);</span><br></pre></td></tr></table></figure><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><blockquote><p>MongoDB 中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果。</p></blockquote><p>通过<a href="https://www.runoob.com/mongodb/mongodb-aggregate.html">聚合查询</a>可以对数据进行分组，统计等等。</p><p>聚合查询的条件由一个个管道（管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数）组成。</p><h4 id="example1"><a href="#example1" class="headerlink" title="example1"></a>example1</h4><p><code>unwind</code> 是对符合匹配出的内容按照data数组中每个字段进行分解，分解成一个个文档</p><p><code>getMappedResults</code>以map形式返回查询结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;xxDTO&gt; <span class="title">mongodbExample</span><span class="params">(xxQuery query)</span> </span>&#123;</span><br><span class="line">      Criteria criteria = Criteria.where(<span class="string">&quot;xx_column&quot;</span>).in(query.getxxList())</span><br><span class="line">              .and(<span class="string">&quot;xx&quot;</span>).in(query.getxxList())</span><br><span class="line">              .and(<span class="string">&quot;xxx&quot;</span>).is(query.getxx())</span><br><span class="line">              .and(<span class="string">&quot;xxxx&quot;</span>).is(query.getxx());</span><br><span class="line"></span><br><span class="line">      Aggregation aggregation = newAggregation(</span><br><span class="line">              match(criteria),</span><br><span class="line">              unwind(<span class="string">&quot;data&quot;</span>),</span><br><span class="line">              match(Criteria.where(<span class="string">&quot;data.y_name&quot;</span>).is(query.getxxName())),</span><br><span class="line">              project()</span><br><span class="line">                      .and(<span class="string">&quot;limit_id&quot;</span>).as(<span class="string">&quot;limit_id&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.x_name&quot;</span>).as(<span class="string">&quot;x_name&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.x_unit&quot;</span>).as(<span class="string">&quot;x_unit&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.x_value&quot;</span>).as(<span class="string">&quot;x_value&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_name&quot;</span>).as(<span class="string">&quot;y_name&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_unit&quot;</span>).as(<span class="string">&quot;y_unit&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_low&quot;</span>).as(<span class="string">&quot;y_low&quot;</span>)</span><br><span class="line">                      .and(<span class="string">&quot;data.y_high&quot;</span>).as(<span class="string">&quot;y_high&quot;</span>)</span><br><span class="line">                      .andExclude(<span class="string">&quot;_id&quot;</span>)</span><br><span class="line">      );</span><br><span class="line">      AggregationResults&lt;xxDTO&gt; aggregate = mongoTemplate.aggregate(aggregation, <span class="string">&quot;INPUT_COLLECTION_NAME&quot;</span>, xxxDTO.class);</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">return</span> aggregate.getMappedResults();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h4><blockquote><p>此示例基于MongoDB聚合框架文档中的“ <a href="http://docs.mongodb.org/manual/tutorial/aggregation-examples/#largest-and-smallest-cities-by-state">最大和最小城市”</a>示例。我们添加了额外的排序，以使用不同的MongoDB版本生成稳定的结果。在这里，我们希望通过使用聚合框架按每个州的人口返回最小和最大的城市。此示例演示分组，排序和投影（选择）。</p></blockquote><p><code>nested</code>用于在聚合查询过程中创建一个次级文档，在这里面分别是“biggestCity”和“samllestCity”，同时将”biggestCity”，”biggestPop”字段名分别绑定为”name”, “population”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipInfo</span> </span>&#123;</span><br><span class="line">   String id;</span><br><span class="line">   String city;</span><br><span class="line">   String state;</span><br><span class="line">   <span class="meta">@Field(&quot;pop&quot;)</span> <span class="keyword">int</span> population;</span><br><span class="line">   <span class="meta">@Field(&quot;loc&quot;)</span> <span class="keyword">double</span>[] location;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   <span class="keyword">int</span> population;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipInfoStats</span> </span>&#123;</span><br><span class="line">   String id;</span><br><span class="line">   String state;</span><br><span class="line">   City biggestCity;</span><br><span class="line">   City smallestCity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.data.mongodb.core.aggregation.Aggregation.*;</span><br><span class="line"></span><br><span class="line">TypedAggregation&lt;ZipInfo&gt; aggregation = newAggregation(ZipInfo.class,</span><br><span class="line">    group(<span class="string">&quot;state&quot;</span>, <span class="string">&quot;city&quot;</span>)</span><br><span class="line">       .sum(<span class="string">&quot;population&quot;</span>).as(<span class="string">&quot;pop&quot;</span>),</span><br><span class="line">    sort(ASC, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;state&quot;</span>, <span class="string">&quot;city&quot;</span>),</span><br><span class="line">    group(<span class="string">&quot;state&quot;</span>)</span><br><span class="line">       .last(<span class="string">&quot;city&quot;</span>).as(<span class="string">&quot;biggestCity&quot;</span>)</span><br><span class="line">       .last(<span class="string">&quot;pop&quot;</span>).as(<span class="string">&quot;biggestPop&quot;</span>)</span><br><span class="line">       .first(<span class="string">&quot;city&quot;</span>).as(<span class="string">&quot;smallestCity&quot;</span>)</span><br><span class="line">       .first(<span class="string">&quot;pop&quot;</span>).as(<span class="string">&quot;smallestPop&quot;</span>),</span><br><span class="line">    project()</span><br><span class="line">       .and(<span class="string">&quot;state&quot;</span>).previousOperation()</span><br><span class="line">       .and(<span class="string">&quot;biggestCity&quot;</span>)</span><br><span class="line">          .nested(bind(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;biggestCity&quot;</span>).and(<span class="string">&quot;population&quot;</span>, <span class="string">&quot;biggestPop&quot;</span>))</span><br><span class="line">       .and(<span class="string">&quot;smallestCity&quot;</span>)</span><br><span class="line">          .nested(bind(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;smallestCity&quot;</span>).and(<span class="string">&quot;population&quot;</span>, <span class="string">&quot;smallestPop&quot;</span>)),</span><br><span class="line">    sort(ASC, <span class="string">&quot;state&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">AggregationResults&lt;ZipInfoStats&gt; result = mongoTemplate.aggregate(aggregation, ZipInfoStats.class);</span><br><span class="line">ZipInfoStats firstZipInfoStats = result.getMappedResults().get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>请注意，<code>ZipInfo</code>类映射给定输入集合的结构。<code>ZipInfoStats</code>类以所需的输出格式定义结构。</p><p>上述列表使用以下算法：</p><ol><li>使用<code>group</code>操作从输入集合中定义组。分组标准是<code>state</code>和<code>city</code>字段的组合，它们形成组的ID结构。我们使用<code>sum</code>运算符从分组元素聚合<code>population</code>属性的值，并将结果保存在<code>pop</code>字段中。</li><li>使用<code>sort</code>操作按<code>pop</code>，<code>state</code>和<code>city</code>字段按升序对中间结果进行排序，以便最小的城市位于顶部，最大的城市位于结果的底部。请注意，<code>state</code>和<code>city</code>上的排序是针对组ID字段（MongoDB处理的Spring Data）隐式执行的。</li><li>再次使用<code>group</code>操作将中间结果分组为<code>state</code>。请注意，<code>state</code>再次隐式引用组ID字段。我们在<code>project</code>操作中分别调用<code>last(…)</code>和<code>first(…)</code>运算符来选择最大和最小城市的名称和人口数。</li><li>从上一个<code>group</code>操作中选择<code>state</code>字段。请注意，<code>state</code>再次隐式引用组ID字段。由于我们不希望显示隐式生成的ID，因此我们使用<code>and(previousOperation()).exclude()</code>从上一个操作中排除ID。因为我们想要在输出类中填充嵌套的<code>City</code>结构，所以我们必须使用嵌套方法发出适当的子文档。</li><li>在<code>sort</code>操作中按升序对<code>StateStats</code>的结果列表按其状态名称进行排序。</li></ol><p>请注意，我们将作为第一个参数传递的<code>ZipInfo</code>类的输入集合的名称派生到<code>newAggregation</code>方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用spring的MongoTemplate进行mongodb操作时候踩了许多坑，记录一下&lt;a href=&quot;https://www.springcloud.cc/spring-data-mongodb.html#mongo-template&quot;&gt;MongoTemplate&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="实战" scheme="http://123.57.158.5/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="Mongo" scheme="http://123.57.158.5/tags/Mongo/"/>
    
  </entry>
  
  <entry>
    <title>AOP环绕通知</title>
    <link href="http://123.57.158.5/2021/08/30/aop-round-advice/"/>
    <id>http://123.57.158.5/2021/08/30/aop-round-advice/</id>
    <published>2021-08-29T16:26:20.000Z</published>
    <updated>2021-09-01T12:51:33.986Z</updated>
    
    <content type="html"><![CDATA[<p>简单演示aop中的环绕通知的作用实例，用于打印方法执行的时间进行排查，优化项目效率。</p><p>项目结构：</p><p><img src="/2021/08/30/aop-round-advice/image-20210831004102587.png" alt="image-20210831004102587"></p><p>UserDao、UserService等略</p><p>MethodChecker：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodChecker</span> </span>&#123;</span><br><span class="line"><span class="comment">//    ProceedingJoinPoint在原有JoinPoint基础上可以控制目标方法是否执行</span></span><br><span class="line"><span class="comment">//    环绕通知 需要将目标方法返回值返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">check</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//        执行方法，执行proceed方法之前的就相当于前置通知，后面的相当于后置通知，其本身还可以处理通知返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">            Object ret = proceedingJoinPoint.proceed();</span><br><span class="line">            <span class="keyword">long</span> endTime = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">            <span class="keyword">long</span> durationTime = endTime-startTime;</span><br><span class="line">            SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH-mm-ss SSS&quot;</span>);</span><br><span class="line">            String now = simpleDateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">            String className = proceedingJoinPoint.getTarget().getClass().getName();</span><br><span class="line">            String methodName = proceedingJoinPoint.getSignature().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;---&gt;&quot;</span>+now+<span class="string">&quot;  &quot;</span>+className+<span class="string">&quot;.&quot;</span>+methodName+<span class="string">&quot;(&quot;</span>+durationTime+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.orange.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.orange.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;methodChecker&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.orange.aspect.MethodChecker&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.orange..*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;methodChecker&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;check&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringApplication:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.orange.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">        UserService userService = applicationContext.getBean(<span class="string">&quot;userService&quot;</span>,UserService.class);</span><br><span class="line">        userService.createUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解AOP"><a href="#注解AOP" class="headerlink" title="注解AOP"></a>注解AOP</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    使用ioc注解式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.orange&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用aop注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>给UserDao、UserService添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>给切面方法添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodChecker</span> </span>&#123;</span><br><span class="line"><span class="comment">//    ProceedingJoinPoint在原有JoinPoint基础上可以控制目标方法是否执行</span></span><br><span class="line"><span class="comment">//    环绕通知 需要将目标方法返回值返回</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.orange..*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">check</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单演示aop中的环绕通知的作用实例，用于打印方法执行的时间进行排查，优化项目效率。&lt;/p&gt;
&lt;p&gt;项目结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/08/30/aop-round-advice/image-20210831004102587.png&quot; alt=&quot;i</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="AOP" scheme="http://123.57.158.5/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>使用反射简单模拟spring的ioc容器</title>
    <link href="http://123.57.158.5/2021/08/27/spring-ioc/"/>
    <id>http://123.57.158.5/2021/08/27/spring-ioc/</id>
    <published>2021-08-26T16:12:59.000Z</published>
    <updated>2021-08-26T16:23:03.161Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用反射简单模拟Spring的ioc容器</span><br><span class="line">使用依赖dom4j</span><br></pre></td></tr></table></figure><p>项目结构：</p><p><img src="/2021/08/27/spring-ioc/image-20210827001816735.png" alt="image-20210827001816735"></p><h2 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruits</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象，添加getset方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String origin;</span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString方法方便进行输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fruits&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, origin=&#x27;&quot;</span> + origin + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrigin</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.origin = origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Float price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!--关联entity中对象进行配置，property指的是通过对象getset方法进行初始化--&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;durian&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.orange.entity.Fruits&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;durian&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;origin&quot;</span> value=<span class="string">&quot;Thailand&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;price&quot;</span> value=<span class="string">&quot;99.0&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.context;</span><br><span class="line"><span class="comment">// 创建接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Node;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="comment">//    使用hashmap保存ioc容器的数据，数据以beanid 和 Fruits对象形式保存</span></span><br><span class="line">    Map&lt;String, Object&gt; iocContainer = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            使用dom4j读取配置文件</span></span><br><span class="line">            String filePath = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;/applicationContext.xml&quot;</span>).getPath();</span><br><span class="line">            filePath = <span class="keyword">new</span> URLDecoder().decode(filePath, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            Document document = <span class="keyword">new</span> SAXReader().read(<span class="keyword">new</span> File(filePath));</span><br><span class="line"><span class="comment">//            获取配置文件下的bean</span></span><br><span class="line">            List&lt;Node&gt; nodes = document.getRootElement().selectNodes(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line"><span class="comment">//                获取到beanid和class，使用反射创建对象</span></span><br><span class="line">                Element el = (Element) node;</span><br><span class="line">                String beanId = el.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String className = el.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                Class c = Class.forName(className);</span><br><span class="line">                Object obj = c.getConstructor().newInstance();</span><br><span class="line"><span class="comment">//                获取每一个bean下的property 获取name和value 反射给对象注入属性</span></span><br><span class="line">                List&lt;Node&gt; props = el.selectNodes(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Node prop : props) &#123;</span><br><span class="line">                    Element pro = (Element) prop;</span><br><span class="line">                    String propertyName = pro.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                    Object propertyValue = pro.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    String setMethodName = <span class="string">&quot;set&quot;</span> + propertyName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">                    Type fieldType = c.getDeclaredField(propertyName).getGenericType();</span><br><span class="line">                    Method setMethod = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (fieldType.toString().equals(<span class="string">&quot;class java.lang.String&quot;</span>)) &#123;</span><br><span class="line">                        setMethod = c.getMethod(setMethodName, String.class);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fieldType.toString().equals(<span class="string">&quot;class java.lang.Float&quot;</span>)) &#123;</span><br><span class="line">                        setMethod = c.getMethod(setMethodName, Float.class);</span><br><span class="line">                        propertyValue = Float.parseFloat((String) propertyValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setMethod.invoke(obj, propertyValue);</span><br><span class="line">                &#125;</span><br><span class="line">                iocContainer.put(beanId, obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">        Object obj = iocContainer.get(beanId);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="IocApplication-java"><a href="#IocApplication-java" class="headerlink" title="IocApplication.java"></a>IocApplication.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.orange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.orange.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.orange.context.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.orange.entity.Fruits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IocApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">        Fruits durian = (Fruits) context.getBean(<span class="string">&quot;durian&quot;</span>);</span><br><span class="line">        System.out.println(durian);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="IOC" scheme="http://123.57.158.5/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>ssm部分笔记</title>
    <link href="http://123.57.158.5/2021/08/15/ssm/"/>
    <id>http://123.57.158.5/2021/08/15/ssm/</id>
    <published>2021-08-15T02:26:30.000Z</published>
    <updated>2021-08-26T16:15:09.078Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis 默认开启一级缓存，只在一个sqlsession中使用，不论进行多少次相同的sql查询，结果都在同一个内存地址中。</p><p>commit操作会强制清空一二级缓存</p><p>二次缓存在mapper的namespace中生效，二级缓存的设置：</p><p><img src="/2021/08/15/ssm/image-20210815103904479.png" alt="image-20210815103904479"></p><p>对于列表中存储多个查询对象的，会被当作一个对象存储进缓存，缓存命中率低，所以不推荐使用缓存。</p><p><img src="/2021/08/15/ssm/image-20210815104627699.png" alt="image-20210815104627699"></p><p>一对多（one to many）的one表的xml配置</p><p><img src="/2021/08/15/ssm/image-20210815202133723.png" alt="image-20210815202133723"></p><p>多对一查询（many to one） many表的xml配置</p><p><img src="/2021/08/15/ssm/image-20210815223023718.png" alt="image-20210815223023718"></p><p>xxxx 略，暂时不更新笔记内容了</p><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><p>尤其注意xml的配置问题，特别容易导致错误</p><p>例如xml中mysql数据库的引入，注意是在cj.jdbc包下面，引用错误会导致NoClassDefFoundError</p><h3 id="bean-scope中的单例与多例模式对比"><a href="#bean-scope中的单例与多例模式对比" class="headerlink" title="bean scope中的单例与多例模式对比"></a>bean scope中的单例与多例模式对比</h3><p><img src="/2021/08/15/ssm/Snipaste_2021-08-25_15-13-31.png" alt="Snipaste_2021-08-25_15-13-31"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mybatis 默认开启一级缓存，只在一个sqlsession中使用，不论进行多少次相同的sql查询，结果都在同一个内存地址中。&lt;/p&gt;
&lt;p&gt;commit操作会强制清空一二级缓存&lt;/p&gt;
&lt;p&gt;二次缓存在mapper的namespace中生效，二级缓存的设置：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Spring" scheme="http://123.57.158.5/tags/Spring/"/>
    
    <category term="MyBatis" scheme="http://123.57.158.5/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>IDEA下新建Servlet项目与Tomcat10不兼容问题</title>
    <link href="http://123.57.158.5/2021/08/03/servlet-tomcat-problem/"/>
    <id>http://123.57.158.5/2021/08/03/servlet-tomcat-problem/</id>
    <published>2021-08-03T14:28:13.000Z</published>
    <updated>2021-08-03T14:54:58.004Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习java后端，在使用IDEA新建Servlet+Tomcat项目的时候，碰到了问题。tomcat是通过<code>brew install tomcat</code>安装的。启动项目后可以看到首页内容，但是首页出现的所有超链接页面全部报错404。</p><p>花了一个晚上没查明白，第二天切换为了tomcat@9的最新版，就解决了！太离谱了</p><p><code>brew install tomcat</code>安装的是最新版Tomcat10最新版，但是可能是与Servlet不兼容。后使用<code>brew install tomact@9</code>安装了9的最新版9.0.46，然后将其添加到idea的tomcat路径中</p><p><img src="/2021/08/03/servlet-tomcat-problem/image-20210803225349780.png" alt="image-20210803225349780"></p><p><img src="/2021/08/03/servlet-tomcat-problem/image-20210803225439855.png" alt="image-20210803225439855"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习java后端，在使用IDEA新建Servlet+Tomcat项目的时候，碰到了问题。tomcat是通过&lt;code&gt;brew install tomcat&lt;/code&gt;安装的。启动项目后可以看到首页内容，但是首页出现的所有超链接页面全部报错404。&lt;/p&gt;
&lt;p&gt;花</summary>
      
    
    
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
    <category term="Servlet" scheme="http://123.57.158.5/tags/Servlet/"/>
    
    <category term="Tomcat" scheme="http://123.57.158.5/tags/Tomcat/"/>
    
    <category term="IDEA" scheme="http://123.57.158.5/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Java部分学习笔记3（接口、继承、多态到异常处理）</title>
    <link href="http://123.57.158.5/2021/07/14/java3/"/>
    <id>http://123.57.158.5/2021/07/14/java3/</id>
    <published>2021-07-13T16:26:15.000Z</published>
    <updated>2021-07-18T05:13:13.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口、继承与多态"><a href="#接口、继承与多态" class="headerlink" title="接口、继承与多态"></a>接口、继承与多态</h2><p>继承中重写父类的方法时候，修饰权限只能从小的范围到大的范围，比如父方法的protected权限，子方法不可以为private，可以为public。</p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中所有的类都继承于Object</p><p>几个重要方法：</p><ul><li><p><code>getClass()</code>方法</p><p>返回对象执行时的Class实例，使用此实例可以调用<code>getClass().getName()</code>获得类的名称。</p></li><li><p><code>toString()</code>方法</p><p>将对象以字符串形式返回，可以通过重写为对象提供一个特定的输出模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">reWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;重写函数&quot;</span>+getClass().getName()+<span class="string">&quot;toStrring方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> reWrite());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>equals()</code>方法</p><p>当两个自定义类的对象进行比较时候，返回的是false。因为此处默认实现的是“==”方法比较引用地址。这点<strong>不同于</strong>字符串、整型等对象的比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">overW m = <span class="keyword">new</span> overW();</span><br><span class="line">overW n = <span class="keyword">new</span> overW();</span><br><span class="line">System.out.println(m.equals(n));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>转换注意理解向上转型（父类引用指向子类实例）和向下转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Birds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Seagull</span> <span class="keyword">extends</span> <span class="title">Birds</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        Birds smallSeagull = <span class="keyword">new</span> Seagull();</span><br><span class="line">        <span class="comment">// 向下转型（显式类型转换）</span></span><br><span class="line">        Seagull sg = (Seagull) smallSeagull;</span><br><span class="line">        sg.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意的是，向下转型时候如果父类对象不是子类对象的实例，就会发生ClassCastException异常。</p><p>向上转型不可以调用子类特有的方法没法调用的。</p><p><code>instanceof</code>java关键字，用于判断一个对象实例是否属于某个类。</p><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>在一个类中允许多个重名方法存在，只要参数不同即可，这就是方法的重载。参数类型不同，或参数个数不同，或参数顺序不同都可以构成参数重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...表示不定长参数 相当于a[]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>...a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m:a)&#123;</span><br><span class="line">            sum += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 调用的其实是第一个add方法</span></span><br><span class="line">        System.out.println(add(<span class="number">1</span>));</span><br><span class="line">      <span class="comment">// 重载 调用的是第二个add</span></span><br><span class="line">        System.out.println(add(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是继承父类的方法，方便子类进行调用，同时也方便后期维护。子类也可以对父类方法进行重写，使得程序具有良好的可扩展性。</p><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p>略。因为个人原因暂停更新笔记。。。</p><p>重更时间待定</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;接口、继承与多态&quot;&gt;&lt;a href=&quot;#接口、继承与多态&quot; class=&quot;headerlink&quot; title=&quot;接口、继承与多态&quot;&gt;&lt;/a&gt;接口、继承与多态&lt;/h2&gt;&lt;p&gt;继承中重写父类的方法时候，修饰权限只能从小的范围到大的范围，比如父方法的protected权</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java部分学习笔记（类和对象——数字处理类）</title>
    <link href="http://123.57.158.5/2021/07/04/java2/"/>
    <id>http://123.57.158.5/2021/07/04/java2/</id>
    <published>2021-07-04T04:47:42.000Z</published>
    <updated>2021-10-06T03:55:34.408Z</updated>
    
    <content type="html"><![CDATA[<p>主要做自我知识点的补充，不是全面系统的笔记</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">//定义一个String类型的成员变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="comment">//定义一个getName方法</span></span><br><span class="line">      <span class="keyword">int</span> id = <span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">      setName(<span class="string">&quot;Java&quot;</span>);<span class="comment">//调用类中其他方法</span></span><br><span class="line">      <span class="keyword">return</span> id + <span class="keyword">this</span>.name;<span class="comment">//设置方法的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;<span class="comment">//定义一个setName方法</span></span><br><span class="line">      <span class="keyword">this</span>.name = name;<span class="comment">//将参数数值赋予类中的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Book <span class="title">getBook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//返回Book类引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>主要控制着对类和类的成员变量及成员方法的访问。</p><ul><li><strong>private</strong>：这个类将隐藏其内的所有数据，以免用户直接访问它。</li><li><strong>public</strong>：这个类中的数据可以被子类或其他包中的类使用。</li><li><strong>protected</strong>：只有本包内该类的子类或者其他类可以访问此类中的成员变量和成员方法。</li></ul><p>如果不使用修饰，则预设为protected，即只有一个包中的类可以调用这个类的成员变量或成员方法。同时<strong>类的权限设定会约束类成员的权限和设定</strong>。</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>例子中<code>this.name = name</code>this代表的是本类中的一个对象，第一个name就是成员变量，第二个则是传入的数值参数。</p><p><code>public Book getBook()&#123;return this;&#125;</code>例子中定义了Book类的方法，返回值为Book类对象。</p><h3 id="Java类的构造方法"><a href="#Java类的构造方法" class="headerlink" title="Java类的构造方法"></a>Java类的构造方法</h3><ul><li>每次实例化一个对象，都会调用构造方法</li><li>构造方法没有返回值</li><li>构造方法的名称要与本类的名称相同</li><li>无参的构造方法可以用this调用有参的构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Orange</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="string">&quot;this 调用了有参数的构造方法&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;这是无参的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Orange</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是有参的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>可用于定义静态变量、常量和方法，目的是为了方便<strong>共享数据</strong>和<strong>共享方法</strong>。便于将不同类需要使用的成员分配到一个<strong>固定的内存位置</strong>中。</p><p>一般通过<code>类名.静态类成员</code>调用，而不建议通过<code>对象.静态类成员</code>调用，避免混淆静态成员和非静态成员。</p><p>静态成员同样收到权限修饰符（pbulic、protected、private）的约束。</p><p>静态方法中不可以使用this关键字</p><p>在静态方法中不可以<strong>直接</strong>调用非静态方法</p><p>不能将方法体内的局部变量声明为static</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static method1 initiated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(StaticTest.PI);<span class="comment">//调用静态常量</span></span><br><span class="line">        System.out.println(StaticTest.id);<span class="comment">//调用静态变量</span></span><br><span class="line">        StaticTest.method1();<span class="comment">//调用静态方法</span></span><br><span class="line">      method1();<span class="comment">//调用静态方法（因为该静态方法在该类内部）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips（类的初始化）：</p><p>执行类的时候如果希望先执行类的初始化操作，可以用static定义一个静态区域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的主方法"><a href="#类的主方法" class="headerlink" title="类的主方法"></a>类的主方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主方法是静态的，所以如要<strong>直接</strong>在主方法中调用其他方法，则该方法必须也是静态的。</li><li>主方法没有返回值</li><li>主方法的形参为数组。其中args[0]~args[n]分别带代表程序的第一个参数到第n个参数，可以使用args.length获取参数的个数。</li></ul><p>通过下面这个例子，我们可以来理解该类和对象的属性和行为，静态对象等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessProperty</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义静态成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">36</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用call()方法&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        AccessProperty obj1 = <span class="keyword">new</span> AccessProperty();</span><br><span class="line">        AccessProperty obj2 = <span class="keyword">new</span> AccessProperty();</span><br><span class="line">        <span class="comment">// 使用第二个对象调用静态变量</span></span><br><span class="line">        obj2.i = <span class="number">63</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个实例调用变量i的结果：&quot;</span>+obj1.i++);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个实例调用变量i的结果：&quot;</span>+obj2.i);</span><br><span class="line">        obj1.call();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个实例调用变量i的结果为：&quot;</span>+obj1.i);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个实例调用变量i的结果为：&quot;</span>+obj2.i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">第一个实例调用变量i的结果：63</span></span><br><span class="line"><span class="comment">第二个实例调用变量i的结果：64</span></span><br><span class="line"><span class="comment">调用call()方法</span></span><br><span class="line"><span class="comment">0 1 2 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第一个实例调用变量i的结果为：3</span></span><br><span class="line"><span class="comment">第二个实例调用变量i的结果为：3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>创建的两个对象位于不同的内存空间，但是他们都共享了静态变量i，所以两个对象调用的都死同一个变量i。第一个输出语句中i++会在调用obj1.i后执行，所以之后的变量i变成了64。调用call方法对i进行了重新的赋值，所以i最后变成了3。</p><h3 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h3><p>被java虚拟机视为“垃圾”：</p><ul><li>对象引用超过其作用范围，这个对象将被视为垃圾</li><li>将对象赋值为null</li></ul><p>但是对于不是通过new操作符创建的对象，java提供了<code>finalize()</code>方法，是Object类的方法，它被声明为protected，用户可以在自己的类中定义这个方法。</p><p>但是如过java虚拟机内存耗尽，也不会发生垃圾回收处理。因此java还提供了<code>System.gc()</code>方法来强制启动垃圾回收器</p><p><em>尝试编写一个类，定义一个修饰符为private的成员变量，并定义两个成员方法，一个方法实现为此成员变量赋值，另一个成员方法获取这个成员变量的值，保证其他类继承该类时能获取该类的成员变量的值。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 test = <span class="keyword">new</span> Test2();</span><br><span class="line">        test.setAge(<span class="number">100</span>);</span><br><span class="line">        System.out.println(test.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>可以将int、boolean等基本类型转化为对象来进行处理</p><table><thead><tr><th>Integer方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>byteValue()</td><td>byte</td><td>以 byte 类型返回该 Integer 的值</td></tr><tr><td>Integer.CompareTo( anotherInteger)</td><td>int</td><td>在数字上比较 Integer 对象。如果这两个值相等，则返回0；如果调用对象的数值小于anotherInteger 的数值，则返回负值；如果调用对象的数值大于anotherInteger 的数值，则返回正值</td></tr><tr><td>equals(Object IntegerObj)</td><td>boolean</td><td>比较此对象与指定对象是否相等</td></tr><tr><td>intValue()</td><td>int</td><td>以 int 型返回此 Integer 对象</td></tr><tr><td>shortValue()</td><td>short</td><td>以 int 型返回此 Integer 对象</td></tr><tr><td>longValue()</td><td>long</td><td>以 long 型返回此 Integer 对象</td></tr><tr><td>floatValue()</td><td>float</td><td>以 float 型返回此 Integer 对象</td></tr><tr><td>doubleValue()</td><td>double</td><td>以 double 型返回此 Integer 对象</td></tr><tr><td>toString()</td><td>String</td><td>返回一个表示该 Integer 值的 String 对象</td></tr><tr><td>valueOf(String str)</td><td>Integer</td><td>返回保存指定的 String 值的 Integer 对象</td></tr><tr><td>parseInt(String str)</td><td>int</td><td>返回包含在由 str 指定的字符串中的数字的等价数值，如“1010101”返回1010101</td></tr><tr><td>parseInt(String str , int radix)</td><td>int</td><td>实现将字符串按照参数 radix 指定的进制转换为 int，如parseInt(1010 , 2)返回,将1010看做二进制返回十进制数10</td></tr></tbody></table><p>除此之外，Integer类还提供了4个常量。</p><ul><li><code>MAX_VALUE</code>：表示int类型可取的最大值，即2<sup>31</sup>-1。</li><li><code>MIN_VALUE</code>：表示int类型可取的最小值，即-2<sup>31</sup></li><li><code>SIZE</code>：用来以二进制补码形式表示int值的位数</li><li><code>TYPE</code>：表示基本类型int的Class实例</li></ul><table><thead><tr><th>Boolean方法</th><th>返回值</th><th>功能</th></tr></thead><tbody><tr><td>booleanValue()</td><td>boolean</td><td>将 Boolean 对象的值以对应的 boolean 值返回</td></tr><tr><td>equals(Object obj)</td><td>boolean</td><td>判断调用该方法的对象与 obj 是否相等。当且仅当参数不是 null，且与调用该 方法的对象一样都表示同一个 boolean 值的 Boolean 对象时，才返回 true</td></tr><tr><td>parseBoolean(String s)</td><td>boolean</td><td>将字符串参数解析为 boolean 值</td></tr><tr><td>toString()</td><td>string</td><td>返回表示该 boolean 值的 String 对象</td></tr><tr><td>valueOf(String s)</td><td>boolean</td><td>返回一个用指定的字符串表示的 boolean 值</td></tr></tbody></table><p><em><code>booleanValue()</code>和<code>valueOf(String s)</code>最大区别在于后者是静态方法，可以不用开辟新的内存空间</em></p><p>boolean的3个常量：</p><ul><li><code>TRUE</code>：表示对应基值true的Boolean对象。</li><li><code>FALSE</code>：表示对应基值false的Boolean对象</li><li><code>TYPE</code>：基本类型boolean的Class对象</li></ul><p>其他Character、Double、Number等等包装类的方法略，自行查询。</p><h2 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h2><h3 id="DecimalFormat类"><a href="#DecimalFormat类" class="headerlink" title="DecimalFormat类"></a>DecimalFormat类</h3><p>在Java中没有格式化的数据遵循以下原则：</p><ul><li>绝对值大雨0.001且小于10000000，使用常规小数形式表示。</li><li>其他使用科学记数法形式表示。</li></ul><p>DecimalFormat是NumberFormat的一个子类，用于格式化十进制数字。通过该类的<code>applyPattern()</code>方法来实现数字格式化。</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>代表阿拉伯数字，该位不存在则显示0</td></tr><tr><td>#</td><td>代表阿拉伯数字，该不存在则不显示</td></tr><tr><td>.</td><td>小数分隔符</td></tr><tr><td>-</td><td>负号</td></tr><tr><td>,</td><td>组分隔符</td></tr><tr><td>E</td><td>分隔科学记数法中的尾数和指数，E后面一般接0，不可接#</td></tr><tr><td>%</td><td>将数字转化为百分数</td></tr><tr><td>\u2030</td><td>转化为千分数</td></tr><tr><td>\u00A4</td><td>作为货币记号</td></tr><tr><td>‘</td><td>为特殊字符添加单引号，系统会将此符号视为普通符号处理</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecimalFormatDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个用于打印输出的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DecimalForamtMode</span><span class="params">(String pattern, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        DecimalFormat myFormat = <span class="keyword">new</span> DecimalFormat(pattern);</span><br><span class="line">        String output = myFormat.format(value);</span><br><span class="line">        System.out.println(value + <span class="string">&quot;,  &quot;</span> + pattern + <span class="string">&quot;,  &quot;</span> + output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;000,000&quot;</span>, <span class="number">12331</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;##,#####&quot;</span>, <span class="number">12331</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#,###$&quot;</span>, <span class="number">12331</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#.##E0&quot;</span>, <span class="number">123310000</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#.##%&quot;</span>, <span class="number">0.44</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#.##\u2030&quot;</span>, <span class="number">0.44</span>);</span><br><span class="line">        DecimalForamtMode(<span class="string">&quot;#.##\u00A4&quot;</span>, <span class="number">0.44</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">12331.0,  000,000,  012,331</span></span><br><span class="line"><span class="comment">12331.0,  ##,#####,  12331</span></span><br><span class="line"><span class="comment">12331.0,  #,###$,  12,331$</span></span><br><span class="line"><span class="comment">1.2331E8,  #.##E0,  1.23E8</span></span><br><span class="line"><span class="comment">0.44,  #.##%,  44%</span></span><br><span class="line"><span class="comment">0.44,  #.##‰,  440‰</span></span><br><span class="line"><span class="comment">0.44,  #.##¤,  0.44￥</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>该类中<code>setGroupSize(2)</code>可以设置数字分组大小，2表示两个数字为一组。</p><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>提供了众多数学常用函数方法，都被定义为了static形式。</p><p>例如<code>Math.sin(Math.PI/2)</code>求90度的正弦值，<code>Math.cos(0)</code>求0的余弦值。</p><p><code>Math.exp(6)</code>e的6次方,<code>Math.log(Math.E)</code>代表ln(e),<code>Math.pow(2,3)</code>2的3次方,sqrt平方根，sbrt立方根等.</p><p><strong>函数取整</strong>：<code>Math.ceil()</code>向上取整；<code>Math.floor()</code>向下取整；<code>Math.rint()</code>去最接近的整数，一样近取偶数；<code>Math.round(float a)</code>加上0.5返回最接近的整数数；<code>Math.round(double a)</code>加上0.5返回最接近的整数，并强制转化为长整型。</p><p>max、min、abs等略</p><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><ol><li><p><code>Math.random()</code>随机生成0~1之间的double型数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取1～10之间随机整数</span></span><br><span class="line">(<span class="keyword">int</span>)(Math.random()*<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>随机字符</strong>: <code>(char)(cha1 + Math.random()*(char2-char1+1));</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取随机a-z之间的字符</span></span><br><span class="line">(<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span>+Math.random()*(<span class="string">&#x27;z&#x27;</span>-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li><p>Random类</p><p><code>java.util.Random</code>。通过实例化一个Random对象创建一个随机数生成器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br></pre></td></tr></table></figure><p><code>nextInt()</code>, <code>nextFloat()</code>, <code>nextBoolean()</code>分别返回随机整数、浮点数和布尔值等</p><p><code>ints</code>方法返回随机整数，设置参数可以限制范围，取值数量等等。</p></li></ol><h3 id="大数字高精度运算"><a href="#大数字高精度运算" class="headerlink" title="大数字高精度运算"></a>大数字高精度运算</h3><p>java提供了BigInteger和BigDecimal分别针对大数字处理和大小数处理的类，精度很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数必须以字符串形式村子啊</span></span><br><span class="line">BigInteger demoInt = <span class="keyword">new</span> BigInteger(<span class="string">&quot;36&quot;</span>);</span><br><span class="line"><span class="comment">// 注意BigInteger对象的互相运算</span></span><br><span class="line">demoInt.add(<span class="keyword">new</span> BigInteger(<span class="string">&quot;8&quot;</span>));</span><br><span class="line">demoInt.multiply(<span class="keyword">new</span> BigInteger(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">demoInt.subtract(<span class="keyword">new</span> BigInteger(<span class="string">&quot;30&quot;</span>));</span><br><span class="line">demoInt.divide(<span class="keyword">new</span> BigInteger(<span class="string">&quot;3&quot;</span>));</span><br></pre></td></tr></table></figure><p><code>divideAndRemainder()</code>该除法方法返回数组，第一个为商，第二个为余数。</p><p>BigDecimal类的使用类似，但是构造参数除了string还可以是double：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal demoDec = <span class="keyword">new</span> BigDecimal(String val);</span><br><span class="line">BigDecimal demoDec = <span class="keyword">new</span> BigDecimal(<span class="keyword">double</span> val);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要做自我知识点的补充，不是全面系统的笔记&lt;/p&gt;
&lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Postman接口测试</title>
    <link href="http://123.57.158.5/2021/06/23/postman-test/"/>
    <id>http://123.57.158.5/2021/06/23/postman-test/</id>
    <published>2021-06-22T16:19:20.000Z</published>
    <updated>2021-07-04T17:37:11.447Z</updated>
    
    <content type="html"><![CDATA[<p>接口测试流程：</p><ol><li><p>获取接口信息</p><p>通过接口文档和抓包获取接口基本调用方式和返回</p></li><li><p>接口测试用例设计</p><p>根据获取到的接口信息，按照接口测试用例设计方法，设计参数和预期返回结果</p></li><li><p>接口发包</p><p>使用工具或者编程想接口传递参数</p></li><li><p>返回信息验证</p><p>获取接口返回的结果，进行解析和验证</p></li></ol><p>接口测试用例的设计：</p><p>以高德地图的一个get请求的ip查询请求地址为例，在postman中新建一个get请求，将抓包到的request url添加进去，可以测试接口的各项功能。例如改变参数后接口是否正常使用，例如各个参数是否必填。</p><p><img src="/2021/06/23/postman-test/image-20210624004047302.png" alt="image-20210624004047302"></p><p>当不勾选key参数后：</p><p><img src="/2021/06/23/postman-test/image-20210624004406045.png" alt="image-20210624004406045"></p><p>当填写错误的ip地址：</p><p><img src="/2021/06/23/postman-test/image-20210624004335989.png" alt="image-20210624004335989"></p><p>可以验证该get接口是否符合设计需求。</p><p>可以在ip地址参数中按照<strong>等价类</strong>及<strong>边界值</strong>法进行测试</p><p>在postman发送请求过程中，已经默默带上了请求头（request headers）信息，如果是在浏览器中也会带有。</p><p><img src="/2021/06/23/postman-test/image-20210624010413171.png" alt="image-20210624010413171"></p><h2 id="接口收发包过程"><a href="#接口收发包过程" class="headerlink" title="接口收发包过程"></a>接口收发包过程</h2><p>postman接口请求过程：</p><p>获取地址（URL）——设置http方法（GET POST等）——设置请求头域（request headers）——填写请求参数</p><p>postman接口响应验证：</p><p>http状态码——收到接口响应——检查返回头域（response headers）——查看返回主体内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接口测试流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取接口信息&lt;/p&gt;
&lt;p&gt;通过接口文档和抓包获取接口基本调用方式和返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接口测试用例设计&lt;/p&gt;
&lt;p&gt;根据获取到的接口信息，按照接口测试用例设计方法，设计参数和预期返回结果&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    
    <category term="Postman" scheme="http://123.57.158.5/tags/Postman/"/>
    
    <category term="接口测试" scheme="http://123.57.158.5/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java初学部分笔记(从语言基础到数组)</title>
    <link href="http://123.57.158.5/2021/06/09/java1/"/>
    <id>http://123.57.158.5/2021/06/09/java1/</id>
    <published>2021-06-09T14:53:06.000Z</published>
    <updated>2021-07-04T17:00:04.846Z</updated>
    
    <content type="html"><![CDATA[<p>每一个java程序必须包含一个<code>main()</code>方法，含有<code>main()</code>方法的类被称为主类。与python不同，需要有分号，单双引号有区分，同时文件名必须和类名同名。</p><p>Terminal运行java程序，先进行编译，后运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac xxx.java</span><br><span class="line">java xxx</span><br></pre></td></tr></table></figure><h2 id="java语言基础"><a href="#java语言基础" class="headerlink" title="java语言基础"></a>java语言基础</h2><h3 id="自增减运算符"><a href="#自增减运算符" class="headerlink" title="自增减运算符"></a>自增减运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++a(--a)<span class="comment">//表示在使用变量a之前，先使a的值加（减）1</span></span><br><span class="line">a++(a++)<span class="comment">//表示在使用变量a之后，使a的值加（减）1</span></span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>；</span><br><span class="line">b = ++a;<span class="comment">//将a增加1，此时a为2，将a赋值给b，b为2</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">b = a++;<span class="comment">//将a赋值给b，此时b为1，再将a增加1，a为2</span></span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><strong>按位与</strong>：运算符<code>&amp;</code>，如果两个整型数据a、b对应位置都是1，则结果位才是1，否则为0</p><p><strong>按位或</strong>：运算符<code>|</code>，如果两个操作数对应位都是0，则结果才是0，否则为1</p><p><strong>按位取反</strong>：运算符<code>~</code>，对操作数二进制中的数取反</p><p><strong>按位异或</strong>：运算符<code>^</code>，当两个操作数的对应位相同（都为1或0），则结果为0，否则为1</p><p><strong>移位操作</strong>：<code>&lt;&lt;</code>：左移，右边移动的位补0。<code>&gt;&gt;</code>：右移，左边移空填入最高位的数。<code>&gt;&gt;&gt;</code>：无符号右移，左边移空位填入0</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件？值1:值2</span><br></pre></td></tr></table></figure><p>若条件为true，取值1，否则取值2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1&lt;2如果如果为真，返回true，否则返回false，最后赋值给a</span></span><br><span class="line"><span class="keyword">boolean</span> a = <span class="number">1</span>&lt;<span class="number">2</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="for语句-foreach语句"><a href="#for语句-foreach语句" class="headerlink" title="for语句\foreach语句"></a>for语句\foreach语句</h3><p>for语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach语句是for语句的变体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量x: 遍历对象obj)&#123;</span><br><span class="line">  引用x的语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x: arr)&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;遍历arr输出&quot;</span>+x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p>break只会跳出所在位置的内层循环，如果需要通过break跳出外层循环，需要给外层循环指定名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Loop: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j = j + <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">break</span> Loop;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i + <span class="string">&quot;,&quot;</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continue跳过本次循环到下一次循环，continue生效了，后面的语句就不执行。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 等价于 String a = new String(&quot;hello&quot;);</span></span><br><span class="line"><span class="keyword">char</span> b = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">String c = <span class="keyword">new</span> String(b, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 3为截取3个字符。等价于 String c = &quot;cde&quot;;</span></span><br></pre></td></tr></table></figure><p>字符串查找方法中，<code>IndexOf()</code>/<code>LastIndexOf()</code>返回指定字符（串）（最后一次出现）的索引位置，值得注意的是<code>LastIndexOf()</code>中参数如果为<code>&quot;&quot;</code>，其结果等价于<code>length()</code>方法，返回字符串长度。</p><p><code>charAt()</code>返回指定位置字符串，<code>substring(int beginIndex, int endIndex)</code>截取字符串（结束字符串参数可省略）</p><p><code>trim()</code>返回字符串去除<strong>前后</strong>空格后的结果，<code>replace(&quot;old&quot;,&quot;new&quot;)</code>返回替换字符（串）后结果</p><p><code>startWith()</code>/<code>endsWith()</code>返回字符串是否以xx开头或结尾的布尔值。</p><p>java语言也有<code>equals()</code>方法比较字符串，不同于<code>==</code>比较内存地址。<code>equalsIngoreCase()</code>方法不区分大小写，返回布尔值</p><p><code>compareTo()</code>方法返回规则为，对比二者的第一个字符，如果不同返回字符的<strong>Unicode差值</strong>，结束；如果第一个字符相同，对比随后的字符，直到字符不同，返回差值结束。如果字符串完全相同（equal方法返回true），返回值为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">Sytem.out.println(a.compareTo(b));</span><br><span class="line"><span class="comment">// 返回的是o的Unicode值减去h的Unicode值,-7</span></span><br></pre></td></tr></table></figure><p><code>toLowerCase()</code>/<code>toUpperCase()</code>返回转换大小写之后的字符串。</p><p><code>split(String sign, int limit)</code>方法分割字符串，limit是最高分割次数（可选参数），如果有多个分隔符需要<code>|</code>分割。返回的是数组对象</p><p>注意：<code> | . &amp; * +</code> 是转义字符, 要加<code>\\</code>转义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String local_ip = <span class="string">&quot;192.168.0.1&quot;</span>;</span><br><span class="line">String[] ip_list = local_ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"><span class="comment">// 转换为列表显示</span></span><br><span class="line">System.out.println(Arrays.toString(ip_list));</span><br><span class="line"><span class="comment">// 逐个输出字符串数字</span></span><br><span class="line"><span class="keyword">for</span>(String num : ip_list)&#123;</span><br><span class="line">  System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>format()</code>方法实现对日期/时间的格式化转换，格式转换符可以自行搜索查询。</p><p>常见日期转换符：</p><table><thead><tr><th>转换符</th><th>说　　明</th><th>示　　例</th></tr></thead><tbody><tr><td>%tF</td><td>“年-月-日”格式（4位年份）</td><td>2021-03-20</td></tr><tr><td>%tD</td><td>“月/日/年”格式（2位年份）</td><td>03/20/21</td></tr><tr><td>%tr</td><td>“时：分：秒 PM（AM）”格式（12小时制）</td><td>03:22:06 下午</td></tr><tr><td>%tT</td><td>“时：分：秒”格式（24小时制）</td><td>15:23:50</td></tr><tr><td>%tR</td><td>“时：分”格式（24小时制）</td><td>15:23</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">String s = String.format(<span class="string">&quot;%tD&quot;</span>, date);</span><br></pre></td></tr></table></figure><p>常见类型转换符：</p><table><thead><tr><th align="center">转换符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">%s</td><td align="center">字符串类型</td></tr><tr><td align="center">%c</td><td align="center">字符类型</td></tr><tr><td align="center">%b</td><td align="center">布尔类型</td></tr><tr><td align="center">%d</td><td align="center">整数类型（十进制）</td></tr><tr><td align="center">%x</td><td align="center">整数类型（十六进制）</td></tr><tr><td align="center">%o</td><td align="center">整数类型（八进制）</td></tr><tr><td align="center">%f</td><td align="center">浮点类型</td></tr><tr><td align="center">%a</td><td align="center">十六进制浮点类型</td></tr><tr><td align="center">%e</td><td align="center">指数类型</td></tr><tr><td align="center">%g</td><td align="center">通用浮点类型（f和e类型中较短的）</td></tr><tr><td align="center">%h</td><td align="center">散列码</td></tr><tr><td align="center">%%</td><td align="center">百分比类型</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(<span class="string">&quot;%o&quot;</span>,<span class="number">100</span>));</span><br><span class="line"><span class="comment">//将100由十进制转化为8进制，输出144</span></span><br></pre></td></tr></table></figure><p>注意：不能将上面的方法用于字符串转化数字，字符串转化数字有<code>parseInt()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(<span class="string">&quot;100&quot;</span>,<span class="number">16</span>);</span><br><span class="line"><span class="comment">//将“100”转化为16进制</span></span><br></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><strong>正则表达式</strong>进行字符串匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String reg = <span class="string">&quot;^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;3&#125;)([0-9]|X)$&quot;</span>;</span><br><span class="line"><span class="comment">//匹配身份证号</span></span><br><span class="line">String str1 = <span class="string">&quot;36220119990101&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;362201199901015201&quot;</span>;</span><br><span class="line">System.out.println(str1.matches(reg));</span><br><span class="line">System.out.println(str3.matches(reg));</span><br></pre></td></tr></table></figure><h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><p>java对字符串进行“+”拼接等操作后，会创建新的字符串，占用内存；所以对于频繁的字符串修改操作时候，可以使用<strong>StringBuilder类</strong>，是一种可变字符序列，提高效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">  builder.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> time = endtime-starttime;</span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure><p>此外，该类还带有<code>append()/insert()/delete()</code>等方法。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 申明，再用new运算符进行内存分配</span></span><br><span class="line"><span class="keyword">int</span> arr[];</span><br><span class="line">String str[];</span><br><span class="line"><span class="comment">// 创建5个元素的整型数组</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 申明的同时为数组分配内存</span></span><br><span class="line"><span class="keyword">int</span> month[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br></pre></td></tr></table></figure><p>初始化一维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 常用</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>同理初始化二维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>使用二维数组<code>arr[0][0]</code>返回第一行第一列</p><p>使用foreach遍历二维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x[]:arr)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> num:x)&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Arrays.fill(int[] arr, int value)</code>方法将value值赋给arr数组中每个元素，也可以在两个参数中间增加指定范围的索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><code>Arrays.sort(object)</code>可对数组进行升序排序，结合了快速排序与归并排序的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将随机数放入数组后再排序</span></span><br><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  arr[i] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">  System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(<span class="string">&quot;====&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Arrays.copyOf(arr,int newlength)</code>方法拷贝数组，如果拷贝后长度大于被拷贝数组，则填充0，否则进行截取。<code>Arrays.copyOfRange(arr,int fromIndex,int toIndex)</code>截取长度复制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每一个java程序必须包含一个&lt;code&gt;main()&lt;/code&gt;方法，含有&lt;code&gt;main()&lt;/code&gt;方法的类被称为主类。与python不同，需要有分号，单双引号有区分，同时文件名必须和类名同名。&lt;/p&gt;
&lt;p&gt;Terminal运行java程序，先进行编译，后</summary>
      
    
    
    
    <category term="Java" scheme="http://123.57.158.5/categories/Java/"/>
    
    
    <category term="Java" scheme="http://123.57.158.5/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://123.57.158.5/2021/05/23/hello-world/"/>
    <id>http://123.57.158.5/2021/05/23/hello-world/</id>
    <published>2021-05-23T02:34:37.977Z</published>
    <updated>2021-05-23T02:34:37.977Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树的一些性质及遍历</title>
    <link href="http://123.57.158.5/2021/03/11/b-tree-traverse/"/>
    <id>http://123.57.158.5/2021/03/11/b-tree-traverse/</id>
    <published>2021-03-11T02:05:20.000Z</published>
    <updated>2021-05-23T02:34:34.370Z</updated>
    
    <content type="html"><![CDATA[<p>算法中已经提到过二叉树，这里重点讲二叉树的遍历。参考书籍《大话数据结构》</p><p>二叉树的一些性质，这些性质可以很简单得到证明：</p><ol><li>在二叉树第i层最多有2<sup>i-1</sup>个节点</li><li>深部为k的二叉树最多有2<sup>k</sup>-1节点</li><li>对于任何一个二叉树，如果其终端节点（叶子节点）数为n<sub>0</sub>，度为2的节点数为n<sub>2</sub>，n<sub>0</sub>=n<sub>2</sub>+1</li><li>具有n个节点的完全二叉树的深度为[log<sub>2</sub>n]+1（[x]表示不大于x的最大整数）。<em>可以理解为性质2的倒推</em></li><li>如果有一颗n个节点的完全二叉树的节点按照层序编号（从第一层到最后一层，每层从左往右），对任意一个节点（1&lt;=i&lt;=n）有：<ul><li>如果i=1，则节点i是完全二叉树的根，无双亲；如果i&gt;1，其双亲节点是[i/2]</li><li>如果2i&gt;n，则节点i无左孩子（节点i为叶子节点）；否则<font color="red">左孩子是2i</font></li><li>如果2i+1&gt;n，则节点i无右孩子；否则其<font color="red">右孩子是节点2i+1</font></li></ul></li></ol><p><strong>二叉树的遍历</strong>：是指从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。</p><div class="mermaid">graph TDA --&gt; BA --&gt; CB --&gt; DB --&gt; EC --&gt; FC --&gt; G</div><p>遍历可分为前序（ABC)  中序(BAC)  后序(BCA)</p><p><strong>前序遍历</strong>：依次访问根节点——左孩子——右孩子。上图的二叉树前序遍历后为ABDECFG</p><p><strong>中序遍历</strong>：依次访问左孩子——根节点——右孩子。DBEAFCG</p><p><strong>后序遍历</strong>：依次访问左孩子——右孩子——根节点。DEBFGCA</p><p>层序遍历：一层层从左至右。ABCDEFG</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;算法中已经提到过二叉树，这里重点讲二叉树的遍历。参考书籍《大话数据结构》&lt;/p&gt;
&lt;p&gt;二叉树的一些性质，这些性质可以很简单得到证明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在二叉树第i层最多有2&lt;sup&gt;i-1&lt;/sup&gt;个节点&lt;/li&gt;
&lt;li&gt;深部为k的二叉树最多有2&lt;sup&gt;k</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://123.57.158.5/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="http://123.57.158.5/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="算法" scheme="http://123.57.158.5/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本编辑器及软件安装</title>
    <link href="http://123.57.158.5/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://123.57.158.5/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</id>
    <published>2021-01-06T15:26:14.000Z</published>
    <updated>2021-05-23T02:34:39.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nano文本编辑器"><a href="#Nano文本编辑器" class="headerlink" title="Nano文本编辑器"></a>Nano文本编辑器</h2><blockquote><p>复制、剪贴和粘贴</p><p>复制一整行：Alt+6</p><p>剪贴一整行：Ctrl+K</p><p>粘贴：Ctrl+U</p><p>如果需要复制／剪贴多行或者一行中的一部分，先将光标移动到需要复制／剪贴的文本的开头，按Ctrl+6（或者Alt+A）做标记，然后移动光标到 待复制／剪贴的文本末尾。这时选定的文本会反白，用Alt+6来复制，Ctrl+K来剪贴。若在选择文本过程中要取消，只需要再按一次Ctrl+6。</p><p>搜索</p><p>按Ctrl+W，然后输入你要搜索的关键字，回车确定。这将会定位到第一个匹配的文本，接着可以用Alt+W来定位到下一个匹配的文本。</p><p>保存</p><p>使用Ctrl+O来保存所做的修改</p><p>退出</p><p>按Ctrl+X</p></blockquote><p><code>nano file</code>可以直接路径，没有该文件的话，就会创建一个再编辑</p><p><strong>配置nano编辑器</strong></p><p>单个用户配置：</p><p>一般通过<code>/home/username</code>路径下的.nanorc文件修改。<code>nano .nanorc</code></p><p>配置语言以set开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 相当于命令后面加 -m 参数 鼠标生效</span><br><span class="line">set mouse</span><br><span class="line"># 相当于 -i 参数 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line"># 激活职能home键 -A参数</span><br><span class="line">set smarthome</span><br></pre></td></tr></table></figure><p>全局配置：</p><p><code>/etc/nanorc</code>文件中修改（root用户）</p><p><code>sudo nano /etc/nanorc</code></p><p><strong>配置终端</strong></p><p>单个用户的终端配置文件<code>/home/username/.bashrc</code></p><p><code>nano ~/.bashrc</code></p><p>bash其实是一种shell，shell用于解释我们输入终端的各种命令的，是用户和操作系统之间的一个命令解释器。</p><p>配置.bashrc文件可以修改终端的各种配置，如命令提示符样式，创建命令别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建别名 alias xx=&#x27;command&#x27;</span><br><span class="line">alias ll=&#x27;ls -alF&#x27;</span><br><span class="line">alias la=&#x27;ls -A&#x27;</span><br><span class="line">alias l=&#x27;ls -CF&#x27;</span><br></pre></td></tr></table></figure><p>全局配置的路径：<code>/etc/bash.bashrc</code>，但是家目录下的<font color="red">优先级</font>高于系统的bash.bashrc文件</p><p><strong>profile配置文件</strong></p><p>单个用户：<code>~/.profile</code>，全局<code>/etc/profile</code></p><p>bashrc应用于图形化终端，profile应用于TTY1-TTY6这种需要用户登录的终端。profile文件会调用.bashrc</p><img src="/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/151709029500416466.jpg" alt="151709029500416466" style="zoom:33%;"> <p>bashrc 和 profile二者修改后都是下次登陆生效，需要立即生效使用source命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br><span class="line">source .profile</span><br></pre></td></tr></table></figure><h2 id="Ubuntu软件仓库"><a href="#Ubuntu软件仓库" class="headerlink" title="Ubuntu软件仓库"></a>Ubuntu软件仓库</h2><p>对于ubuntu系统，在全世界各地分布有软件仓库。Linux的.deb软件包相较于windows的exe安装包文件，包含了依赖关系的管理，对于依赖的软件会自动下载。</p><p><strong>管理软件仓库</strong></p><p>如果我们要切换软件仓库，可以通过编辑软件仓库列表文件<code>/etc/apt/sources.list</code>(root模式)</p><p>一般来说，这个文件中有作用的行是由以下两个指令开头：</p><ul><li>deb: 用于下载软件的二进制版本，大多数情况下我们用的是这个</li><li>deb-src: 用于下载软件的源代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例其中一行</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic universe</span><br></pre></td></tr></table></figure><p>第二个是仓库地址，第三个bionic是Ubuntu版本代号，第三个universe是软件仓库的区域，也就是要查看的代码仓库的不同分区。</p><p>Ubuntu图形界面中software&amp;update中可以直接切换软件仓库，更加方便</p><h3 id="终端包管理工具"><a href="#终端包管理工具" class="headerlink" title="终端包管理工具"></a>终端包管理工具</h3><p><code>apt-get</code>/<code>apt</code>管理包命令</p><p><code>aptitude</code>：这个命令再卸载软件时可以卸载不用的依赖</p><p><code>sudo apt update</code>更新软件包缓存；<code>sudo apt-cache search</code>搜索软件包；<code>sudo apt install</code>安装软件包；<code>sudo apt upgrade</code>升级所有已安装软件包；<code>sudo apt autoremove</code></p><p><code>dpkg</code>命令时apt-get和aptitude两个命令的后端（backend）命令</p><p>依赖链：<code>dpkg--&gt;apt-get,aptitude--&gt;Ubuntu Software</code></p><p>使用dpkg可以安装本地的软件包：<code>sudo dpkg -i *.deb</code>，卸载：<code>sudo dpkg -r 包名</code></p><h2 id="阅读手册"><a href="#阅读手册" class="headerlink" title="阅读手册"></a>阅读手册</h2><h3 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h3><p>例如<code>man ls</code>，会出现ls命令的使用说明。手册的各部分区域说明：</p><p><strong>NAME</strong></p><p>命令的全称</p><p><strong>SYNOPSIS</strong></p><p>概要，使用此命令的方法</p><p><code>ls [OPTION]... [FILE]...</code></p><img src="/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20210110233353458.png" alt="image-20210110233353458" style="zoom:50%;"><p>粗体：原封不动输入</p><p>下划线：用实际内容替代</p><p><code>[-hvc]</code>中括号内为可选参数</p><p><code>a|b</code>输入a或b选项</p><p>OPTION参数，省略号表示可输入多个参数</p><p><strong>DESCRIPTION</strong></p><p>列出所有参数和用法</p><p>其他区域：<strong>AUTHOR</strong>, <strong>REPROTIONG BUGS</strong>, <strong>COPYRIGHT</strong>, <strong>SEE ALSO</strong></p><h3 id="apropos查找命令"><a href="#apropos查找命令" class="headerlink" title="apropos查找命令"></a>apropos查找命令</h3><p>apropos命令后面添加关键字即可（根据手册中的关键字）</p><p>例如需要查找控制音量的方法 <code>apropos sound</code></p><img src="/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20210111005834669.png" alt="image-20210111005834669" style="zoom:67%;"><h3 id="其他查阅手册的方法"><a href="#其他查阅手册的方法" class="headerlink" title="其他查阅手册的方法"></a>其他查阅手册的方法</h3><p><strong>很多命令都支持<code>-h</code>参数</strong></p><p>比man命令的内容稍显简便</p><p><strong>whatis命令</strong></p><p>man的精简版，显示man的NAME区域</p><h3 id="文件查找命令"><a href="#文件查找命令" class="headerlink" title="文件查找命令"></a>文件查找命令</h3><h4 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h4><p><font color="red">查找速度极快，查找包含关键字的文件。</font></p><p><code>locate xxx</code>会查找并列出xxx（目录或文件名包含xxx）所在的所有目录</p><p>缺陷：如果是刚新建的文件locate是查不到的，因为locate不是查找硬盘，是在数据库（包含文件的列表和文件的位置）中查找记录。对于刚创建的文件，没有更新进数据库（一般24小时自动更新）</p><p>当然也可以用updatedb命令强制系统立即更新数据库 <code>sudo updatedb</code></p><h4 id="find命令深入查找"><a href="#find命令深入查找" class="headerlink" title="find命令深入查找"></a>find命令深入查找</h4><font color="red">遍历实际的硬盘的文件，还可以对查找的文件进行操作。查找文件要完全对应关键字，但是可以用正则匹配功能强大</font><p>find 默认当前子目录查找，也可以指定目录查找；用文件名、创建时间等查找；最后可以对找到的文件进行操作</p><p>例如：<code>find -name &#39;new_file&#39;</code>根据名字查找当前目录的文件 ; <code>find /var/log -name &#39;syslog&#39;</code>查找其他目录的文件； </p><p><strong>根据文件大小查找</strong></p><p><code>find /var -size +10M</code>查找/var目录下大于10m的文件</p><p><strong>根据文件的最近访问时间查找</strong></p><p><code>find -name &#39;*.txt&#39; -atime -7</code>查找7天内访问的txt文件</p><p><strong>仅查找目录或文件</strong></p><p><code>find -name &#39;file1&#39; -type d</code>查找名为file1的目录</p><p><strong>操作查找结果</strong></p><p>格式化输出：<code>find -name &#39;file1&#39; -printf &#39;%p - %u\n&#39;</code>将查找到的文件格式化输出为<code>文件名 - 用户名</code>的形式</p><p>删除操作：<code>xxx -delete</code></p><p>调用其他命令：</p><p>加上<code>-exec</code>参数之后就可以接其他命令了，十分强大</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/var目录下的所有txt文件修改权限为600</span></span><br><span class="line">find /var -name <span class="string">&#x27;*.txt&#x27;</span> -<span class="built_in">exec</span> chmod 600 &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>大括号表示刚查找到的文件，<code>\;</code>是exec的结尾</p><p>将<code>-exec</code>参数换成<code>-ok</code>参数效果一样，但是会对每个文件都做确认提示！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nano文本编辑器&quot;&gt;&lt;a href=&quot;#Nano文本编辑器&quot; class=&quot;headerlink&quot; title=&quot;Nano文本编辑器&quot;&gt;&lt;/a&gt;Nano文本编辑器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;复制、剪贴和粘贴&lt;/p&gt;
&lt;p&gt;复制一整行：Alt+6&lt;/</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://123.57.158.5/tags/Linux/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Terminal" scheme="http://123.57.158.5/tags/Terminal/"/>
    
    <category term="Ubuntu" scheme="http://123.57.158.5/tags/Ubuntu/"/>
    
    <category term="Nano" scheme="http://123.57.158.5/tags/Nano/"/>
    
    <category term="RTFM" scheme="http://123.57.158.5/tags/RTFM/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络5之实践网络分析异步任务（更新中</title>
    <link href="http://123.57.158.5/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5/"/>
    <id>http://123.57.158.5/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5/</id>
    <published>2020-12-30T16:43:42.000Z</published>
    <updated>2021-05-23T02:34:44.457Z</updated>
    
    <content type="html"><![CDATA[<p>内容安排</p><div class="mermaid">graph LR;a[搭建服务基本框架]--&gt;b[Python操作字节序列]b--&gt;c[实现IP报文解析器]c--&gt;d[实现UDP报文解析器]d--&gt;e[实现TCP报文解析器]</div><p><img src="/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5/image-20210102231245869.png" alt="image-20210102231245869"></p><h2 id="搭建服务基本框架"><a href="#搭建服务基本框架" class="headerlink" title="搭建服务基本框架"></a>搭建服务基本框架</h2><p>网卡工作的两种模式：</p><table><thead><tr><th>混杂模式</th><th>非混杂模式</th></tr></thead><tbody><tr><td>接受所有经过网卡设备的数据</td><td>只接受目的地址指向自己的数据</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内容安排&lt;/p&gt;
&lt;div class=&quot;mermaid&quot;&gt;graph LR;
	a[搭建服务基本框架]--&amp;gt;b[Python操作字节序列]
	b--&amp;gt;c[实现IP报文解析器]
	c--&amp;gt;d[实现UDP报文解析器]
	d--&amp;gt;e[实现TCP报文解析器</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="实战" scheme="http://123.57.158.5/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="计算机网络" scheme="http://123.57.158.5/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络4应用层</title>
    <link href="http://123.57.158.5/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://123.57.158.5/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-12-29T07:02:01.000Z</published>
    <updated>2021-05-23T02:34:44.271Z</updated>
    
    <content type="html"><![CDATA[<p>应用层位于TCP/IP四层模型的最上面，对应七层模型的应用层、表示层会话层。</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201229150405939.png" alt="image-20201229150405939"></p><h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><p>传输层给及以下的层提供了完整的通信服务，应用层主要是面向用户的一层。</p><p>应用层的一些协议：</p><table><thead><tr><th>FTP</th><th>HTTP</th><th>HTTPS</th><th>DNS</th><th>TELNET</th></tr></thead><tbody><tr><td>21</td><td>80</td><td>443</td><td>53</td><td>23</td></tr></tbody></table><p>应用层内容包括以后的应用层软件和面向传输层的编程</p><p>传输层TCP\UDP协议的使用场景：</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201229151054596.png" alt="image-20201229151054596"></p><p>应用层主要功能是定义应用间通信的规则，比如应用进程的报文类型（请求报文、应答报文）；报文的语法和格式；应用进程发送数据的时机、规则</p><h2 id="DNS详解"><a href="#DNS详解" class="headerlink" title="DNS详解"></a>DNS详解</h2><p>DNS(Domain Name System: 域名系统)</p><p>首先我们是通过<code>ip地址:端口</code>来指定某个网络服务（web服务、网络存储、远程调用等等），而DNS就是方便记录各项网络服务地址的。</p><p>使用域名帮助记忆。将域名解析为IP地址。</p><ul><li>域名由点、字母和数字组成</li><li>点分割不同的域</li><li>域名可以分为顶级域、二级域、三级域</li></ul><p>例如<code>www.rice-and-bran.site</code>，site就是顶级域，rice-and-bran是二级域，www是三级域。</p><div class="mermaid">graph LR;    A{顶级域}--&gt;B{国家}    A--&gt;C{通用}    B--&gt;D[cn]    B--&gt;E[us]    C--&gt;F[com]    C--&gt;G[net]    C--&gt;H[gov]</div><p>当访问一个域名的时候，首先会访问本地域名服务器，若没有则访问根域名服务器，再访问顶级域名服务器，一步步向下。</p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>DHCP(Dynamic Host Configuration Protocol: 动态主机设置协议)，是一个局域网协议，应用UDP协议的应用层协议。</p><p>比如电脑中的TCP/IP协议设置中，默认选择自动获取IP地址，就是通过DHCP协议自动获得局域网分配的ip，（非永久，有租期的一个概念）</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201230233537304.png" alt="image-20201230233537304"></p><p>当设备要接入局域网，DHCP协议工作过程：</p><ul><li>DHCP服务器监听默认端口：67</li><li>主机使用UDP协议广播DHCP发现报文</li><li>DHCP服务器发出DHCP提供报文</li><li>主机向DHCP服务器发出DHCP请求报文</li><li>DHCP服务器回应并提供IP地址</li></ul><p>之后如果设备还要与外网通信，则需要通过NAT技术转换公网IP进行通信</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP(HyperText Transfer Protocol: 超文本传输协议)，是可靠的数据传输协议</p><p><code>http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></p><p>http一般使用80端口，https一般使用443端口</p><p>web服务器应答过程: </p><div class="mermaid">graph LR;a[接收客户端连接]--&gt;b[接收请求报文]b--&gt;c[处理请求]c--&gt;d[访问web资源]d--&gt;e[构造应答]e--&gt;f[发送应答]</div><table><thead><tr><th>HTTP请求方法</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>获取指定的服务端资源/提交数据</td></tr><tr><td>POST</td><td>提交数据到服务端</td></tr><tr><td>DELETE</td><td>删除指定的服务端资源</td></tr><tr><td>UPDATE</td><td>更新指定的服务端资源</td></tr><tr><td>PUT</td><td></td></tr><tr><td>OPTIONS</td><td></td></tr><tr><td>PATCH</td><td></td></tr><tr><td>HEAD</td><td></td></tr><tr><td>TRACE</td><td></td></tr></tbody></table><ol><li>在地址中指定资源：</li></ol><p><code>xxx/111.html</code>, <code>xxx/?a=1&amp;b=1</code></p><ol start="2"><li>在请求中指定资源：</li></ol><p>请求报文和应答报文的组成：</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201230235508131.png" alt="image-20201230235508131"></p><p>例如通过POST请求来指定资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST https://www.rice-and-bran.com HTTP/1.1</span><br><span class="line"></span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;sort&quot;:0,</span><br><span class="line">&quot;unlearn&quot;:0,</span><br><span class="line">&quot;page&quot;:2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到请求后，web服务器返回应答报文，包含状态码，具体有这些类型：</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>200~299</td><td>成功状态码</td></tr><tr><td>300~399</td><td>重定向状态码</td></tr><tr><td>400~499</td><td>客户端错误状态码</td></tr><tr><td>500~599</td><td>服务端错误状态码</td></tr></tbody></table><h2 id="HTTP工作的结构"><a href="#HTTP工作的结构" class="headerlink" title="HTTP工作的结构"></a>HTTP工作的结构</h2><h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h3><p>优先把热门数据缓存起来</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231000807836.png" alt="image-20201231000807836"></p><h3 id="web代理"><a href="#web代理" class="headerlink" title="web代理"></a>web代理</h3><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231001012582.png" alt="image-20201231001012582"></p><p>作用：1.屏蔽server部署的结构，不给用户直接看到；2.保证server的安全，比如在proxy中设置防火墙</p><p><strong>正向代理</strong>：代表client去访问server；<strong>反向代理</strong>：代表server把数据返回给客户端</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN(Content Delivery Network: 内容分发网络)，为了进行多媒体内容的加速</p><p>在距离用户近的地方部署cdn服务器备份多媒体内容，使用户更快的收到内容，改善用户获取多媒体内容的体验。</p><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p>例如搜索引擎的爬虫，爬取信息，建立索引。但是不好的爬虫会增加网络拥塞，损耗服务器资源</p><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTP是明文传输的，但是对于一些敏感信息传输。https协议会对传输内容进行加密，https为443端口</p><h3 id="加密模型"><a href="#加密模型" class="headerlink" title="加密模型"></a>加密模型</h3><p>对称加密：加密解密密钥统一；非对称加密则不一致</p><p>假设加密密钥为A，解密密钥为B；AB是拥有一定数学关系的一组密钥。</p><p>通过<strong>公钥</strong>（公开）进行加密，<strong>私钥</strong>（非公开，用户使用）进行解密</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书是可信任组织颁发给特定对象的认证</p><p>数字证书的内容：证书格式、版本号；证书序列号；有效期；对象名称；<font color="red">对象公开密钥</font>…</p><p><strong>SSL</strong>(Secure Sockets Layer: 安全套接层)，是介入传输层和应用层之间，保证数据安全和数据完整，对传输层数据进行加密后传输</p><p>https协议加密过程：</p><p><em>E：encode，D：decode</em></p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231003216484.png" alt="image-20201231003216484"></p><p>SSL安全参数握手过程: </p><p>1，2：</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231003549226.png" alt="image-20201231003549226"></p><p>3：客户端收到服务端的加密算法、数字证书以及随机数后。需要</p><ul><li>确认证书是否有效</li><li>生成随机数3</li><li>使用服务器公钥加密随机数3</li></ul><p>4：发送加密后的数据给服务器</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231003818999.png" alt="image-20201231003818999"></p><p>然后服务器解密随机数3，两边都拥有了三个随机数</p><p>5：两边根据随机数1,2,3和相同的算法生成<font color="red">对称密钥</font>，双方使用对称密钥进行加密通信</p><p>ssl参数握手过程的特点：</p><ul><li>综合使用对称加密和非对称加密</li><li>双方分别生成秘钥，没有经过传输过程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;应用层位于TCP/IP四层模型的最上面，对应七层模型的应用层、表示层会话层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://123.57.158.5/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>红会急救培训笔记</title>
    <link href="http://123.57.158.5/2020/12/28/First-Aid-Elementary-Course/"/>
    <id>http://123.57.158.5/2020/12/28/First-Aid-Elementary-Course/</id>
    <published>2020-12-28T14:52:35.000Z</published>
    <updated>2021-05-23T02:34:37.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>半个月前我报名了北京红会的16学时急救课程，27，28号两天是培训时间，地点是在门头沟区的心田培训中心。主要学习内容是CPR（心肺复苏）、AED的使用、常见疾病处置、创伤处理等。对我来说是一次很有收获的体验，开这篇文章记录一下参加课程的笔记、心得。</p><img src="/2020/12/28/First-Aid-Elementary-Course/11c0950fb47eebdb.jpeg" alt="11c0950fb47eebdb" style="zoom:67%;"><p><strong>红十字会起源</strong>：亨利杜南目睹索尔费里诺战役后，成立伤兵救护委员会，后演变为日内瓦公约</p><h2 id="day1-徒手心肺复苏"><a href="#day1-徒手心肺复苏" class="headerlink" title="day1 徒手心肺复苏"></a>day1 徒手心肺复苏</h2><p>抢救生命的绿色通道“生存链”</p><div class="mermaid">graph LR;A[应急反应系统识别和启动]--&gt;B[高质量心肺复苏]B--&gt;C[快速除颤]C--&gt;D[基础及高级急救医疗服务]D--&gt;E[高级生命维护和骤停后护理]</div><p>救护员课程重点学习心肺复苏和除颤</p><p><strong>猝死</strong>：平素身体健康或貌似健康的患者，在出乎意料的短时间内，因自然疾病而突然死亡即为猝死。对于死亡时间，世卫组织定义从发病到死亡6小时内，一般认为1小时内死亡者多为心源性猝死。</p><p><strong>心肺复苏</strong>：指救护员在现场为心脏骤停患者实施胸外按压和人工呼吸。</p><p>我国每年有约54万人死于心脏猝死，如果经过有效的心肺复苏，部分患者可存活。</p><p>黄金四分钟：</p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229005456937.png" alt="image-20201229005456937"></p><p>判断+救治步骤：</p><ol><li><p>环境安全，做好防护。</p></li><li><p>轻拍患者双肩，呼喊（“先生先生，您怎么了？”），确认有无意识。解开衣服，仔细观察呼吸（1001-1007），确认有无呼吸（或仅仅是喘息）</p></li><li><p>无呼吸无意识，大声呼叫，让人帮忙拨打120，取AED。表明救护员身份并寻求援助。</p></li><li><p>立即进入<strong>心肺复苏</strong>程序，C-A-B。（如果是溺水则是A-B-C，要先保持气道畅通）</p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229005703564.png" alt="image-20201229005703564"></p><blockquote><p>心肺复苏CAB分别代表:1.C: circulation循环，即要求胸外按压，保证心脏射血，体内血液循环。2.A: airway气道，即要求保持气道通畅，要注意清理口腔呕吐物，采取仰颌抬颏法使呼吸顺畅。3.B: breathing呼吸，即口对口人工呼吸，每一次吹气要看到胸廓有起伏，但也不要用力过猛。保证氧气输送到肺组织。</p></blockquote><p>心肺复苏注意事项：</p><ul><li><p>按压位置位于两乳头连线中点的胸骨处，双手十指相扣，掌根对着胸骨，手臂不弯曲，使用上半身力量，髋关节为轴。</p></li><li><p>按压深度约5-6cm（一般胸骨到背部厚度三分之一）</p></li><li><p>每分钟100~120次</p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229005818116.png" alt="image-20201229005818116"></p></li><li><p>按压时时刻注意患者头部，有反应则停止并判断情况。</p></li><li><p>医生没到/病人没醒按压不能停！！！！ （人工呼吸、使用AED除外）</p></li><li><p>人工呼吸前检查气道，口腔无异物，仰额抬颏法。嘴包嘴吹气，持续1秒</p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229005855463.png" alt="image-20201229005855463"></p></li><li><p>吹压比/吹气比：<strong>30：2</strong>（30次按压，两次人工呼吸）。<font color="red">持续五个周期的30：2的心肺复苏</font>，再检查患者反应和呼吸（脖子动脉）</p></li></ul></li><li><p>AED抵达后，立即开机，将电极贴对应身体裸露位置，右边锁骨下面，一处左边乳房下面。前胸后背也可以。</p></li><li><p>按照AED提示除颤，随后根据自己节奏30：2心肺复苏。</p></li><li><p>呼吸心跳恢复后，调整侧卧位</p></li></ol><p><img src="/2020/12/28/First-Aid-Elementary-Course/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5" alt="img"></p><p>心肺复苏成功的标志：恢复自主心跳自主呼吸及意识</p><p>可参考表现：眼球活动、睫毛放射、四肢活动；瞳孔扩大逐渐缩回变小；有知觉、反应、脸色转红等</p><blockquote><p>自动体外除颤器又称自动体外电击器、自动电击器、自动除颤器、心脏除颤器及傻瓜电击器等，是一种便携式的医疗设备，它可以诊断特定的心率失常，并且给予电击<a href="https://baike.baidu.com/item/%E9%99%A4%E9%A2%A4/3310526">除颤</a>，是可被非专业人员使用的用于抢救心脏骤停患者的医疗设备。在心跳骤停时，只有在最佳抢救时间的“黄金4分钟”内，利用自动体外除颤器（AED）对患者进行除颤和心肺复苏，才是最有效制止猝死的办法。</p></blockquote><p><strong>异物阻塞处置</strong>：</p><p>腹部冲击法（海姆立克法）冲击患者腹部，使横膈肌急速提升，呼吸道压力骤升，异物排出。（极端场景才使用，因为可能造成脏器损伤，一般拍拍背就行）</p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229010943066.png" alt="image-20201229010943066" style="zoom:50%;"><p>问题及其他病情处置：</p><ol><li>隔着薄衣服可以做心肺复苏吗？可以，但要保证按压高质量。</li><li>有呼吸无意识怎么处置？恢复安全体位即可</li><li>癫痫发作怎么处置？腾出空间，让其自我恢复，不做处理</li><li>患者倒地后判断呼吸要通过身体起伏而不是脉搏？1）脉搏非专业人士判断不准 2）判断呼吸没有，心跳一定是停止的，因为心跳停止后呼吸才停。</li></ol><h2 id="day2-创伤现场救治"><a href="#day2-创伤现场救治" class="headerlink" title="day2 创伤现场救治"></a>day2 创伤现场救治</h2><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229014414580.png" alt="image-20201229014414580"></p><p>流血包扎原则：</p><ul><li><p>包扎前上敷料，从远心端–&gt;近心端（毒蛇咬伤则相反）包扎。手臂包扎使用螺旋包扎法，手背手心使用八字包扎法，关节包扎使用人字形包。胸部、腹部用三角巾包扎。</p><p><em>图为胸部包扎处理</em></p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229014508145.png" alt="image-20201229014508145"></p></li><li><p>包扎结束再外侧（大拇指那边一侧）</p></li><li><p>包扎时候绷带朝上拿</p></li><li><p>包扎完检查末端血液循环（比如按压指尖）</p></li><li><p>使用三角巾悬挂</p></li></ul><p>骨折处理：</p><ul><li>伤侧房足够的软垫、如果是开放骨折不能清理，只制动不复位</li><li>使用三角巾悬挂</li><li>加制动带</li></ul><p>三角巾悬挂原则：</p><p>如果是上臂、前臂受伤使用大悬臂带，如果是肢末端（手，锁骨）使用三角叫悬臂带</p><p><em>图为大悬臂带</em></p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229014614803.png" alt="image-20201229014614803"></p><p>具体其他的包扎 悬挂方法建议看视频复习巩固。细节不好文字描述。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这两天真的有点高强度，尤其基地位于门头沟，往返三小时多，回宿舍就累趴了。（ps：第一次做门头沟S1线，培训小伙伴告知我是磁悬浮的，怪不得很舒适平稳。沿途景色不错）</p><p>笔记到这里就结束了，这次课程收获满满，确实学到了很多急救的干货，最重要的是当家人朋友出现紧急状况就知道该怎么做了。如果路遇紧急情况我应该也能尽一份力。</p><p>感谢红会的老师们，真的很耐心很温暖很细心！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;半个月前我报名了北京红会的16学时急救课程，27，28号两天是培训时间，地点是在门头沟区的心田培训中心。主要学习内容是CPR（心肺复苏）、A</summary>
      
    
    
    
    <category term="生活" scheme="http://123.57.158.5/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="CPR" scheme="http://123.57.158.5/tags/CPR/"/>
    
    <category term="AED" scheme="http://123.57.158.5/tags/AED/"/>
    
  </entry>
  
  <entry>
    <title>Linux1基本命令(Ubuntu)</title>
    <link href="http://123.57.158.5/2020/12/16/linux-go1/"/>
    <id>http://123.57.158.5/2020/12/16/linux-go1/</id>
    <published>2020-12-16T11:27:07.000Z</published>
    <updated>2021-06-29T16:19:43.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端的基本操作"><a href="#终端的基本操作" class="headerlink" title="终端的基本操作"></a>终端的基本操作</h2><p>什么是TTY?</p><blockquote><p>在Linux中，TTY也许是跟终端有关系的最为混乱的术语。TTY是TeleTYpe的一个老缩写。Teletypes，或者teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，和古老的电报机区别并不是很大。之后，当计算机只能以批处理方式运行时（当时穿孔卡片阅读器是唯一一种使程序载入运行的方式），电传打字机成为唯一能够被使用的“实时”输入/输出设备。最终，电传打字机被键盘和显示器终端所取代。</p><p>在Linux 系统中，计算机显示器通常被称为控制台终端(Console）。它仿真了类型为Linux的一种终端(TERM=Linux），并且有一些设备特殊文件与之相关联：tty0、tty1、tty2 等。当你在控制台上登录时，使用的是tty1。使用Alt+[F1—F6]组合键时，我们就可以切换到tty2、tty3等上面去。tty1–tty6等称为虚拟终端，而tty0则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上（这时也叫控制台终端）。因此不管当前正在使用哪个虚拟终端，系统信息都会发送到控制台终端上。/dev/console即控制台，是与操作系统交互的设备，系统将一些信息直接输出到控制台上。只有在单用户模式下，才允许用户登录控制台。</p></blockquote><p><code>ctrl+alt+f1</code>：回到图形界面</p><p><code>ctrl+alt+f2</code>：对应终端2(tty2)，f3-f6分别对应tty3-tty6</p><p>但是我们一般常用图形模式的终端。调用方式<code>Ctrl+Alt+T</code></p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>打开终端后会自动出现命令行提示符</p><p>比如<code>scheelite@scheelte-VirtualBox:~$</code></p><p><code>scheelite</code>是当前用户的名字，Linux是多用户的操作系统，@后面是主机名，：是分隔符，~是当前所在目录的名字，$指示用户拥有的权限，表示普通用户，如果是#怎是root用户</p><p>使用<code>sudo su</code>切换root用户，切换后显示<code>root@scheelte-VirtualBox:/home/scheelite#</code></p><p>使用<code>whoami</code>命令可以获知当前用户名，<code>hostname</code>获知主机名</p><h3 id="基本命令使用"><a href="#基本命令使用" class="headerlink" title="基本命令使用"></a>基本命令使用</h3><p><code>date</code>显示当前时间，<code>ls</code>显示当前所有的目录</p><p>参数是写在命令之后的一些补充选项，空格隔开。</p><p><strong>短参数</strong>：短横线后面加一个字母，可以一次性加多个短参数，也可以合并写。参数的值 <code>-p 10</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">command -p -a -T -c</span><br><span class="line">command -paTC</span><br><span class="line"></span><br><span class="line">显示所有文件（包括隐藏文件）</span><br><span class="line">ls -a</span><br></pre></td></tr></table></figure><p><strong>长参数</strong>：以两个短横线开始，只能以空格隔开。参数的值<code>--parameter=10</code></p><p>可以长短参数结合使用</p><p><strong>其他参数</strong>：没有绝对的准则。例如ls命令 后面带了一个参数的话，这是一个目录的路径名的话，那么就会列出此目录下的文件，例如 <code>ls Code</code></p><p>Tab键可以补全命令/路径，敲两下tab键。</p><h3 id="命令行快捷键"><a href="#命令行快捷键" class="headerlink" title="命令行快捷键"></a>命令行快捷键</h3><p>上下键切换历史命令</p><p><code>ctrl+r</code>查找使用过的命令；</p><p><code>history</code>显示所有输入的命令；</p><p><code>ctrl+l</code>清屏；</p><p><code>ctrl+d</code>给终端传递EOF（文件结束符）；</p><p><code>shift+PgUp</code>用于向上滚屏</p><p><code>ctrl+a</code>/<code>home </code>     <code>ctrl+e</code>/<code>end</code>光标跳到一行命令的开始/结尾</p><p><code>ctrl+u</code>/<code>ctrl+k</code>删除光标左侧/右侧的命令</p><p><code>ctrl+w</code>删除光标左侧的一个“单词”（空格隔开的一部分）</p><p><code>ctrl+y</code>用于粘贴上面u/k/w删除的字符串</p><h2 id="Linux下的文件操作"><a href="#Linux下的文件操作" class="headerlink" title="Linux下的文件操作"></a>Linux下的文件操作</h2><h3 id="Linux下文件目录组织形式"><a href="#Linux下文件目录组织形式" class="headerlink" title="Linux下文件目录组织形式"></a>Linux下文件目录组织形式</h3><ul><li>在Linux中<font color="red">一切都是文件</font>，不像windows分为文件和非文件，甚至连目录也是文件</li><li>Linux中只有一个根目录就是<code>/</code>，最顶级的目录，不同于windows很多个盘：<code>C:\</code>等</li><li>windows中用反斜杠表明目录层级和包含关系，而Linux中用<code>/</code>来表示，例如：<code>/usr/bin</code></li><li>一般在Linux命令目录时尽量不使用空格或其他特殊符号，尽量用小写字母</li><li>linux中以点开头的文件是隐藏文件。但是<code>.</code>（一个点）表示当前目录，<code>..</code>（两个点）表示上一级目录</li></ul><p>/bin：包含用户可执行的二进制文件；/boot: 包含linux启动密切相关的文件；/etc：系统配置文件；/home: 用户私人目录；/lib：包含被程序调用的库文件，<code>.os</code>结尾，类似于win的dll；/media: 访问外设（usb等）内容；/mnt：临时挂载一些装置；/opt：用于安装第三方软件；/root：超级用户目录；/sbin系统级重要可执行文件；/usr：安装大部分用户需要调用的程序 ….；/var：程序日志文件</p><p><code>pwd</code>命令 获知当前目录</p><p><code>which</code>命令获取命令的可执行文件的位置，参数为命令，如<code>which pwd</code>获取pwd命令可执行文件的位置。</p><h3 id="ls、cd、du命令"><a href="#ls、cd、du命令" class="headerlink" title="ls、cd、du命令"></a>ls、cd、du命令</h3><p>不带参数列出非隐藏文件，-a参数列出所有文件，-A列出不带<code>.</code>和<code>..</code>的目录，</p><p>-l参数列出文件详细信息, <code>total xx</code> 表示当前目录的总字节数（k）</p><p><img src="/2020/12/16/linux-go1/image-20201231122820898.png" alt="image-20201231122820898"></p><p>里面每一行的内容分别代表：文件权限、链接数目、文件所有者、文件所在的群组、文件大小（仅指目录文件的大小）、文件修改时间、名称</p><p>可以很多参数合并一起使用如<code>ls -ltah</code>显示所有文件详情</p><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p>change directory 切换路径</p><p><code>cd ~</code>或直接<code>cd</code>会到直接回到家目录</p><h4 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h4><p>disk usage, du可以让我们直到文件和目录所占的空间大小；相比<code>ls -l</code>命令，du命令统计的才是真正的文件大小</p><p><code>-h</code>便于阅读模式，<code>-a</code>显示所有目录、文件的大小，<code>-s</code>直接出现总大小</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>syslog文件位于<code>/var/log</code>这个目录中，记录了电脑的所有事情的日志。</p><h4 id="cat和less命令"><a href="#cat和less命令" class="headerlink" title="cat和less命令"></a>cat和less命令</h4><p>cat命令和less命令：显示文件内容，不能对内容进行修改。</p><p>cat一次性在终端显示文件所有内容，加上想要显示的文件路径即可：<code>cat syslog</code>，中间加上<code>-n</code>参数显示行号。适合显示小文件</p><p>less命令分页显示文件内容。空格键翻页显示，<code>↓</code>/<code>enter</code>显示下一行，<code>d</code>前进半个屏幕，<code>b</code>向上一页，<code>y</code>/<code>↑</code>显示到上一行，<code>=</code>等号显示你在当前文件中的位置，h键进入使用手册，<code>/</code>进入搜索模式（按n键在结果中跳转，shift+n往上跳转），</p><h4 id="head和tail命令"><a href="#head和tail命令" class="headerlink" title="head和tail命令"></a>head和tail命令</h4><p>显示文件开头和结尾几行。</p><p>可以加上参数<code>tail -n 5 syslog</code>显示末尾五行，</p><p>配合<code>-f</code>参数可实时追踪文件的更新。</p><p><code>tail -f syslog</code>实时观察syslog文件的增加内容，默认一秒检查是否有更新，也可指定间隔参数，比如<code>tail -f -s 4 syslog</code>设置为4秒</p><h4 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h4><p>touch命令直接更跟路径，创建空白文件</p><p>mkdir创建新文件夹，可以用<code>-p</code>来递归创建目录结构：<code>mkdir -p one/two/three</code></p><h4 id="拷贝、移动文件或目录"><a href="#拷贝、移动文件或目录" class="headerlink" title="拷贝、移动文件或目录"></a>拷贝、移动文件或目录</h4><p>cp命令拷贝，<code>cp file file_copy</code>拷贝file_copy文件，可以换为目录名就可以复制到那里去并改名</p><p>拷贝目录需要在cp命令之后加上<code>-r</code>或者<code>-R</code>参数，目录中所有内容被拷贝</p><p><strong>使用通配符*</strong></p><p>用于代替任何字符，和正则一样。<code>cp *.txt folder</code>把当前目录下的所有txt文件拷贝到folder目录中取</p><p>mv命令移动，使用类似cp，但是移动目录不需要添加额外的参数，和移动文件一样，同样也可以使用通配符。</p><p>mv命令还可以重命名，使用方法一样。</p><h4 id="删除文件和目录"><a href="#删除文件和目录" class="headerlink" title="删除文件和目录"></a>删除文件和目录</h4><p>rm命令用于删除文件和目录，但是不可撤销。直接加文件名</p><p>加上<code>-i</code>参数会询问是否需要删除，<code>-r</code>参数递归（recursive）删除，删除目录</p><h3 id="文件中的软链接和硬链接"><a href="#文件中的软链接和硬链接" class="headerlink" title="文件中的软链接和硬链接"></a>文件中的软链接和硬链接</h3><p>ln命令用于在文件之间创建链接。</p><p>Linux下有两种链接类型：软链接（Symbolic link）和硬链接（Physical link）。Linux文件有三部分：文件名、权限和文件内容。</p><p><strong>Linux文件存储</strong>：每个文件的文件内容被分配到一个inode，因此每个文件名都绑定到它的文件内容（用inode标识）</p><p><strong>硬链接原理</strong>：使链接的两个文件共享同样的文件内容，就是同样的inode。如果两个文件之间有了硬链接，修改文件修改的是同一块内容。硬链接一般只能创建指向文件的硬链接，而<strong>软连接</strong>可以指向文件和目录。</p><p><code>ln file1 file2</code>这个命令创建了一个file1的硬链接file2。</p><p><em>此时如果通过<code>ls -i</code>来查看文件相关的inode信息，会发现二者指向了同一个inode</em></p><p>对于硬链接来说，删除任意一方文件，共同指向的文件内容并不会从硬盘上被删除，只有同时删除，该inode才会被删除。</p><p><img src="/2020/12/16/linux-go1/image-20210102142105447.png" alt="image-20210102142105447"></p><p>第一列是inode信息，第三列中数字为2，对于文件来说指的是有相同inode号的文件数。（对于目录，指的是目录下的文件数）</p><p><strong>软链接</strong>类似与windows下的快捷方式。创建软链接需要带上<code>-s</code>参数</p><p><em>图示创建了file3软链接，链接到file1</em></p><p><img src="/2020/12/16/linux-go1/image-20210102142711614.png" alt="image-20210102142711614"></p><p>如果删掉了file1，file2就会失效。</p><h2 id="Linux下的权限管理"><a href="#Linux下的权限管理" class="headerlink" title="Linux下的权限管理"></a>Linux下的权限管理</h2><p>在Ubuntu系统中可以用sudo(Substitute User DO)命令暂时成为root超级用户。</p><p><code>sudo su</code>切换超级用户，输入exit推出也可以<code>sudo</code>后面直接接待执行命令</p><p><code>adduser username</code>命令添加用户</p><p><code>passwd username</code>命令修改用户密码</p><p><code>deluser username</code>命令删除用户，直接删除，谨慎使用！</p><h3 id="用户群组管理"><a href="#用户群组管理" class="headerlink" title="用户群组管理"></a>用户群组管理</h3><p>如果不设置群组的话，默认是创建一个和用户名一样的群组。当群组多的时候则需要进行管理。</p><p><code>addgroup groupname</code>命令添加新的群组；<code>usermod</code>命令，<code>-l</code>参数可以用于修改用户名，<code>-g</code>参数可用来修改用户的群组：<code>usermod -g groupname username</code></p><p><code>groups username</code>查看用户的所在群组<br><em>添加用户到多个群组<br><code>usermod -G group1,group2,group3 username</code>，<code>-aG</code>参数可以追加而不是移动到这些群组</em></p><p><code>delgroup groupname</code>删除群组</p><h3 id="文件权限设置"><a href="#文件权限设置" class="headerlink" title="文件权限设置"></a>文件权限设置</h3><p><code>chown newuser file</code>命令改变文件所有者，但是文件所属群组依旧不变</p><p><code>chgrp newgroup file</code>命令改变群组，或者<code>chown username:groupname file</code>也可以同时改变群组和所有者</p><p><code>chown</code>的<code>-R</code>参数递归设置子目录和子文件，配合上面的方法使用</p><h4 id="修改访问权限"><a href="#修改访问权限" class="headerlink" title="修改访问权限"></a>修改访问权限</h4><p><strong>权限的原理</strong>：Linux系统中，每个文件和目录都有一系列权限属性，在<code>ls -l</code>运行的第一列信息就是访问权限符。</p><p>第一个字符中：<code>-</code>表示普通文件；<code>d</code>表示目录；<code>l</code>表示软链接文件</p><img src="/2020/12/16/linux-go1/image-20210102152128235.png" alt="image-20210102152128235" style="zoom:50%;"><p>后面的字符中，<code>r</code>可读，<code>w</code>可写，<code>x</code>可执行/可读（对于目录），如果相应位置有字母，表示有相应的权限，短横<code>-</code>表示没有相应权限</p><p><img src="/2020/12/16/linux-go1/image-20210102152505598.png" alt="image-20210102152505598"></p><p>例如file1这个文件<code>-</code>表示普通文件，<code>rw-</code>在sheelite用户下，可读可写，非可执行文件，第二个<code>rw-</code>scheelite群组其他用户也可读可写，不可执行，<code>r--</code>其他用户只能读该文件</p><h4 id="chmod命令改变文件的访问权限"><a href="#chmod命令改变文件的访问权限" class="headerlink" title="chmod命令改变文件的访问权限"></a>chmod命令改变文件的访问权限</h4><p>Linux系统对每种权限（r、w和x）分配了对应的数字</p><table><thead><tr><th>权限</th><th>数字</th></tr></thead><tbody><tr><td>r</td><td>4</td></tr><tr><td>w</td><td>2</td></tr><tr><td>x</td><td>1</td></tr></tbody></table><p>要合并这些权限，就需要简单的数字相加；比如6表示有读和写的权限</p><img src="/2020/12/16/linux-go1/113366367897643514.jpg" alt="113366367897643514" style="zoom:33%;"><p>用三组数字来表示这些权限，例如640：</p><ul><li>6 文件所有者有读写权限</li><li>4 文件所在群组其他用户具有读的权限</li><li>0 除此之外其他用户没有任何权限</li></ul><p><code>chmod 640 file1</code>修改文件权限：</p><p><img src="/2020/12/16/linux-go1/image-20210102153745678.png" alt="image-20210102153745678"></p><p><strong>用字母划分权限</strong></p><p><code>chmod u+rx file1</code>对文件的所有者增加读和运行的权限</p><p><code>chmod g+r o-r file</code>文件file的群组其他用户增加读的权限，其他用户移除读的权限</p><p>配合<code>-R</code>参数可以递归修改目录及其中的文件</p><h2 id="Linux进程操作"><a href="#Linux进程操作" class="headerlink" title="Linux进程操作"></a>Linux进程操作</h2><h3 id="通过进程名杀死进程"><a href="#通过进程名杀死进程" class="headerlink" title="通过进程名杀死进程"></a>通过进程名杀死进程</h3><p>一般可以用 <code>pkill 进程名</code>或者<code>killall 进程名</code>，但是一些linux系统下没有这两个命令，可以使用</p><p><code>kill -9 $(pidof 进程名关键字)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;终端的基本操作&quot;&gt;&lt;a href=&quot;#终端的基本操作&quot; class=&quot;headerlink&quot; title=&quot;终端的基本操作&quot;&gt;&lt;/a&gt;终端的基本操作&lt;/h2&gt;&lt;p&gt;什么是TTY?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Linux中，TTY也许是跟终端有关系的最</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://123.57.158.5/tags/Linux/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Terminal" scheme="http://123.57.158.5/tags/Terminal/"/>
    
    <category term="Ubuntu" scheme="http://123.57.158.5/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法1查找与排序</title>
    <link href="http://123.57.158.5/2020/11/08/%E7%AE%97%E6%B3%951/"/>
    <id>http://123.57.158.5/2020/11/08/%E7%AE%97%E6%B3%951/</id>
    <published>2020-11-07T17:18:13.000Z</published>
    <updated>2021-07-03T07:49:25.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><strong>判断时间复杂度</strong><br>时间复杂度判断占用时间<br>快速判断算法复杂度：</p><ol><li>   确定问题规模n</li><li>   循环减半过程 –&gt; logn</li><li>   K层关于n的循环 —&gt;n<sup>k</sup><br>复杂情况：根据算法执行过程判断</li></ol><p><strong>判断空间复杂度</strong><br>评估算法内存占用大小的式子，表达方式与时间复杂度完全一样</p><ol><li>   算法使用了几个变量：O(1)</li><li>   算法使用了长度为n的一维列表：O(n)</li><li>   算法使用了m行n列的二维列表：O(mn)<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2>递归的两个特点：1.调用自身；2.结束条件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">func1(x-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">func2(x+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">func3(x-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func4</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line">func4(x-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>所以func3和func4是递归，x为正整数，func3会连续输出x到1，func4会输出1 到x<h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2>把盘子从a移动到c</li></ol><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201108012255921.png" alt="image-20201108012255921"></p><p>这样思考过后，就把问题规模由n变成了n-1，这就是一种递归的思想。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">n,a,b,c</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        hanota问题。</span></span><br><span class="line"><span class="string">        n: 盘子数</span></span><br><span class="line"><span class="string">        a: 初始位置</span></span><br><span class="line"><span class="string">        b: 中转位置</span></span><br><span class="line"><span class="string">        c: 目标位置</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &gt;<span class="number">0</span>:</span><br><span class="line">        move(n-<span class="number">1</span>,a,c,b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;moving from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(a,c))</span><br><span class="line">        move(n-<span class="number">1</span>,b,a,c)</span><br><span class="line"></span><br><span class="line">move(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure><p>moving from a to c<br>moving from a to b<br>moving from c to b<br>moving from a to c<br>moving from b to a<br>moving from b to c<br>moving from a to c<br>共7次移动</p><p>汉诺塔移动次数递推式：h(x)=h(x-1)+1</p><h2 id="列表查找"><a href="#列表查找" class="headerlink" title="列表查找"></a>列表查找</h2><p><strong>查找</strong>：在一些数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程。<br><strong>列表查找（线性表查找）</strong>：从列表中查找指定元素</p><ul><li>输入：列表，待查找元素</li><li>输出： 元素下标（未找到返回None或者-1）<br>Python内置列表查找函数: index()<h3 id="顺序查找（Linear-Search）"><a href="#顺序查找（Linear-Search）" class="headerlink" title="顺序查找（Linear Search）"></a>顺序查找（Linear Search）</h3>顺序查找：线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或者搜索到列表最后一个元素为止。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_search</span>(<span class="params">val,li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i]==val:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="二分查找（Binary-Search）"><a href="#二分查找（Binary-Search）" class="headerlink" title="二分查找（Binary Search）"></a>二分查找（Binary Search）</h3></li></ul><p><strong>二分查找</strong>：又叫折半查找 ，从<font color="’red’">有序</font>列表的初始候选区li[0:n]开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">val, li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        val: 待查找值</span></span><br><span class="line"><span class="string">        li：有序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(li)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 候选区有值</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; val:</span><br><span class="line">            right = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 没查找到</span></span><br></pre></td></tr></table></figure><p>时间复杂度O(logn)</p><h3 id="二分与顺序查找比较"><a href="#二分与顺序查找比较" class="headerlink" title="二分与顺序查找比较"></a>二分与顺序查找比较</h3><p>为了证明二分查找比顺序查找效率要高，可以试验一下<br>写一个计算函数时间的装饰器，给两种方法加上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        t1=time.time()</span><br><span class="line">        result = func(*args,**kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; running time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(func.__name__,t2-t1))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>算法比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wrappers <span class="keyword">import</span> time_wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@time_wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order_search</span>(<span class="params">val,li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        有序查找</span></span><br><span class="line"><span class="string">        val: 待查找值</span></span><br><span class="line"><span class="string">        li: 列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i] == val:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@time_wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">val, li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二分查找</span></span><br><span class="line"><span class="string">        val: 待查找值</span></span><br><span class="line"><span class="string">        li：有序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(li)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 候选区有值</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; val:</span><br><span class="line">            right = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 没查找到</span></span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100000000</span>))</span><br><span class="line"><span class="built_in">print</span>(binary_search(<span class="number">123109</span>,li))</span><br><span class="line"><span class="built_in">print</span>(order_search(<span class="number">123109</span>,li))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：<br>binary_search running time: 0.0<br>123109<br>order_search running time: 0.04597640037536621<br>123109<br>内置列表查找函数index()用的是顺序查找，二分查找需要有序列表</p><h2 id="六种常见排序方法"><a href="#六种常见排序方法" class="headerlink" title="六种常见排序方法"></a>六种常见排序方法</h2><p>排序：将一组“无序”的记录序列调整为“有序”的记录序列<br>列表排序：将无序列表转变为有序列表</p><ul><li>输入：列表</li><li>输出：有序列表<br>内置排序函数：sort()</li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>列表每两个相邻的数，如果前面比后面大，则交换这两个数</li><li>一趟排序完成后，则无序区减少一个数，有序区增加一个数</li><li>代码关键点：趟、无序区范围<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        冒泡排序</span></span><br><span class="line"><span class="string">        li: 无序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 第i趟</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):  <span class="comment"># 遍历比较列表内数值</span></span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">li = [random.randint(<span class="number">0</span>, <span class="number">10000</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]  <span class="comment"># 10个随机数</span></span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"><span class="built_in">print</span>(bubble_sort(li))</span><br></pre></td></tr></table></figure>关键在于理解排序的过程，将列表中的每一个数依次比较。<br>时间复杂度O(n<sup>2</sup>)</li></ul><p>但是如果在某一趟过程中没有发生交换，说明已经结束排序。则需要改进算法，提高效率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        冒泡排序</span></span><br><span class="line"><span class="string">        li: 无序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 第i趟</span></span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):  <span class="comment"># 遍历比较列表内数值</span></span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span> li</span><br><span class="line">        <span class="built_in">print</span>(li)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">9672</span>, <span class="number">9123</span>, <span class="number">4409</span>, <span class="number">9845</span>, <span class="number">4436</span>, <span class="number">98</span>, <span class="number">1768</span>, <span class="number">7077</span>, <span class="number">730</span>, <span class="number">5105</span>]</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"><span class="built_in">print</span>(bubble_sort(li))</span><br></pre></td></tr></table></figure><p>对于相同的列表，则将会减少循环次数，提高效率</p><p>Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> exchange = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">              <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    exchange = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!exchange) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ShowArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowArray</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建冒泡排序对象</span></span><br><span class="line">        BubbleSort sorter = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">65</span>, <span class="number">67</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">33</span>, <span class="number">90</span> &#125;;</span><br><span class="line">        sorter.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>一趟排序记录最小的数，放到第一个位置</li><li>再一趟排序记录列表无序区最小的数，放到第二个位置<br>…</li><li>算法关键点：有序区和无序区、无序区最小数的位置<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        排序算法，将每次查找过程中较小的数放在列表最左端</span></span><br><span class="line"><span class="string">        li: 待排序列表</span></span><br><span class="line"><span class="string">        return: li    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 第i趟</span></span><br><span class="line">        min_loc = i  <span class="comment"># 无序区第一个数开始查找</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(li)):</span><br><span class="line">            <span class="keyword">if</span> li[j] &lt; li[min_loc]:</span><br><span class="line">                min_loc = j</span><br><span class="line">        li[i], li[min_loc] = li[min_loc], li[i]</span><br><span class="line">        <span class="built_in">print</span>(li)</span><br><span class="line">    <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure>时间复杂度O(n<sup>2</sup>)</li></ul><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min_loc = i;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min_loc]) &#123;</span><br><span class="line">                    min_loc = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i] = arr[min_loc];</span><br><span class="line">            arr[min_loc] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        ShowArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowArray</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SelectSort sorter = <span class="keyword">new</span> SelectSort();</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">73</span>, <span class="number">45</span>, <span class="number">66</span>, <span class="number">53</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        sorter.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>初始时手里（有序区）只有一张牌</li><li>每次（从无序区）摸一张牌，插入到手里已有牌的正确位置<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        插入排序，将无序区的数据依次取出，与有序区数据比较，然后放在合理的位置</span></span><br><span class="line"><span class="string">        li: 无序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(li)):  <span class="comment"># 无序列表第一个数</span></span><br><span class="line">        temp = li[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; temp: <span class="comment">#如果有序区的数依次与无序列表第一个数比较，直到找到对应位置</span></span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j+<span class="number">1</span>] = temp</span><br><span class="line">    <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure></li></ul><p>时间复杂度O(n<sup>2</sup>)</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>快速排序：快</li><li>快速排序思路：<ul><li>取一个元素 p ，是元素p归为；</li><li>列表被p分成两部分，左边都比p小，右边都比p大；</li><li>递归完成排序</li></ul></li></ul><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201114212701000.png" alt="image-20201114212701000"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速排序-框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">data,left,right</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    data: 列表</span></span><br><span class="line"><span class="string">    left: 列表左边index</span></span><br><span class="line"><span class="string">    right: 列表右边right</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = partition(data,left,right)</span><br><span class="line">        quick_sort(data,left,mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(data,mid+<span class="number">1</span>,right)</span><br></pre></td></tr></table></figure><p>partition函数需要实现：<br>先提出列表的第一位，单独存储为a，从列表最右边开始依次找比a小的数，放在左边的空位，然后从左边找比a大的数填补右边的空位…依次执行，左右筛选完之后（left和right重合），把a防在空位中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">li, left, right</span>):</span></span><br><span class="line">    temp = li[left]  <span class="comment"># 将列表左边第一个数提出来</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;= temp:  <span class="comment"># 从右边依次找比temp小的数</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        li[left] = li[right]  <span class="comment"># 将找到的比temp小的数放在左边空位</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= temp:   <span class="comment"># 从左边找比temp大的数</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[right] = li[left]  <span class="comment"># 将找到的比temp大的数放在右边空位</span></span><br><span class="line">    li[left] = temp  <span class="comment"># 当左右相等 列表放置结束，将temp放在列表空位上</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">li, left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:  <span class="comment"># 递归调用每一部分列表，直到完成排序</span></span><br><span class="line">        mid = partition(li, left, right)</span><br><span class="line">        quick_sort(li, left, mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(li, mid+<span class="number">1</span>, right)</span><br></pre></td></tr></table></figure><p>快排的效率：</p><p>时间复杂度：O(n(logn))</p><p>存在的问题：</p><p>最坏情况，将倒叙的列表排序，时间复杂度接近O(n)了，但是这点可以通过随机取数解决</p><p>python在windows上递归最大深度为998，但是可以设置修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序前传-树与二叉树</p><ul><li>树是一种数据结构 比如：目录结构</li><li>树是一种可以递归定义的数据结构</li><li>树是由n个节点组成的集合：<ul><li>如果n=0，那是一颗空树；</li><li>如果n&gt;0，那存在一个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一个树。</li></ul></li></ul><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201119225548961.png" alt="image-20201119225548961"></p><p><strong>根节点</strong>：如图里的A</p><p><strong>叶子节点</strong>：不可分叉的节点，如图中的B C H I P Q…</p><p><strong>树的深度（高度）</strong>：看有几层，如图中是四层</p><p><strong>树的度</strong>：就是往下分了几个叉，比如E的度是2，如果说一整棵树，就是指分叉分得最多的节点的度，比如图中是A，度为6。</p><p><strong>孩子节点</strong>、<strong>父节点</strong>：不解释</p><p><strong>子树</strong>：树的一部分</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>就是度不超过的2的树，每个节点最多有两个孩子节点，两个孩子节点被区分为左孩子节点，右孩子节点</p><p><strong>满二叉树</strong>：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树</p><p><strong>完全二叉树</strong>：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201123235002681.png" alt="image-20201123235002681" style="zoom: 67%;"><p><strong>二叉树的存储排序</strong>（表达方式）</p><p>分链式存储方式（后面阐述）和<strong>顺序存储方式</strong></p><p>顺序存储类似于列表，挨个存储，存储之后可以找到，父节点与左右孩子节点的关系。</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201123235917151.png" alt="image-20201123235917151"></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>堆</strong>：一种特殊的完全二叉树结构</p><ul><li>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li><li>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li></ul><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201124224317521.png" alt="image-20201124224317521"></p><p><strong>堆的向下调整</strong>：假设节点的左右子树都是堆，但自身不是堆。可以通过一次向下的调整来将其变成一个堆(和较低层级元素交换形成大根堆或小根堆)</p><h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><p>过程：</p><ol><li><p>建立堆</p><p>从最低 最右 层级进行调整，构造成堆</p></li><li><p>得到堆顶元素，为最大元素</p></li><li><p>去掉堆顶元素，将堆最后一个元素放到堆顶，此时可通过一次向下调整重新使堆有序</p></li><li><p>堆顶元素为第二大元素</p></li><li><p>重复步骤3，直到堆变空</p></li></ol><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/55.gif" alt="55"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        堆向下调整过程</span></span><br><span class="line"><span class="string">        li: 待调整列表</span></span><br><span class="line"><span class="string">        low: 根节点元素</span></span><br><span class="line"><span class="string">        high: 最后一个节点元素</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  <span class="comment"># 最开始i为根节点元素</span></span><br><span class="line">    j = i*<span class="number">2</span>+<span class="number">1</span>   <span class="comment"># j为i的左孩子</span></span><br><span class="line">    tmp = li[low]   <span class="comment"># 将根节点元素临时存储起来</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:  <span class="comment"># 只要j位置有数</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j+<span class="number">1</span>] &gt; li[j]:   <span class="comment"># 只要右孩子存在且大于左孩子</span></span><br><span class="line">            j = j+<span class="number">1</span>   <span class="comment"># j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> li[j] &gt; tmp:  <span class="comment"># 如果j节点数大于i节点</span></span><br><span class="line">            li[i] = li[j]  <span class="comment"># j节点数上移</span></span><br><span class="line">            i = j   <span class="comment"># 继续下一层级</span></span><br><span class="line">            j = i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br></pre></td></tr></table></figure><p>开始<strong>构造（建立）堆</strong></p><p>需要从最后的父节点开始，最后一个节点的小标为n-1，可以求出其父节点为<code>(n-2)//2</code></p><p>之后<strong>挨个出数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line"><span class="comment"># i 为待调整堆的根节点位置</span></span><br><span class="line">        sift(li, i, n - <span class="number">1</span>)<span class="comment"># 到这里堆建立完成</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># i 指向当前堆的最后一个元素</span></span><br><span class="line">        li[<span class="number">0</span>], li[i] = li[i], li[<span class="number">0</span>]</span><br><span class="line">        sift(li, <span class="number">0</span>, i - <span class="number">1</span>) <span class="comment"># i已经被提上low的位置，high的位置所以变成了i-1</span></span><br></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)</p><h5 id="堆排序内置模块"><a href="#堆排序内置模块" class="headerlink" title="堆排序内置模块"></a>堆排序内置模块</h5><p>python内置模块——heapq</p><p> <strong>补充模块说明</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="comment"># q--&gt;queue 优先队列（小的先出或者大的先出</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">heapq.heapify(li)<span class="comment"># 建堆,建立的是小根堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)):</span><br><span class="line">    heapq.heappop(li)<span class="comment"># 挨个出数</span></span><br></pre></td></tr></table></figure><h4 id="堆排序——topk问题"><a href="#堆排序——topk问题" class="headerlink" title="堆排序——topk问题"></a>堆排序——topk问题</h4><p>现在有n个数，设计算法得到前k大的数。（k&lt;n)</p><p>解决思路：</p><ul><li>排序后切片     复杂度：O(nlogn+k)k可以忽略</li><li>排序LowB三人组      复杂度：O(kn) </li><li>堆排序思路        复杂度：O(nlogk)</li></ul><p>堆排序解决topk思路：</p><ol><li>取列表前k个元素建立一个小根堆，堆顶就是目前的第k大的树</li><li>依次向后遍历原列表，对列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一此调整</li><li>遍历列表所有元素后，倒序弹出堆顶</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift_k</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        向下调整</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low</span><br><span class="line">    j = i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    tmp = li[low]</span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>] <span class="keyword">and</span> j+<span class="number">1</span> &lt;= high:</span><br><span class="line">            j = j+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> li[j] &lt; tmp:</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = j*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span>(<span class="params">li, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        取出列表中最大的k个数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="comment"># 取出前k个数建立小根堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((k-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        sift_k(li, i, k-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(li)</span><br><span class="line">    <span class="comment"># 遍历k后面的数，比li[0]大则替换且重新调整</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; li[<span class="number">0</span>]:</span><br><span class="line">            li[<span class="number">0</span>] = li[i]</span><br><span class="line">            sift_k(li, <span class="number">0</span>, k-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 出数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        li[i], li[<span class="number">0</span>] = li[<span class="number">0</span>], li[i]</span><br><span class="line">        sift_k(li, <span class="number">0</span>, i-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> li[<span class="number">0</span>:k]</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>假设现在的列表分两段有序，如何将其合并成一个有序列表。这样的合并操作就成为归并（merge）</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/27.gif" alt="GIF 2020-12-7 21-21-27"></p><p>归并函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">li, low, mid, high</span>):</span></span><br><span class="line">    i = low</span><br><span class="line">    j = mid+<span class="number">1</span></span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> li[i] &lt; li[j]:</span><br><span class="line">            tmp.append(li[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(li[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 两边肯定有一部分没有数了</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        tmp.append(li[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        tmp.append(li[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    li[low:high+<span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure><h4 id="使用归并"><a href="#使用归并" class="headerlink" title="使用归并"></a>使用归并</h4><ul><li>分解：将列表越分越小，直到分成一个元素</li><li>终止条件：一个元素是有序的</li><li>合并：将两个有序列表归并，列表越来越大</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:  <span class="comment"># 说明至少有两个元素，递归归并</span></span><br><span class="line">        mid = (low+high)//<span class="number">2</span></span><br><span class="line">        merge_sort(li, low, mid)</span><br><span class="line">        merge_sort(li, mid+<span class="number">1</span>, high)</span><br><span class="line">        merge(li, low, mid, high)   <span class="comment"># 调用归并方法</span></span><br></pre></td></tr></table></figure><p>每次归并是O(n)，所以时间复杂度是O(nlogn)。空间复杂度是O(n)</p><p>python的<code>sort()</code>使用的一种‘team sort’的算法，结合了插入排序与归并排序</p><h3 id="排序方法对比"><a href="#排序方法对比" class="headerlink" title="排序方法对比"></a>排序方法对比</h3><p>三种快速排序的时间复杂度都是O(nlogn)</p><p>一般情况下，就运行时间而言：快速排序&lt;归并排序&lt;堆排序</p><p>三种算法的缺点：</p><ul><li>快速排序：极端情况下排序效率低</li><li>归并排序：需要额外的内存开销</li><li>堆排序：在快的排序算法中仙骨笛较慢</li></ul><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201209144244938.png" alt="image-20201209144244938"></p><p>稳定性：稳定指的是排序中的两个相同的数，排序后相对其初始位置不发生改变。挨个比较的算法就是稳定的！！</p><h2 id="其他排序"><a href="#其他排序" class="headerlink" title="其他排序"></a>其他排序</h2><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序（Shell Sort）是一种分组插入排序算法。</p><ol><li><p>首先取一个整数d<sub>1</sub>=n/2，将元素分为d<sub>1</sub>个组，每组相邻两个元素之间的距离是d<sub>1</sub>，在各组内进行直接插入排序；</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/28.gif" alt="GIF 2020-12-14 20-48-28"></p></li><li><p>取第二个数d<sub>2</sub>=d<sub>1</sub>/2，重复上述分组排序过程，直到d<sub>i</sub>=1，即所有元素在同一组内进行直接插入排序。</p></li></ol><p>希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/11.gif" alt="GIF 2020-12-14 20-55-11"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_insert_sort</span>(<span class="params">gap, li</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; 这一部分采用的是插入排序的思想 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, <span class="built_in">len</span>(li)):</span><br><span class="line">        temp = li[i]</span><br><span class="line">        j = i - gap</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; temp:</span><br><span class="line">            li[j+gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j+gap] = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 分组之后 各组采用插入排序 &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    d = n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> d &gt; <span class="number">0</span>:</span><br><span class="line">        shell_insert_sort(d, li)</span><br><span class="line">        d //= <span class="number">2</span></span><br></pre></td></tr></table></figure><p>时间复杂度与选取的gap序列有关</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>对列表进行排序，已知列表中的数范围都在0到100之间。设计时间复杂度为O(n)的算法</p><p>优点：比系统自带的<code>sort()</code>方法都快</p><p>缺点：消耗空间（需要100个数的列表），有限制（需要知道列表中数的范围）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coun_sort</span>(<span class="params">li,max_count=<span class="number">100</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计数排序，已知列表中的数的范围，新建0-最大数的顺序列表用于记录每个数的出现次数，从而排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    count_list = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_count+<span class="number">1</span>)] <span class="comment"># 生成一个长度为li的最大值的统计次数列表</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> li:</span><br><span class="line">        count_list[val] += <span class="number">1</span> <span class="comment"># 统计每个数出现的次数</span></span><br><span class="line">    li.clear()</span><br><span class="line">    <span class="keyword">for</span> index, count <span class="keyword">in</span> <span class="built_in">enumerate</span>(count_list): <span class="comment"># 遍历生成新的列表</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">            li.append(index)</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>在计数排序中，如果元素的范围比较大（比如在1到1亿之间），如何改造算法？</p><p>桶排序(Bucket Sort): 首先将元素分在不同的桶中，在对每个桶中的元素排序</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201229222547450.png" alt="image-20201229222547450"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span>(<span class="params">li, n=<span class="number">10</span>, max_num=<span class="number">10000</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">桶排序，将列表中的数分为10个桶，将每个桶中的数排序</span></span><br><span class="line"><span class="string">li:待排序列表</span></span><br><span class="line"><span class="string">n:桶个数</span></span><br><span class="line"><span class="string">max_num:列表最大数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建桶</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> li:</span><br><span class="line"><span class="comment"># 将列表中的数依次放入桶中，对于列表中的最大数，放入最后一个桶</span></span><br><span class="line">        i = <span class="built_in">min</span>(var//(max_num//n), n-<span class="number">1</span>)</span><br><span class="line">        buckets[i].append(var)</span><br><span class="line">        <span class="comment"># 将每个桶中元素进行排序</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets[i])-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> buckets[i][j] &lt; buckets[i][j-<span class="number">1</span>]:</span><br><span class="line">            buckets[i][j], buckets[i][j-<span class="number">1</span>] = buckets[i][j-<span class="number">1</span>], buckets[i][j]</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    li.clear()</span><br><span class="line">    <span class="keyword">for</span> buk <span class="keyword">in</span> buckets:</span><br><span class="line">        li.extend(buk)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>桶排序表现取决于数据的分布。也就是需要对不同数据排序时采取不同的分桶策略。</li><li>平均情况时间复杂度：O(n+k)，k约一个桶中元素个数。</li><li>最坏情况时间复杂度：O(n<sup>2</sup>k)</li><li>空间复杂度：O(nk)</li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>多关键字排序：假如现在有一个员工表，要求按照薪资排序，年龄相同的员工按照年龄排序。</p><p>思路：先按照年龄进行排序，再按照薪资进行稳定的排序</p><p>对于32、13、94、52、17、54、93是否可以看做多关键字排序（先看十位，后看个位）</p><p>在基数排序中，先排序个位，再排序十位！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redix_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基数排序，将列表中的数依次按个位、十位、百位...最高位排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    max_digit = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(li))) <span class="comment"># 获取最大数的位数</span></span><br><span class="line">    t = <span class="number">0</span> <span class="comment"># t代表循环的次数</span></span><br><span class="line">    <span class="keyword">while</span> t &lt;= max_digit:</span><br><span class="line">        <span class="comment"># 每次都构建十个桶</span></span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> var <span class="keyword">in</span> li:</span><br><span class="line">            i = (var//(<span class="number">10</span>**t)) % <span class="number">10</span> <span class="comment"># 获取列表中数对应位数上的值</span></span><br><span class="line">            buckets[i].append(var)</span><br><span class="line">        li.clear()</span><br><span class="line">        <span class="keyword">for</span> buk <span class="keyword">in</span> buckets:</span><br><span class="line">            li.extend(buk)</span><br><span class="line">       t += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>时间复杂度：（kn)</p><p>空间复杂度：（n+k)</p><p>k表示最大数位数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;算法复杂度&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;判断时间复杂度&lt;/strong&gt;&lt;br&gt;时间复杂度判断占用时间&lt;br&gt;快速判断算法复杂度：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://123.57.158.5/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="数据结构与算法" scheme="http://123.57.158.5/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://123.57.158.5/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="查找算法" scheme="http://123.57.158.5/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
