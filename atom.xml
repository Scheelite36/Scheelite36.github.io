<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只柑の博客</title>
  
  
  <link href="http://123.57.158.5/atom.xml" rel="self"/>
  
  <link href="http://123.57.158.5/"/>
  <updated>2021-05-23T02:34:37.977Z</updated>
  <id>http://123.57.158.5/</id>
  
  <author>
    <name>一只柑</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://123.57.158.5/2021/05/23/hello-world/"/>
    <id>http://123.57.158.5/2021/05/23/hello-world/</id>
    <published>2021-05-23T02:34:37.977Z</published>
    <updated>2021-05-23T02:34:37.977Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树的一些性质及遍历</title>
    <link href="http://123.57.158.5/2021/03/11/b-tree-traverse/"/>
    <id>http://123.57.158.5/2021/03/11/b-tree-traverse/</id>
    <published>2021-03-11T02:05:20.000Z</published>
    <updated>2021-05-23T02:34:34.370Z</updated>
    
    <content type="html"><![CDATA[<p>算法中已经提到过二叉树，这里重点讲二叉树的遍历。参考书籍《大话数据结构》</p><p>二叉树的一些性质，这些性质可以很简单得到证明：</p><ol><li>在二叉树第i层最多有2<sup>i-1</sup>个节点</li><li>深部为k的二叉树最多有2<sup>k</sup>-1节点</li><li>对于任何一个二叉树，如果其终端节点（叶子节点）数为n<sub>0</sub>，度为2的节点数为n<sub>2</sub>，n<sub>0</sub>=n<sub>2</sub>+1</li><li>具有n个节点的完全二叉树的深度为[log<sub>2</sub>n]+1（[x]表示不大于x的最大整数）。<em>可以理解为性质2的倒推</em></li><li>如果有一颗n个节点的完全二叉树的节点按照层序编号（从第一层到最后一层，每层从左往右），对任意一个节点（1&lt;=i&lt;=n）有：<ul><li>如果i=1，则节点i是完全二叉树的根，无双亲；如果i&gt;1，其双亲节点是[i/2]</li><li>如果2i&gt;n，则节点i无左孩子（节点i为叶子节点）；否则<font color="red">左孩子是2i</font></li><li>如果2i+1&gt;n，则节点i无右孩子；否则其<font color="red">右孩子是节点2i+1</font></li></ul></li></ol><p><strong>二叉树的遍历</strong>：是指从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。</p><div class="mermaid">graph TDA --&gt; BA --&gt; CB --&gt; DB --&gt; EC --&gt; FC --&gt; G</div><p>遍历可分为前序（ABC)  中序(BAC)  后序(BCA)</p><p><strong>前序遍历</strong>：依次访问根节点——左孩子——右孩子。上图的二叉树前序遍历后为ABDECFG</p><p><strong>中序遍历</strong>：依次访问左孩子——根节点——右孩子。DBEAFCG</p><p><strong>后序遍历</strong>：依次访问左孩子——右孩子——根节点。DEBFGCA</p><p>层序遍历：一层层从左至右。ABCDEFG</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;算法中已经提到过二叉树，这里重点讲二叉树的遍历。参考书籍《大话数据结构》&lt;/p&gt;
&lt;p&gt;二叉树的一些性质，这些性质可以很简单得到证明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在二叉树第i层最多有2&lt;sup&gt;i-1&lt;/sup&gt;个节点&lt;/li&gt;
&lt;li&gt;深部为k的二叉树最多有2&lt;sup&gt;k</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://123.57.158.5/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="http://123.57.158.5/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="算法" scheme="http://123.57.158.5/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux文本编辑器及软件安装</title>
    <link href="http://123.57.158.5/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://123.57.158.5/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</id>
    <published>2021-01-06T15:26:14.000Z</published>
    <updated>2021-05-23T02:34:39.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nano文本编辑器"><a href="#Nano文本编辑器" class="headerlink" title="Nano文本编辑器"></a>Nano文本编辑器</h2><blockquote><p>复制、剪贴和粘贴</p><p>复制一整行：Alt+6</p><p>剪贴一整行：Ctrl+K</p><p>粘贴：Ctrl+U</p><p>如果需要复制／剪贴多行或者一行中的一部分，先将光标移动到需要复制／剪贴的文本的开头，按Ctrl+6（或者Alt+A）做标记，然后移动光标到 待复制／剪贴的文本末尾。这时选定的文本会反白，用Alt+6来复制，Ctrl+K来剪贴。若在选择文本过程中要取消，只需要再按一次Ctrl+6。</p><p>搜索</p><p>按Ctrl+W，然后输入你要搜索的关键字，回车确定。这将会定位到第一个匹配的文本，接着可以用Alt+W来定位到下一个匹配的文本。</p><p>保存</p><p>使用Ctrl+O来保存所做的修改</p><p>退出</p><p>按Ctrl+X</p></blockquote><p><code>nano file</code>可以直接路径，没有该文件的话，就会创建一个再编辑</p><p><strong>配置nano编辑器</strong></p><p>单个用户配置：</p><p>一般通过<code>/home/username</code>路径下的.nanorc文件修改。<code>nano .nanorc</code></p><p>配置语言以set开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 相当于命令后面加 -m 参数 鼠标生效</span><br><span class="line">set mouse</span><br><span class="line"># 相当于 -i 参数 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line"># 激活职能home键 -A参数</span><br><span class="line">set smarthome</span><br></pre></td></tr></table></figure><p>全局配置：</p><p><code>/etc/nanorc</code>文件中修改（root用户）</p><p><code>sudo nano /etc/nanorc</code></p><p><strong>配置终端</strong></p><p>单个用户的终端配置文件<code>/home/username/.bashrc</code></p><p><code>nano ~/.bashrc</code></p><p>bash其实是一种shell，shell用于解释我们输入终端的各种命令的，是用户和操作系统之间的一个命令解释器。</p><p>配置.bashrc文件可以修改终端的各种配置，如命令提示符样式，创建命令别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建别名 alias xx=&#x27;command&#x27;</span><br><span class="line">alias ll=&#x27;ls -alF&#x27;</span><br><span class="line">alias la=&#x27;ls -A&#x27;</span><br><span class="line">alias l=&#x27;ls -CF&#x27;</span><br></pre></td></tr></table></figure><p>全局配置的路径：<code>/etc/bash.bashrc</code>，但是家目录下的<font color="red">优先级</font>高于系统的bash.bashrc文件</p><p><strong>profile配置文件</strong></p><p>单个用户：<code>~/.profile</code>，全局<code>/etc/profile</code></p><p>bashrc应用于图形化终端，profile应用于TTY1-TTY6这种需要用户登录的终端。profile文件会调用.bashrc</p><img src="/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/151709029500416466.jpg" alt="151709029500416466" style="zoom:33%;"> <p>bashrc 和 profile二者修改后都是下次登陆生效，需要立即生效使用source命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br><span class="line">source .profile</span><br></pre></td></tr></table></figure><h2 id="Ubuntu软件仓库"><a href="#Ubuntu软件仓库" class="headerlink" title="Ubuntu软件仓库"></a>Ubuntu软件仓库</h2><p>对于ubuntu系统，在全世界各地分布有软件仓库。Linux的.deb软件包相较于windows的exe安装包文件，包含了依赖关系的管理，对于依赖的软件会自动下载。</p><p><strong>管理软件仓库</strong></p><p>如果我们要切换软件仓库，可以通过编辑软件仓库列表文件<code>/etc/apt/sources.list</code>(root模式)</p><p>一般来说，这个文件中有作用的行是由以下两个指令开头：</p><ul><li>deb: 用于下载软件的二进制版本，大多数情况下我们用的是这个</li><li>deb-src: 用于下载软件的源代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例其中一行</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic universe</span><br></pre></td></tr></table></figure><p>第二个是仓库地址，第三个bionic是Ubuntu版本代号，第三个universe是软件仓库的区域，也就是要查看的代码仓库的不同分区。</p><p>Ubuntu图形界面中software&amp;update中可以直接切换软件仓库，更加方便</p><h3 id="终端包管理工具"><a href="#终端包管理工具" class="headerlink" title="终端包管理工具"></a>终端包管理工具</h3><p><code>apt-get</code>/<code>apt</code>管理包命令</p><p><code>aptitude</code>：这个命令再卸载软件时可以卸载不用的依赖</p><p><code>sudo apt update</code>更新软件包缓存；<code>sudo apt-cache search</code>搜索软件包；<code>sudo apt install</code>安装软件包；<code>sudo apt upgrade</code>升级所有已安装软件包；<code>sudo apt autoremove</code></p><p><code>dpkg</code>命令时apt-get和aptitude两个命令的后端（backend）命令</p><p>依赖链：<code>dpkg--&gt;apt-get,aptitude--&gt;Ubuntu Software</code></p><p>使用dpkg可以安装本地的软件包：<code>sudo dpkg -i *.deb</code>，卸载：<code>sudo dpkg -r 包名</code></p><h2 id="阅读手册"><a href="#阅读手册" class="headerlink" title="阅读手册"></a>阅读手册</h2><h3 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h3><p>例如<code>man ls</code>，会出现ls命令的使用说明。手册的各部分区域说明：</p><p><strong>NAME</strong></p><p>命令的全称</p><p><strong>SYNOPSIS</strong></p><p>概要，使用此命令的方法</p><p><code>ls [OPTION]... [FILE]...</code></p><img src="/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20210110233353458.png" alt="image-20210110233353458" style="zoom:50%;"><p>粗体：原封不动输入</p><p>下划线：用实际内容替代</p><p><code>[-hvc]</code>中括号内为可选参数</p><p><code>a|b</code>输入a或b选项</p><p>OPTION参数，省略号表示可输入多个参数</p><p><strong>DESCRIPTION</strong></p><p>列出所有参数和用法</p><p>其他区域：<strong>AUTHOR</strong>, <strong>REPROTIONG BUGS</strong>, <strong>COPYRIGHT</strong>, <strong>SEE ALSO</strong></p><h3 id="apropos查找命令"><a href="#apropos查找命令" class="headerlink" title="apropos查找命令"></a>apropos查找命令</h3><p>apropos命令后面添加关键字即可（根据手册中的关键字）</p><p>例如需要查找控制音量的方法 <code>apropos sound</code></p><img src="/2021/01/06/Linux%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20210111005834669.png" alt="image-20210111005834669" style="zoom:67%;"><h3 id="其他查阅手册的方法"><a href="#其他查阅手册的方法" class="headerlink" title="其他查阅手册的方法"></a>其他查阅手册的方法</h3><p><strong>很多命令都支持<code>-h</code>参数</strong></p><p>比man命令的内容稍显简便</p><p><strong>whatis命令</strong></p><p>man的精简版，显示man的NAME区域</p><h3 id="文件查找命令"><a href="#文件查找命令" class="headerlink" title="文件查找命令"></a>文件查找命令</h3><h4 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h4><p><font color="red">查找速度极快，查找包含关键字的文件。</font></p><p><code>locate xxx</code>会查找并列出xxx（目录或文件名包含xxx）所在的所有目录</p><p>缺陷：如果是刚新建的文件locate是查不到的，因为locate不是查找硬盘，是在数据库（包含文件的列表和文件的位置）中查找记录。对于刚创建的文件，没有更新进数据库（一般24小时自动更新）</p><p>当然也可以用updatedb命令强制系统立即更新数据库 <code>sudo updatedb</code></p><h4 id="find命令深入查找"><a href="#find命令深入查找" class="headerlink" title="find命令深入查找"></a>find命令深入查找</h4><font color="red">遍历实际的硬盘的文件，还可以对查找的文件进行操作。查找文件要完全对应关键字，但是可以用正则匹配功能强大</font><p>find 默认当前子目录查找，也可以指定目录查找；用文件名、创建时间等查找；最后可以对找到的文件进行操作</p><p>例如：<code>find -name &#39;new_file&#39;</code>根据名字查找当前目录的文件 ; <code>find /var/log -name &#39;syslog&#39;</code>查找其他目录的文件； </p><p><strong>根据文件大小查找</strong></p><p><code>find /var -size +10M</code>查找/var目录下大于10m的文件</p><p><strong>根据文件的最近访问时间查找</strong></p><p><code>find -name &#39;*.txt&#39; -atime -7</code>查找7天内访问的txt文件</p><p><strong>仅查找目录或文件</strong></p><p><code>find -name &#39;file1&#39; -type d</code>查找名为file1的目录</p><p><strong>操作查找结果</strong></p><p>格式化输出：<code>find -name &#39;file1&#39; -printf &#39;%p - %u\n&#39;</code>将查找到的文件格式化输出为<code>文件名 - 用户名</code>的形式</p><p>删除操作：<code>xxx -delete</code></p><p>调用其他命令：</p><p>加上<code>-exec</code>参数之后就可以接其他命令了，十分强大</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/var目录下的所有txt文件修改权限为600</span></span><br><span class="line">find /var -name <span class="string">&#x27;*.txt&#x27;</span> -<span class="built_in">exec</span> chmod 600 &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>大括号表示刚查找到的文件，<code>\;</code>是exec的结尾</p><p>将<code>-exec</code>参数换成<code>-ok</code>参数效果一样，但是会对每个文件都做确认提示！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nano文本编辑器&quot;&gt;&lt;a href=&quot;#Nano文本编辑器&quot; class=&quot;headerlink&quot; title=&quot;Nano文本编辑器&quot;&gt;&lt;/a&gt;Nano文本编辑器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;复制、剪贴和粘贴&lt;/p&gt;
&lt;p&gt;复制一整行：Alt+6&lt;/</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://123.57.158.5/tags/Linux/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Terminal" scheme="http://123.57.158.5/tags/Terminal/"/>
    
    <category term="Ubuntu" scheme="http://123.57.158.5/tags/Ubuntu/"/>
    
    <category term="Nano" scheme="http://123.57.158.5/tags/Nano/"/>
    
    <category term="RTFM" scheme="http://123.57.158.5/tags/RTFM/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络5之实践网络分析异步任务（更新中</title>
    <link href="http://123.57.158.5/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5/"/>
    <id>http://123.57.158.5/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5/</id>
    <published>2020-12-30T16:43:42.000Z</published>
    <updated>2021-05-23T02:34:44.457Z</updated>
    
    <content type="html"><![CDATA[<p>内容安排</p><div class="mermaid">graph LR;a[搭建服务基本框架]--&gt;b[Python操作字节序列]b--&gt;c[实现IP报文解析器]c--&gt;d[实现UDP报文解析器]d--&gt;e[实现TCP报文解析器]</div><p><img src="/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5/image-20210102231245869.png" alt="image-20210102231245869"></p><h2 id="搭建服务基本框架"><a href="#搭建服务基本框架" class="headerlink" title="搭建服务基本框架"></a>搭建服务基本框架</h2><p>网卡工作的两种模式：</p><table><thead><tr><th>混杂模式</th><th>非混杂模式</th></tr></thead><tbody><tr><td>接受所有经过网卡设备的数据</td><td>只接受目的地址指向自己的数据</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内容安排&lt;/p&gt;
&lt;div class=&quot;mermaid&quot;&gt;graph LR;
	a[搭建服务基本框架]--&amp;gt;b[Python操作字节序列]
	b--&amp;gt;c[实现IP报文解析器]
	c--&amp;gt;d[实现UDP报文解析器]
	d--&amp;gt;e[实现TCP报文解析器</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="实战" scheme="http://123.57.158.5/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="计算机网络" scheme="http://123.57.158.5/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络4应用层</title>
    <link href="http://123.57.158.5/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://123.57.158.5/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-12-29T07:02:01.000Z</published>
    <updated>2021-05-23T02:34:44.271Z</updated>
    
    <content type="html"><![CDATA[<p>应用层位于TCP/IP四层模型的最上面，对应七层模型的应用层、表示层会话层。</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201229150405939.png" alt="image-20201229150405939"></p><h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><p>传输层给及以下的层提供了完整的通信服务，应用层主要是面向用户的一层。</p><p>应用层的一些协议：</p><table><thead><tr><th>FTP</th><th>HTTP</th><th>HTTPS</th><th>DNS</th><th>TELNET</th></tr></thead><tbody><tr><td>21</td><td>80</td><td>443</td><td>53</td><td>23</td></tr></tbody></table><p>应用层内容包括以后的应用层软件和面向传输层的编程</p><p>传输层TCP\UDP协议的使用场景：</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201229151054596.png" alt="image-20201229151054596"></p><p>应用层主要功能是定义应用间通信的规则，比如应用进程的报文类型（请求报文、应答报文）；报文的语法和格式；应用进程发送数据的时机、规则</p><h2 id="DNS详解"><a href="#DNS详解" class="headerlink" title="DNS详解"></a>DNS详解</h2><p>DNS(Domain Name System: 域名系统)</p><p>首先我们是通过<code>ip地址:端口</code>来指定某个网络服务（web服务、网络存储、远程调用等等），而DNS就是方便记录各项网络服务地址的。</p><p>使用域名帮助记忆。将域名解析为IP地址。</p><ul><li>域名由点、字母和数字组成</li><li>点分割不同的域</li><li>域名可以分为顶级域、二级域、三级域</li></ul><p>例如<code>www.rice-and-bran.site</code>，site就是顶级域，rice-and-bran是二级域，www是三级域。</p><div class="mermaid">graph LR;    A{顶级域}--&gt;B{国家}    A--&gt;C{通用}    B--&gt;D[cn]    B--&gt;E[us]    C--&gt;F[com]    C--&gt;G[net]    C--&gt;H[gov]</div><p>当访问一个域名的时候，首先会访问本地域名服务器，若没有则访问根域名服务器，再访问顶级域名服务器，一步步向下。</p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>DHCP(Dynamic Host Configuration Protocol: 动态主机设置协议)，是一个局域网协议，应用UDP协议的应用层协议。</p><p>比如电脑中的TCP/IP协议设置中，默认选择自动获取IP地址，就是通过DHCP协议自动获得局域网分配的ip，（非永久，有租期的一个概念）</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201230233537304.png" alt="image-20201230233537304"></p><p>当设备要接入局域网，DHCP协议工作过程：</p><ul><li>DHCP服务器监听默认端口：67</li><li>主机使用UDP协议广播DHCP发现报文</li><li>DHCP服务器发出DHCP提供报文</li><li>主机向DHCP服务器发出DHCP请求报文</li><li>DHCP服务器回应并提供IP地址</li></ul><p>之后如果设备还要与外网通信，则需要通过NAT技术转换公网IP进行通信</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP(HyperText Transfer Protocol: 超文本传输协议)，是可靠的数据传输协议</p><p><code>http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></p><p>http一般使用80端口，https一般使用443端口</p><p>web服务器应答过程: </p><div class="mermaid">graph LR;a[接收客户端连接]--&gt;b[接收请求报文]b--&gt;c[处理请求]c--&gt;d[访问web资源]d--&gt;e[构造应答]e--&gt;f[发送应答]</div><table><thead><tr><th>HTTP请求方法</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>获取指定的服务端资源/提交数据</td></tr><tr><td>POST</td><td>提交数据到服务端</td></tr><tr><td>DELETE</td><td>删除指定的服务端资源</td></tr><tr><td>UPDATE</td><td>更新指定的服务端资源</td></tr><tr><td>PUT</td><td></td></tr><tr><td>OPTIONS</td><td></td></tr><tr><td>PATCH</td><td></td></tr><tr><td>HEAD</td><td></td></tr><tr><td>TRACE</td><td></td></tr></tbody></table><ol><li>在地址中指定资源：</li></ol><p><code>xxx/111.html</code>, <code>xxx/?a=1&amp;b=1</code></p><ol start="2"><li>在请求中指定资源：</li></ol><p>请求报文和应答报文的组成：</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201230235508131.png" alt="image-20201230235508131"></p><p>例如通过POST请求来指定资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST https://www.rice-and-bran.com HTTP/1.1</span><br><span class="line"></span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;sort&quot;:0,</span><br><span class="line">&quot;unlearn&quot;:0,</span><br><span class="line">&quot;page&quot;:2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到请求后，web服务器返回应答报文，包含状态码，具体有这些类型：</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>200~299</td><td>成功状态码</td></tr><tr><td>300~399</td><td>重定向状态码</td></tr><tr><td>400~499</td><td>客户端错误状态码</td></tr><tr><td>500~599</td><td>服务端错误状态码</td></tr></tbody></table><h2 id="HTTP工作的结构"><a href="#HTTP工作的结构" class="headerlink" title="HTTP工作的结构"></a>HTTP工作的结构</h2><h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h3><p>优先把热门数据缓存起来</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231000807836.png" alt="image-20201231000807836"></p><h3 id="web代理"><a href="#web代理" class="headerlink" title="web代理"></a>web代理</h3><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231001012582.png" alt="image-20201231001012582"></p><p>作用：1.屏蔽server部署的结构，不给用户直接看到；2.保证server的安全，比如在proxy中设置防火墙</p><p><strong>正向代理</strong>：代表client去访问server；<strong>反向代理</strong>：代表server把数据返回给客户端</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN(Content Delivery Network: 内容分发网络)，为了进行多媒体内容的加速</p><p>在距离用户近的地方部署cdn服务器备份多媒体内容，使用户更快的收到内容，改善用户获取多媒体内容的体验。</p><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p>例如搜索引擎的爬虫，爬取信息，建立索引。但是不好的爬虫会增加网络拥塞，损耗服务器资源</p><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTP是明文传输的，但是对于一些敏感信息传输。https协议会对传输内容进行加密，https为443端口</p><h3 id="加密模型"><a href="#加密模型" class="headerlink" title="加密模型"></a>加密模型</h3><p>对称加密：加密解密密钥统一；非对称加密则不一致</p><p>假设加密密钥为A，解密密钥为B；AB是拥有一定数学关系的一组密钥。</p><p>通过<strong>公钥</strong>（公开）进行加密，<strong>私钥</strong>（非公开，用户使用）进行解密</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书是可信任组织颁发给特定对象的认证</p><p>数字证书的内容：证书格式、版本号；证书序列号；有效期；对象名称；<font color="red">对象公开密钥</font>…</p><p><strong>SSL</strong>(Secure Sockets Layer: 安全套接层)，是介入传输层和应用层之间，保证数据安全和数据完整，对传输层数据进行加密后传输</p><p>https协议加密过程：</p><p><em>E：encode，D：decode</em></p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231003216484.png" alt="image-20201231003216484"></p><p>SSL安全参数握手过程: </p><p>1，2：</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231003549226.png" alt="image-20201231003549226"></p><p>3：客户端收到服务端的加密算法、数字证书以及随机数后。需要</p><ul><li>确认证书是否有效</li><li>生成随机数3</li><li>使用服务器公钥加密随机数3</li></ul><p>4：发送加密后的数据给服务器</p><p><img src="/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B1%82/image-20201231003818999.png" alt="image-20201231003818999"></p><p>然后服务器解密随机数3，两边都拥有了三个随机数</p><p>5：两边根据随机数1,2,3和相同的算法生成<font color="red">对称密钥</font>，双方使用对称密钥进行加密通信</p><p>ssl参数握手过程的特点：</p><ul><li>综合使用对称加密和非对称加密</li><li>双方分别生成秘钥，没有经过传输过程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;应用层位于TCP/IP四层模型的最上面，对应七层模型的应用层、表示层会话层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4%E5%BA%94%E7%94%A8%E5%B</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://123.57.158.5/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>红会急救培训笔记</title>
    <link href="http://123.57.158.5/2020/12/28/First-Aid-Elementary-Course/"/>
    <id>http://123.57.158.5/2020/12/28/First-Aid-Elementary-Course/</id>
    <published>2020-12-28T14:52:35.000Z</published>
    <updated>2021-05-23T02:34:37.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>半个月前我报名了北京红会的16学时急救课程，27，28号两天是培训时间，地点是在门头沟区的心田培训中心。主要学习内容是CPR（心肺复苏）、AED的使用、常见疾病处置、创伤处理等。对我来说是一次很有收获的体验，开这篇文章记录一下参加课程的笔记、心得。</p><img src="/2020/12/28/First-Aid-Elementary-Course/11c0950fb47eebdb.jpeg" alt="11c0950fb47eebdb" style="zoom:67%;"><p><strong>红十字会起源</strong>：亨利杜南目睹索尔费里诺战役后，成立伤兵救护委员会，后演变为日内瓦公约</p><h2 id="day1-徒手心肺复苏"><a href="#day1-徒手心肺复苏" class="headerlink" title="day1 徒手心肺复苏"></a>day1 徒手心肺复苏</h2><p>抢救生命的绿色通道“生存链”</p><div class="mermaid">graph LR;A[应急反应系统识别和启动]--&gt;B[高质量心肺复苏]B--&gt;C[快速除颤]C--&gt;D[基础及高级急救医疗服务]D--&gt;E[高级生命维护和骤停后护理]</div><p>救护员课程重点学习心肺复苏和除颤</p><p><strong>猝死</strong>：平素身体健康或貌似健康的患者，在出乎意料的短时间内，因自然疾病而突然死亡即为猝死。对于死亡时间，世卫组织定义从发病到死亡6小时内，一般认为1小时内死亡者多为心源性猝死。</p><p><strong>心肺复苏</strong>：指救护员在现场为心脏骤停患者实施胸外按压和人工呼吸。</p><p>我国每年有约54万人死于心脏猝死，如果经过有效的心肺复苏，部分患者可存活。</p><p>黄金四分钟：</p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229005456937.png" alt="image-20201229005456937"></p><p>判断+救治步骤：</p><ol><li><p>环境安全，做好防护。</p></li><li><p>轻拍患者双肩，呼喊（“先生先生，您怎么了？”），确认有无意识。解开衣服，仔细观察呼吸（1001-1007），确认有无呼吸（或仅仅是喘息）</p></li><li><p>无呼吸无意识，大声呼叫，让人帮忙拨打120，取AED。表明救护员身份并寻求援助。</p></li><li><p>立即进入<strong>心肺复苏</strong>程序，C-A-B。（如果是溺水则是A-B-C，要先保持气道畅通）</p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229005703564.png" alt="image-20201229005703564"></p><blockquote><p>心肺复苏CAB分别代表:1.C: circulation循环，即要求胸外按压，保证心脏射血，体内血液循环。2.A: airway气道，即要求保持气道通畅，要注意清理口腔呕吐物，采取仰颌抬颏法使呼吸顺畅。3.B: breathing呼吸，即口对口人工呼吸，每一次吹气要看到胸廓有起伏，但也不要用力过猛。保证氧气输送到肺组织。</p></blockquote><p>心肺复苏注意事项：</p><ul><li><p>按压位置位于两乳头连线中点的胸骨处，双手十指相扣，掌根对着胸骨，手臂不弯曲，使用上半身力量，髋关节为轴。</p></li><li><p>按压深度约5-6cm（一般胸骨到背部厚度三分之一）</p></li><li><p>每分钟100~120次</p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229005818116.png" alt="image-20201229005818116"></p></li><li><p>按压时时刻注意患者头部，有反应则停止并判断情况。</p></li><li><p>医生没到/病人没醒按压不能停！！！！ （人工呼吸、使用AED除外）</p></li><li><p>人工呼吸前检查气道，口腔无异物，仰额抬颏法。嘴包嘴吹气，持续1秒</p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229005855463.png" alt="image-20201229005855463"></p></li><li><p>吹压比/吹气比：<strong>30：2</strong>（30次按压，两次人工呼吸）。<font color="red">持续五个周期的30：2的心肺复苏</font>，再检查患者反应和呼吸（脖子动脉）</p></li></ul></li><li><p>AED抵达后，立即开机，将电极贴对应身体裸露位置，右边锁骨下面，一处左边乳房下面。前胸后背也可以。</p></li><li><p>按照AED提示除颤，随后根据自己节奏30：2心肺复苏。</p></li><li><p>呼吸心跳恢复后，调整侧卧位</p></li></ol><p><img src="/2020/12/28/First-Aid-Elementary-Course/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5" alt="img"></p><p>心肺复苏成功的标志：恢复自主心跳自主呼吸及意识</p><p>可参考表现：眼球活动、睫毛放射、四肢活动；瞳孔扩大逐渐缩回变小；有知觉、反应、脸色转红等</p><blockquote><p>自动体外除颤器又称自动体外电击器、自动电击器、自动除颤器、心脏除颤器及傻瓜电击器等，是一种便携式的医疗设备，它可以诊断特定的心率失常，并且给予电击<a href="https://baike.baidu.com/item/%E9%99%A4%E9%A2%A4/3310526">除颤</a>，是可被非专业人员使用的用于抢救心脏骤停患者的医疗设备。在心跳骤停时，只有在最佳抢救时间的“黄金4分钟”内，利用自动体外除颤器（AED）对患者进行除颤和心肺复苏，才是最有效制止猝死的办法。</p></blockquote><p><strong>异物阻塞处置</strong>：</p><p>腹部冲击法（海姆立克法）冲击患者腹部，使横膈肌急速提升，呼吸道压力骤升，异物排出。（极端场景才使用，因为可能造成脏器损伤，一般拍拍背就行）</p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229010943066.png" alt="image-20201229010943066" style="zoom:50%;"><p>问题及其他病情处置：</p><ol><li>隔着薄衣服可以做心肺复苏吗？可以，但要保证按压高质量。</li><li>有呼吸无意识怎么处置？恢复安全体位即可</li><li>癫痫发作怎么处置？腾出空间，让其自我恢复，不做处理</li><li>患者倒地后判断呼吸要通过身体起伏而不是脉搏？1）脉搏非专业人士判断不准 2）判断呼吸没有，心跳一定是停止的，因为心跳停止后呼吸才停。</li></ol><h2 id="day2-创伤现场救治"><a href="#day2-创伤现场救治" class="headerlink" title="day2 创伤现场救治"></a>day2 创伤现场救治</h2><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229014414580.png" alt="image-20201229014414580"></p><p>流血包扎原则：</p><ul><li><p>包扎前上敷料，从远心端–&gt;近心端（毒蛇咬伤则相反）包扎。手臂包扎使用螺旋包扎法，手背手心使用八字包扎法，关节包扎使用人字形包。胸部、腹部用三角巾包扎。</p><p><em>图为胸部包扎处理</em></p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229014508145.png" alt="image-20201229014508145"></p></li><li><p>包扎结束再外侧（大拇指那边一侧）</p></li><li><p>包扎时候绷带朝上拿</p></li><li><p>包扎完检查末端血液循环（比如按压指尖）</p></li><li><p>使用三角巾悬挂</p></li></ul><p>骨折处理：</p><ul><li>伤侧房足够的软垫、如果是开放骨折不能清理，只制动不复位</li><li>使用三角巾悬挂</li><li>加制动带</li></ul><p>三角巾悬挂原则：</p><p>如果是上臂、前臂受伤使用大悬臂带，如果是肢末端（手，锁骨）使用三角叫悬臂带</p><p><em>图为大悬臂带</em></p><p><img src="/2020/12/28/First-Aid-Elementary-Course/image-20201229014614803.png" alt="image-20201229014614803"></p><p>具体其他的包扎 悬挂方法建议看视频复习巩固。细节不好文字描述。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这两天真的有点高强度，尤其基地位于门头沟，往返三小时多，回宿舍就累趴了。（ps：第一次做门头沟S1线，培训小伙伴告知我是磁悬浮的，怪不得很舒适平稳。沿途景色不错）</p><p>笔记到这里就结束了，这次课程收获满满，确实学到了很多急救的干货，最重要的是当家人朋友出现紧急状况就知道该怎么做了。如果路遇紧急情况我应该也能尽一份力。</p><p>感谢红会的老师们，真的很耐心很温暖很细心！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;半个月前我报名了北京红会的16学时急救课程，27，28号两天是培训时间，地点是在门头沟区的心田培训中心。主要学习内容是CPR（心肺复苏）、A</summary>
      
    
    
    
    <category term="生活" scheme="http://123.57.158.5/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="CPR" scheme="http://123.57.158.5/tags/CPR/"/>
    
    <category term="AED" scheme="http://123.57.158.5/tags/AED/"/>
    
  </entry>
  
  <entry>
    <title>Linux1基本命令(Ubuntu)</title>
    <link href="http://123.57.158.5/2020/12/16/linux-go1/"/>
    <id>http://123.57.158.5/2020/12/16/linux-go1/</id>
    <published>2020-12-16T11:27:07.000Z</published>
    <updated>2021-05-23T02:34:39.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端的基本操作"><a href="#终端的基本操作" class="headerlink" title="终端的基本操作"></a>终端的基本操作</h2><p>什么是TTY?</p><blockquote><p>在Linux中，TTY也许是跟终端有关系的最为混乱的术语。TTY是TeleTYpe的一个老缩写。Teletypes，或者teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，和古老的电报机区别并不是很大。之后，当计算机只能以批处理方式运行时（当时穿孔卡片阅读器是唯一一种使程序载入运行的方式），电传打字机成为唯一能够被使用的“实时”输入/输出设备。最终，电传打字机被键盘和显示器终端所取代。</p><p>在Linux 系统中，计算机显示器通常被称为控制台终端(Console）。它仿真了类型为Linux的一种终端(TERM=Linux），并且有一些设备特殊文件与之相关联：tty0、tty1、tty2 等。当你在控制台上登录时，使用的是tty1。使用Alt+[F1—F6]组合键时，我们就可以切换到tty2、tty3等上面去。tty1–tty6等称为虚拟终端，而tty0则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上（这时也叫控制台终端）。因此不管当前正在使用哪个虚拟终端，系统信息都会发送到控制台终端上。/dev/console即控制台，是与操作系统交互的设备，系统将一些信息直接输出到控制台上。只有在单用户模式下，才允许用户登录控制台。</p></blockquote><p><code>ctrl+alt+f1</code>：回到图形界面</p><p><code>ctrl+alt+f2</code>：对应终端2(tty2)，f3-f6分别对应tty3-tty6</p><p>但是我们一般常用图形模式的终端。调用方式<code>Ctrl+Alt+T</code></p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>打开终端后会自动出现命令行提示符</p><p>比如<code>scheelite@scheelte-VirtualBox:~$</code></p><p><code>scheelite</code>是当前用户的名字，Linux是多用户的操作系统，@后面是主机名，：是分隔符，~是当前所在目录的名字，$指示用户拥有的权限，表示普通用户，如果是#怎是root用户</p><p>使用<code>sudo su</code>切换root用户，切换后显示<code>root@scheelte-VirtualBox:/home/scheelite#</code></p><p>使用<code>whoami</code>命令可以获知当前用户名，<code>hostname</code>获知主机名</p><h3 id="基本命令使用"><a href="#基本命令使用" class="headerlink" title="基本命令使用"></a>基本命令使用</h3><p><code>date</code>显示当前时间，<code>ls</code>显示当前所有的目录</p><p>参数是写在命令之后的一些补充选项，空格隔开。</p><p><strong>短参数</strong>：短横线后面加一个字母，可以一次性加多个短参数，也可以合并写。参数的值 <code>-p 10</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">command -p -a -T -c</span><br><span class="line">command -paTC</span><br><span class="line"></span><br><span class="line">显示所有文件（包括隐藏文件）</span><br><span class="line">ls -a</span><br></pre></td></tr></table></figure><p><strong>长参数</strong>：以两个短横线开始，只能以空格隔开。参数的值<code>--parameter=10</code></p><p>可以长短参数结合使用</p><p><strong>其他参数</strong>：没有绝对的准则。例如ls命令 后面带了一个参数的话，这是一个目录的路径名的话，那么就会列出此目录下的文件，例如 <code>ls Code</code></p><p>Tab键可以补全命令/路径，敲两下tab键。</p><h3 id="命令行快捷键"><a href="#命令行快捷键" class="headerlink" title="命令行快捷键"></a>命令行快捷键</h3><p>上下键切换历史命令</p><p><code>ctrl+r</code>查找使用过的命令；</p><p><code>history</code>显示所有输入的命令；</p><p><code>ctrl+l</code>清屏；</p><p><code>ctrl+d</code>给终端传递EOF（文件结束符）；</p><p><code>shift+PgUp</code>用于向上滚屏</p><p><code>ctrl+a</code>/<code>home </code>     <code>ctrl+e</code>/<code>end</code>光标跳到一行命令的开始/结尾</p><p><code>ctrl+u</code>/<code>ctrl+k</code>删除光标左侧/右侧的命令</p><p><code>ctrl+w</code>删除光标左侧的一个“单词”（空格隔开的一部分）</p><p><code>ctrl+y</code>用于粘贴上面u/k/w删除的字符串</p><h2 id="Linux下的文件操作"><a href="#Linux下的文件操作" class="headerlink" title="Linux下的文件操作"></a>Linux下的文件操作</h2><h3 id="Linux下文件目录组织形式"><a href="#Linux下文件目录组织形式" class="headerlink" title="Linux下文件目录组织形式"></a>Linux下文件目录组织形式</h3><ul><li>在Linux中<font color="red">一切都是文件</font>，不像windows分为文件和非文件，甚至连目录也是文件</li><li>Linux中只有一个根目录就是<code>/</code>，最顶级的目录，不同于windows很多个盘：<code>C:\</code>等</li><li>windows中用反斜杠表明目录层级和包含关系，而Linux中用<code>/</code>来表示，例如：<code>/usr/bin</code></li><li>一般在Linux命令目录时尽量不使用空格或其他特殊符号，尽量用小写字母</li><li>linux中以点开头的文件是隐藏文件。但是<code>.</code>（一个点）表示当前目录，<code>..</code>（两个点）表示上一级目录</li></ul><p>/bin：包含用户可执行的二进制文件；/boot: 包含linux启动密切相关的文件；/etc：系统配置文件；/home: 用户私人目录；/lib：包含被程序调用的库文件，<code>.os</code>结尾，类似于win的dll；/media: 访问外设（usb等）内容；/mnt：临时挂载一些装置；/opt：用于安装第三方软件；/root：超级用户目录；/sbin系统级重要可执行文件；/usr：安装大部分用户需要调用的程序 ….；/var：程序日志文件</p><p><code>pwd</code>命令 获知当前目录</p><p><code>which</code>命令获取命令的可执行文件的位置，参数为命令，如<code>which pwd</code>获取pwd命令可执行文件的位置。</p><h3 id="ls、cd、du命令"><a href="#ls、cd、du命令" class="headerlink" title="ls、cd、du命令"></a>ls、cd、du命令</h3><p>不带参数列出非隐藏文件，-a参数列出所有文件，-A列出不带<code>.</code>和<code>..</code>的目录，</p><p>-l参数列出文件详细信息, <code>total xx</code> 表示当前目录的总字节数（k）</p><p><img src="/2020/12/16/linux-go1/image-20201231122820898.png" alt="image-20201231122820898"></p><p>里面每一行的内容分别代表：文件权限、链接数目、文件所有者、文件所在的群组、文件大小（仅指目录文件的大小）、文件修改时间、名称</p><p>可以很多参数合并一起使用如<code>ls -ltah</code>显示所有文件详情</p><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p>change directory 切换路径</p><p><code>cd ~</code>或直接<code>cd</code>会到直接回到家目录</p><h4 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h4><p>disk usage, du可以让我们直到文件和目录所占的空间大小；相比<code>ls -l</code>命令，du命令统计的才是真正的文件大小</p><p><code>-h</code>便于阅读模式，<code>-a</code>显示所有目录、文件的大小，<code>-s</code>直接出现总大小</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>syslog文件位于<code>/var/log</code>这个目录中，记录了电脑的所有事情的日志。</p><h4 id="cat和less命令"><a href="#cat和less命令" class="headerlink" title="cat和less命令"></a>cat和less命令</h4><p>cat命令和less命令：显示文件内容，不能对内容进行修改。</p><p>cat一次性在终端显示文件所有内容，加上想要显示的文件路径即可：<code>cat syslog</code>，中间加上<code>-n</code>参数显示行号。适合显示小文件</p><p>less命令分页显示文件内容。空格键翻页显示，<code>↓</code>/<code>enter</code>显示下一行，<code>d</code>前进半个屏幕，<code>b</code>向上一页，<code>y</code>/<code>↑</code>显示到上一行，<code>=</code>等号显示你在当前文件中的位置，h键进入使用手册，<code>/</code>进入搜索模式（按n键在结果中跳转，shift+n往上跳转），</p><h4 id="head和tail命令"><a href="#head和tail命令" class="headerlink" title="head和tail命令"></a>head和tail命令</h4><p>显示文件开头和结尾几行。</p><p>可以加上参数<code>tail -n 5 syslog</code>显示末尾五行，</p><p>配合<code>-f</code>参数可实时追踪文件的更新。</p><p><code>tail -f syslog</code>实时观察syslog文件的增加内容，默认一秒检查是否有更新，也可指定间隔参数，比如<code>tail -f -s 4 syslog</code>设置为4秒</p><h4 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h4><p>touch命令直接更跟路径，创建空白文件</p><p>mkdir创建新文件夹，可以用<code>-p</code>来递归创建目录结构：<code>mkdir -p one/two/three</code></p><h4 id="拷贝、移动文件或目录"><a href="#拷贝、移动文件或目录" class="headerlink" title="拷贝、移动文件或目录"></a>拷贝、移动文件或目录</h4><p>cp命令拷贝，<code>cp file file_copy</code>拷贝file_copy文件，可以换为目录名就可以复制到那里去并改名</p><p>拷贝目录需要在cp命令之后加上<code>-r</code>或者<code>-R</code>参数，目录中所有内容被拷贝</p><p><strong>使用通配符*</strong></p><p>用于代替任何字符，和正则一样。<code>cp *.txt folder</code>把当前目录下的所有txt文件拷贝到folder目录中取</p><p>mv命令移动，使用类似cp，但是移动目录不需要添加额外的参数，和移动文件一样，同样也可以使用通配符。</p><p>mv命令还可以重命名，使用方法一样。</p><h4 id="删除文件和目录"><a href="#删除文件和目录" class="headerlink" title="删除文件和目录"></a>删除文件和目录</h4><p>rm命令用于删除文件和目录，但是不可撤销。直接加文件名</p><p>加上<code>-i</code>参数会询问是否需要删除，<code>-r</code>参数递归（recursive）删除，删除目录</p><h3 id="文件中的软链接和硬链接"><a href="#文件中的软链接和硬链接" class="headerlink" title="文件中的软链接和硬链接"></a>文件中的软链接和硬链接</h3><p>ln命令用于在文件之间创建链接。</p><p>Linux下有两种链接类型：软链接（Symbolic link）和硬链接（Physical link）。Linux文件有三部分：文件名、权限和文件内容。</p><p><strong>Linux文件存储</strong>：每个文件的文件内容被分配到一个inode，因此每个文件名都绑定到它的文件内容（用inode标识）</p><p><strong>硬链接原理</strong>：使链接的两个文件共享同样的文件内容，就是同样的inode。如果两个文件之间有了硬链接，修改文件修改的是同一块内容。硬链接一般只能创建指向文件的硬链接，而<strong>软连接</strong>可以指向文件和目录。</p><p><code>ln file1 file2</code>这个命令创建了一个file1的硬链接file2。</p><p><em>此时如果通过<code>ls -i</code>来查看文件相关的inode信息，会发现二者指向了同一个inode</em></p><p>对于硬链接来说，删除任意一方文件，共同指向的文件内容并不会从硬盘上被删除，只有同时删除，该inode才会被删除。</p><p><img src="/2020/12/16/linux-go1/image-20210102142105447.png" alt="image-20210102142105447"></p><p>第一列是inode信息，第三列中数字为2，对于文件来说指的是有相同inode号的文件数。（对于目录，指的是目录下的文件数）</p><p><strong>软链接</strong>类似与windows下的快捷方式。创建软链接需要带上<code>-s</code>参数</p><p><em>图示创建了file3软链接，链接到file1</em></p><p><img src="/2020/12/16/linux-go1/image-20210102142711614.png" alt="image-20210102142711614"></p><p>如果删掉了file1，file2就会失效。</p><h2 id="Linux下的权限管理"><a href="#Linux下的权限管理" class="headerlink" title="Linux下的权限管理"></a>Linux下的权限管理</h2><p>在Ubuntu系统中可以用sudo(Substitute User DO)命令暂时成为root超级用户。</p><p><code>sudo su</code>切换超级用户，输入exit推出也可以<code>sudo</code>后面直接接待执行命令</p><p><code>adduser username</code>命令添加用户</p><p><code>passwd username</code>命令修改用户密码</p><p><code>deluser username</code>命令删除用户，直接删除，谨慎使用！</p><h3 id="用户群组管理"><a href="#用户群组管理" class="headerlink" title="用户群组管理"></a>用户群组管理</h3><p>如果不设置群组的话，默认是创建一个和用户名一样的群组。当群组多的时候则需要进行管理。</p><p><code>addgroup groupname</code>命令添加新的群组；<code>usermod</code>命令，<code>-l</code>参数可以用于修改用户名，<code>-g</code>参数可用来修改用户的群组：<code>usermod -g groupname username</code></p><p><code>groups username</code>查看用户的所在群组<br><em>添加用户到多个群组<br><code>usermod -G group1,group2,group3 username</code>，<code>-aG</code>参数可以追加而不是移动到这些群组</em></p><p><code>delgroup groupname</code>删除群组</p><h3 id="文件权限设置"><a href="#文件权限设置" class="headerlink" title="文件权限设置"></a>文件权限设置</h3><p><code>chown newuser file</code>命令改变文件所有者，但是文件所属群组依旧不变</p><p><code>chgrp newgroup file</code>命令改变群组，或者<code>chown username:groupname file</code>也可以同时改变群组和所有者</p><p><code>chown</code>的<code>-R</code>参数递归设置子目录和子文件，配合上面的方法使用</p><h4 id="修改访问权限"><a href="#修改访问权限" class="headerlink" title="修改访问权限"></a>修改访问权限</h4><p><strong>权限的原理</strong>：Linux系统中，每个文件和目录都有一系列权限属性，在<code>ls -l</code>运行的第一列信息就是访问权限符。</p><p>第一个字符中：<code>-</code>表示普通文件；<code>d</code>表示目录；<code>l</code>表示软链接文件</p><img src="/2020/12/16/linux-go1/image-20210102152128235.png" alt="image-20210102152128235" style="zoom:50%;"><p>后面的字符中，<code>r</code>可读，<code>w</code>可写，<code>x</code>可执行/可读（对于目录），如果相应位置有字母，表示有相应的权限，短横<code>-</code>表示没有相应权限</p><p><img src="/2020/12/16/linux-go1/image-20210102152505598.png" alt="image-20210102152505598"></p><p>例如file1这个文件<code>-</code>表示普通文件，<code>rw-</code>在sheelite用户下，可读可写，非可执行文件，第二个<code>rw-</code>scheelite群组其他用户也可读可写，不可执行，<code>r--</code>其他用户只能读该文件</p><h4 id="chmod命令改变文件的访问权限"><a href="#chmod命令改变文件的访问权限" class="headerlink" title="chmod命令改变文件的访问权限"></a>chmod命令改变文件的访问权限</h4><p>Linux系统对每种权限（r、w和x）分配了对应的数字</p><table><thead><tr><th>权限</th><th>数字</th></tr></thead><tbody><tr><td>r</td><td>4</td></tr><tr><td>w</td><td>2</td></tr><tr><td>x</td><td>1</td></tr></tbody></table><p>要合并这些权限，就需要简单的数字相加；比如6表示有读和写的权限</p><img src="/2020/12/16/linux-go1/113366367897643514.jpg" alt="113366367897643514" style="zoom:33%;"><p>用三组数字来表示这些权限，例如640：</p><ul><li>6 文件所有者有读写权限</li><li>4 文件所在群组其他用户具有读的权限</li><li>0 除此之外其他用户没有任何权限</li></ul><p><code>chmod 640 file1</code>修改文件权限：</p><p><img src="/2020/12/16/linux-go1/image-20210102153745678.png" alt="image-20210102153745678"></p><p><strong>用字母划分权限</strong></p><p><code>chmod u+rx file1</code>对文件的所有者增加读和运行的权限</p><p><code>chmod g+r o-r file</code>文件file的群组其他用户增加读的权限，其他用户移除读的权限</p><p>配合<code>-R</code>参数可以递归修改目录及其中的文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;终端的基本操作&quot;&gt;&lt;a href=&quot;#终端的基本操作&quot; class=&quot;headerlink&quot; title=&quot;终端的基本操作&quot;&gt;&lt;/a&gt;终端的基本操作&lt;/h2&gt;&lt;p&gt;什么是TTY?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Linux中，TTY也许是跟终端有关系的最</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="http://123.57.158.5/tags/Linux/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Terminal" scheme="http://123.57.158.5/tags/Terminal/"/>
    
    <category term="Ubuntu" scheme="http://123.57.158.5/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法1查找与排序</title>
    <link href="http://123.57.158.5/2020/11/08/%E7%AE%97%E6%B3%951/"/>
    <id>http://123.57.158.5/2020/11/08/%E7%AE%97%E6%B3%951/</id>
    <published>2020-11-07T17:18:13.000Z</published>
    <updated>2021-05-23T02:34:41.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><strong>判断时间复杂度</strong><br>时间复杂度判断占用时间<br>快速判断算法复杂度：</p><ol><li>   确定问题规模n</li><li>   循环减半过程 –&gt; logn</li><li>   K层关于n的循环 —&gt;n<sup>k</sup><br>复杂情况：根据算法执行过程判断</li></ol><p><strong>判断空间复杂度</strong><br>评估算法内存占用大小的式子，表达方式与时间复杂度完全一样</p><ol><li>   算法使用了几个变量：O(1)</li><li>   算法使用了长度为n的一维列表：O(n)</li><li>   算法使用了m行n列的二维列表：O(mn)<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2>递归的两个特点：1.调用自身；2.结束条件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">func1(x-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">func2(x+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">func3(x-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func4</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line">func4(x-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>所以func3和func4是递归，x为正整数，func3会连续输出x到1，func4会输出1 到x<h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2>把盘子从a移动到c</li></ol><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201108012255921.png" alt="image-20201108012255921"></p><p>这样思考过后，就把问题规模由n变成了n-1，这就是一种递归的思想。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">n,a,b,c</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        hanota问题。</span></span><br><span class="line"><span class="string">        n: 盘子数</span></span><br><span class="line"><span class="string">        a: 初始位置</span></span><br><span class="line"><span class="string">        b: 中转位置</span></span><br><span class="line"><span class="string">        c: 目标位置</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &gt;<span class="number">0</span>:</span><br><span class="line">        move(n-<span class="number">1</span>,a,c,b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;moving from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(a,c))</span><br><span class="line">        move(n-<span class="number">1</span>,b,a,c)</span><br><span class="line"></span><br><span class="line">move(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure><p>moving from a to c<br>moving from a to b<br>moving from c to b<br>moving from a to c<br>moving from b to a<br>moving from b to c<br>moving from a to c<br>共7次移动</p><p>汉诺塔移动次数递推式：h(x)=h(x-1)+1</p><h2 id="列表查找"><a href="#列表查找" class="headerlink" title="列表查找"></a>列表查找</h2><p><strong>查找</strong>：在一些数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程。<br><strong>列表查找（线性表查找）</strong>：从列表中查找指定元素</p><ul><li>输入：列表，待查找元素</li><li>输出： 元素下标（未找到返回None或者-1）<br>Python内置列表查找函数: index()<h3 id="顺序查找（Linear-Search）"><a href="#顺序查找（Linear-Search）" class="headerlink" title="顺序查找（Linear Search）"></a>顺序查找（Linear Search）</h3>顺序查找：线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或者搜索到列表最后一个元素为止。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_search</span>(<span class="params">val,li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i]==val:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="二分查找（Binary-Search）"><a href="#二分查找（Binary-Search）" class="headerlink" title="二分查找（Binary Search）"></a>二分查找（Binary Search）</h3></li></ul><p><strong>二分查找</strong>：又叫折半查找 ，从<font color="’red’">有序</font>列表的初始候选区li[0:n]开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">val, li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        val: 待查找值</span></span><br><span class="line"><span class="string">        li：有序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(li)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 候选区有值</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; val:</span><br><span class="line">            right = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 没查找到</span></span><br></pre></td></tr></table></figure><p>时间复杂度O(logn)</p><h3 id="二分与顺序查找比较"><a href="#二分与顺序查找比较" class="headerlink" title="二分与顺序查找比较"></a>二分与顺序查找比较</h3><p>为了证明二分查找比顺序查找效率要高，可以试验一下<br>写一个计算函数时间的装饰器，给两种方法加上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        t1=time.time()</span><br><span class="line">        result = func(*args,**kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; running time: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(func.__name__,t2-t1))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>算法比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wrappers <span class="keyword">import</span> time_wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@time_wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order_search</span>(<span class="params">val,li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        有序查找</span></span><br><span class="line"><span class="string">        val: 待查找值</span></span><br><span class="line"><span class="string">        li: 列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i] == val:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@time_wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">val, li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二分查找</span></span><br><span class="line"><span class="string">        val: 待查找值</span></span><br><span class="line"><span class="string">        li：有序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(li)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 候选区有值</span></span><br><span class="line">        mid = (left+right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; val:</span><br><span class="line">            right = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 没查找到</span></span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100000000</span>))</span><br><span class="line"><span class="built_in">print</span>(binary_search(<span class="number">123109</span>,li))</span><br><span class="line"><span class="built_in">print</span>(order_search(<span class="number">123109</span>,li))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：<br>binary_search running time: 0.0<br>123109<br>order_search running time: 0.04597640037536621<br>123109<br>内置列表查找函数index()用的是顺序查找，二分查找需要有序列表</p><h2 id="六种常见排序方法"><a href="#六种常见排序方法" class="headerlink" title="六种常见排序方法"></a>六种常见排序方法</h2><p>排序：将一组“无序”的记录序列调整为“有序”的记录序列<br>列表排序：将无序列表转变为有序列表</p><ul><li>输入：列表</li><li>输出：有序列表<br>内置排序函数：sort()</li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>列表每两个相邻的数，如果前面比后面大，则交换这两个数</li><li>一趟排序完成后，则无序区减少一个数，有序区增加一个数</li><li>代码关键点：趟、无序区范围<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        冒泡排序</span></span><br><span class="line"><span class="string">        li: 无序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 第i趟</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):  <span class="comment"># 遍历比较列表内数值</span></span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">li = [random.randint(<span class="number">0</span>, <span class="number">10000</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]  <span class="comment"># 10个随机数</span></span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"><span class="built_in">print</span>(bubble_sort(li))</span><br></pre></td></tr></table></figure>关键在于理解排序的过程，将列表中的每一个数依次比较。<br>时间复杂度O(n<sup>2</sup>)</li></ul><p>但是如果在某一趟过程中没有发生交换，说明已经结束排序。则需要改进算法，提高效率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        冒泡排序</span></span><br><span class="line"><span class="string">        li: 无序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 第i趟</span></span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-i-<span class="number">1</span>):  <span class="comment"># 遍历比较列表内数值</span></span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span> li</span><br><span class="line">        <span class="built_in">print</span>(li)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">9672</span>, <span class="number">9123</span>, <span class="number">4409</span>, <span class="number">9845</span>, <span class="number">4436</span>, <span class="number">98</span>, <span class="number">1768</span>, <span class="number">7077</span>, <span class="number">730</span>, <span class="number">5105</span>]</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"><span class="built_in">print</span>(bubble_sort(li))</span><br></pre></td></tr></table></figure><p>对于相同的列表，则将会减少循环次数，提高效率</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>一趟排序记录最小的数，放到第一个位置</li><li>再一趟排序记录列表无序区最小的数，放到第二个位置<br>…</li><li>算法关键点：有序区和无序区、无序区最小数的位置<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        排序算法，将每次查找过程中较小的数放在列表最左端</span></span><br><span class="line"><span class="string">        li: 待排序列表</span></span><br><span class="line"><span class="string">        return: li    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):  <span class="comment"># 第i趟</span></span><br><span class="line">        min_loc = i  <span class="comment"># 无序区第一个数开始查找</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(li)):</span><br><span class="line">            <span class="keyword">if</span> li[j] &lt; li[min_loc]:</span><br><span class="line">                min_loc = j</span><br><span class="line">        li[i], li[min_loc] = li[min_loc], li[i]</span><br><span class="line">        <span class="built_in">print</span>(li)</span><br><span class="line">    <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure>时间复杂度O(n<sup>2</sup>)</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>初始时手里（有序区）只有一张牌</li><li>每次（从无序区）摸一张牌，插入到手里已有牌的正确位置<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        插入排序，将无序区的数据依次取出，与有序区数据比较，然后放在合理的位置</span></span><br><span class="line"><span class="string">        li: 无序列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(li)):  <span class="comment"># 无序列表第一个数</span></span><br><span class="line">        temp = li[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; temp: <span class="comment">#如果有序区的数依次与无序列表第一个数比较，直到找到对应位置</span></span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j+<span class="number">1</span>] = temp</span><br><span class="line">    <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure></li></ul><p>时间复杂度O(n<sup>2</sup>)</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>快速排序：快</li><li>快速排序思路：<ul><li>取一个元素 p ，是元素p归为；</li><li>列表被p分成两部分，左边都比p小，右边都比p大；</li><li>递归完成排序</li></ul></li></ul><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201114212701000.png" alt="image-20201114212701000"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速排序-框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">data,left,right</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    data: 列表</span></span><br><span class="line"><span class="string">    left: 列表左边index</span></span><br><span class="line"><span class="string">    right: 列表右边right</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = partition(data,left,right)</span><br><span class="line">        quick_sort(data,left,mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(data,mid+<span class="number">1</span>,right)</span><br></pre></td></tr></table></figure><p>partition函数需要实现：<br>先提出列表的第一位，单独存储为a，从列表最右边开始依次找比a小的数，放在左边的空位，然后从左边找比a大的数填补右边的空位…依次执行，左右筛选完之后（left和right重合），把a防在空位中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">li, left, right</span>):</span></span><br><span class="line">    temp = li[left]  <span class="comment"># 将列表左边第一个数提出来</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;= temp:  <span class="comment"># 从右边依次找比temp小的数</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        li[left] = li[right]  <span class="comment"># 将找到的比temp小的数放在左边空位</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= temp:   <span class="comment"># 从左边找比temp大的数</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[right] = li[left]  <span class="comment"># 将找到的比temp大的数放在右边空位</span></span><br><span class="line">    li[left] = temp  <span class="comment"># 当左右相等 列表放置结束，将temp放在列表空位上</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">li, left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:  <span class="comment"># 递归调用每一部分列表，直到完成排序</span></span><br><span class="line">        mid = partition(li, left, right)</span><br><span class="line">        quick_sort(li, left, mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(li, mid+<span class="number">1</span>, right)</span><br></pre></td></tr></table></figure><p>快排的效率：</p><p>时间复杂度：O(n(logn))</p><p>存在的问题：</p><p>最坏情况，将倒叙的列表排序，时间复杂度接近O(n)了，但是这点可以通过随机取数解决</p><p>python在windows上递归最大深度为998，但是可以设置修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序前传-树与二叉树</p><ul><li>树是一种数据结构 比如：目录结构</li><li>树是一种可以递归定义的数据结构</li><li>树是由n个节点组成的集合：<ul><li>如果n=0，那是一颗空树；</li><li>如果n&gt;0，那存在一个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一个树。</li></ul></li></ul><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201119225548961.png" alt="image-20201119225548961"></p><p><strong>根节点</strong>：如图里的A</p><p><strong>叶子节点</strong>：不可分叉的节点，如图中的B C H I P Q…</p><p><strong>树的深度（高度）</strong>：看有几层，如图中是四层</p><p><strong>树的度</strong>：就是往下分了几个叉，比如E的度是2，如果说一整棵树，就是指分叉分得最多的节点的度，比如图中是A，度为6。</p><p><strong>孩子节点</strong>、<strong>父节点</strong>：不解释</p><p><strong>子树</strong>：树的一部分</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>就是度不超过的2的树，每个节点最多有两个孩子节点，两个孩子节点被区分为左孩子节点，右孩子节点</p><p><strong>满二叉树</strong>：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树</p><p><strong>完全二叉树</strong>：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201123235002681.png" alt="image-20201123235002681" style="zoom: 67%;"><p><strong>二叉树的存储排序</strong>（表达方式）</p><p>分链式存储方式（后面阐述）和<strong>顺序存储方式</strong></p><p>顺序存储类似于列表，挨个存储，存储之后可以找到，父节点与左右孩子节点的关系。</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201123235917151.png" alt="image-20201123235917151"></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>堆</strong>：一种特殊的完全二叉树结构</p><ul><li>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li><li>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li></ul><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201124224317521.png" alt="image-20201124224317521"></p><p><strong>堆的向下调整</strong>：假设节点的左右子树都是堆，但自身不是堆。可以通过一次向下的调整来将其变成一个堆(和较低层级元素交换形成大根堆或小根堆)</p><h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><p>过程：</p><ol><li><p>建立堆</p><p>从最低 最右 层级进行调整，构造成堆</p></li><li><p>得到堆顶元素，为最大元素</p></li><li><p>去掉堆顶元素，将堆最后一个元素放到堆顶，此时可通过一次向下调整重新使堆有序</p></li><li><p>堆顶元素为第二大元素</p></li><li><p>重复步骤3，直到堆变空</p></li></ol><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/55.gif" alt="55"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        堆向下调整过程</span></span><br><span class="line"><span class="string">        li: 待调整列表</span></span><br><span class="line"><span class="string">        low: 根节点元素</span></span><br><span class="line"><span class="string">        high: 最后一个节点元素</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low  <span class="comment"># 最开始i为根节点元素</span></span><br><span class="line">    j = i*<span class="number">2</span>+<span class="number">1</span>   <span class="comment"># j为i的左孩子</span></span><br><span class="line">    tmp = li[low]   <span class="comment"># 将根节点元素临时存储起来</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:  <span class="comment"># 只要j位置有数</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j+<span class="number">1</span>] &gt; li[j]:   <span class="comment"># 只要右孩子存在且大于左孩子</span></span><br><span class="line">            j = j+<span class="number">1</span>   <span class="comment"># j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span> li[j] &gt; tmp:  <span class="comment"># 如果j节点数大于i节点</span></span><br><span class="line">            li[i] = li[j]  <span class="comment"># j节点数上移</span></span><br><span class="line">            i = j   <span class="comment"># 继续下一层级</span></span><br><span class="line">            j = i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br></pre></td></tr></table></figure><p>开始<strong>构造（建立）堆</strong></p><p>需要从最后的父节点开始，最后一个节点的小标为n-1，可以求出其父节点为<code>(n-2)//2</code></p><p>之后<strong>挨个出数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((n-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line"><span class="comment"># i 为待调整堆的根节点位置</span></span><br><span class="line">        sift(li, i, n - <span class="number">1</span>)<span class="comment"># 到这里堆建立完成</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># i 指向当前堆的最后一个元素</span></span><br><span class="line">        li[<span class="number">0</span>], li[i] = li[i], li[<span class="number">0</span>]</span><br><span class="line">        sift(li, <span class="number">0</span>, i - <span class="number">1</span>) <span class="comment"># i已经被提上low的位置，high的位置所以变成了i-1</span></span><br></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)</p><h5 id="堆排序内置模块"><a href="#堆排序内置模块" class="headerlink" title="堆排序内置模块"></a>堆排序内置模块</h5><p>python内置模块——heapq</p><p> <strong>补充模块说明</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="comment"># q--&gt;queue 优先队列（小的先出或者大的先出</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">heapq.heapify(li)<span class="comment"># 建堆,建立的是小根堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)):</span><br><span class="line">    heapq.heappop(li)<span class="comment"># 挨个出数</span></span><br></pre></td></tr></table></figure><h4 id="堆排序——topk问题"><a href="#堆排序——topk问题" class="headerlink" title="堆排序——topk问题"></a>堆排序——topk问题</h4><p>现在有n个数，设计算法得到前k大的数。（k&lt;n)</p><p>解决思路：</p><ul><li>排序后切片     复杂度：O(nlogn+k)k可以忽略</li><li>排序LowB三人组      复杂度：O(kn) </li><li>堆排序思路        复杂度：O(nlogk)</li></ul><p>堆排序解决topk思路：</p><ol><li>取列表前k个元素建立一个小根堆，堆顶就是目前的第k大的树</li><li>依次向后遍历原列表，对列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一此调整</li><li>遍历列表所有元素后，倒序弹出堆顶</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift_k</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        向下调整</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low</span><br><span class="line">    j = i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    tmp = li[low]</span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>] <span class="keyword">and</span> j+<span class="number">1</span> &lt;= high:</span><br><span class="line">            j = j+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> li[j] &lt; tmp:</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = j*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span>(<span class="params">li, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        取出列表中最大的k个数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="comment"># 取出前k个数建立小根堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((k-<span class="number">2</span>)//<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        sift_k(li, i, k-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(li)</span><br><span class="line">    <span class="comment"># 遍历k后面的数，比li[0]大则替换且重新调整</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; li[<span class="number">0</span>]:</span><br><span class="line">            li[<span class="number">0</span>] = li[i]</span><br><span class="line">            sift_k(li, <span class="number">0</span>, k-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 出数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        li[i], li[<span class="number">0</span>] = li[<span class="number">0</span>], li[i]</span><br><span class="line">        sift_k(li, <span class="number">0</span>, i-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> li[<span class="number">0</span>:k]</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>假设现在的列表分两段有序，如何将其合并成一个有序列表。这样的合并操作就成为归并（merge）</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/27.gif" alt="GIF 2020-12-7 21-21-27"></p><p>归并函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">li, low, mid, high</span>):</span></span><br><span class="line">    i = low</span><br><span class="line">    j = mid+<span class="number">1</span></span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> li[i] &lt; li[j]:</span><br><span class="line">            tmp.append(li[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(li[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 两边肯定有一部分没有数了</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        tmp.append(li[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        tmp.append(li[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    li[low:high+<span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure><h4 id="使用归并"><a href="#使用归并" class="headerlink" title="使用归并"></a>使用归并</h4><ul><li>分解：将列表越分越小，直到分成一个元素</li><li>终止条件：一个元素是有序的</li><li>合并：将两个有序列表归并，列表越来越大</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">li, low, high</span>):</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:  <span class="comment"># 说明至少有两个元素，递归归并</span></span><br><span class="line">        mid = (low+high)//<span class="number">2</span></span><br><span class="line">        merge_sort(li, low, mid)</span><br><span class="line">        merge_sort(li, mid+<span class="number">1</span>, high)</span><br><span class="line">        merge(li, low, mid, high)   <span class="comment"># 调用归并方法</span></span><br></pre></td></tr></table></figure><p>每次归并是O(n)，所以时间复杂度是O(nlogn)。空间复杂度是O(n)</p><p>python的<code>sort()</code>使用的一种‘team sort’的算法，结合了插入排序与归并排序</p><h3 id="排序方法对比"><a href="#排序方法对比" class="headerlink" title="排序方法对比"></a>排序方法对比</h3><p>三种快速排序的时间复杂度都是O(nlogn)</p><p>一般情况下，就运行时间而言：快速排序&lt;归并排序&lt;堆排序</p><p>三种算法的缺点：</p><ul><li>快速排序：极端情况下排序效率低</li><li>归并排序：需要额外的内存开销</li><li>堆排序：在快的排序算法中仙骨笛较慢</li></ul><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201209144244938.png" alt="image-20201209144244938"></p><p>稳定性：稳定指的是排序中的两个相同的数，排序后相对其初始位置不发生改变。挨个比较的算法就是稳定的！！</p><h2 id="其他排序"><a href="#其他排序" class="headerlink" title="其他排序"></a>其他排序</h2><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序（Shell Sort）是一种分组插入排序算法。</p><ol><li><p>首先取一个整数d<sub>1</sub>=n/2，将元素分为d<sub>1</sub>个组，每组相邻两个元素之间的距离是d<sub>1</sub>，在各组内进行直接插入排序；</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/28.gif" alt="GIF 2020-12-14 20-48-28"></p></li><li><p>取第二个数d<sub>2</sub>=d<sub>1</sub>/2，重复上述分组排序过程，直到d<sub>i</sub>=1，即所有元素在同一组内进行直接插入排序。</p></li></ol><p>希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/11.gif" alt="GIF 2020-12-14 20-55-11"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_insert_sort</span>(<span class="params">gap, li</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; 这一部分采用的是插入排序的思想 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, <span class="built_in">len</span>(li)):</span><br><span class="line">        temp = li[i]</span><br><span class="line">        j = i - gap</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; temp:</span><br><span class="line">            li[j+gap] = li[j]</span><br><span class="line">            j -= gap</span><br><span class="line">        li[j+gap] = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 分组之后 各组采用插入排序 &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    d = n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> d &gt; <span class="number">0</span>:</span><br><span class="line">        shell_insert_sort(d, li)</span><br><span class="line">        d //= <span class="number">2</span></span><br></pre></td></tr></table></figure><p>时间复杂度与选取的gap序列有关</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>对列表进行排序，已知列表中的数范围都在0到100之间。设计时间复杂度为O(n)的算法</p><p>优点：比系统自带的<code>sort()</code>方法都快</p><p>缺点：消耗空间（需要100个数的列表），有限制（需要知道列表中数的范围）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coun_sort</span>(<span class="params">li,max_count=<span class="number">100</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计数排序，已知列表中的数的范围，新建0-最大数的顺序列表用于记录每个数的出现次数，从而排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    count_list = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_count+<span class="number">1</span>)] <span class="comment"># 生成一个长度为li的最大值的统计次数列表</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> li:</span><br><span class="line">        count_list[val] += <span class="number">1</span> <span class="comment"># 统计每个数出现的次数</span></span><br><span class="line">    li.clear()</span><br><span class="line">    <span class="keyword">for</span> index, count <span class="keyword">in</span> <span class="built_in">enumerate</span>(count_list): <span class="comment"># 遍历生成新的列表</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">            li.append(index)</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>在计数排序中，如果元素的范围比较大（比如在1到1亿之间），如何改造算法？</p><p>桶排序(Bucket Sort): 首先将元素分在不同的桶中，在对每个桶中的元素排序</p><p><img src="/2020/11/08/%E7%AE%97%E6%B3%951/image-20201229222547450.png" alt="image-20201229222547450"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span>(<span class="params">li, n=<span class="number">10</span>, max_num=<span class="number">10000</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">桶排序，将列表中的数分为10个桶，将每个桶中的数排序</span></span><br><span class="line"><span class="string">li:待排序列表</span></span><br><span class="line"><span class="string">n:桶个数</span></span><br><span class="line"><span class="string">max_num:列表最大数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建桶</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> li:</span><br><span class="line"><span class="comment"># 将列表中的数依次放入桶中，对于列表中的最大数，放入最后一个桶</span></span><br><span class="line">        i = <span class="built_in">min</span>(var//(max_num//n), n-<span class="number">1</span>)</span><br><span class="line">        buckets[i].append(var)</span><br><span class="line">        <span class="comment"># 将每个桶中元素进行排序</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets[i])-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> buckets[i][j] &lt; buckets[i][j-<span class="number">1</span>]:</span><br><span class="line">            buckets[i][j], buckets[i][j-<span class="number">1</span>] = buckets[i][j-<span class="number">1</span>], buckets[i][j]</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    li.clear()</span><br><span class="line">    <span class="keyword">for</span> buk <span class="keyword">in</span> buckets:</span><br><span class="line">        li.extend(buk)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>桶排序表现取决于数据的分布。也就是需要对不同数据排序时采取不同的分桶策略。</li><li>平均情况时间复杂度：O(n+k)，k约一个桶中元素个数。</li><li>最坏情况时间复杂度：O(n<sup>2</sup>k)</li><li>空间复杂度：O(nk)</li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>多关键字排序：假如现在有一个员工表，要求按照薪资排序，年龄相同的员工按照年龄排序。</p><p>思路：先按照年龄进行排序，再按照薪资进行稳定的排序</p><p>对于32、13、94、52、17、54、93是否可以看做多关键字排序（先看十位，后看个位）</p><p>在基数排序中，先排序个位，再排序十位！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redix_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基数排序，将列表中的数依次按个位、十位、百位...最高位排序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    max_digit = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(li))) <span class="comment"># 获取最大数的位数</span></span><br><span class="line">    t = <span class="number">0</span> <span class="comment"># t代表循环的次数</span></span><br><span class="line">    <span class="keyword">while</span> t &lt;= max_digit:</span><br><span class="line">        <span class="comment"># 每次都构建十个桶</span></span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> var <span class="keyword">in</span> li:</span><br><span class="line">            i = (var//(<span class="number">10</span>**t)) % <span class="number">10</span> <span class="comment"># 获取列表中数对应位数上的值</span></span><br><span class="line">            buckets[i].append(var)</span><br><span class="line">        li.clear()</span><br><span class="line">        <span class="keyword">for</span> buk <span class="keyword">in</span> buckets:</span><br><span class="line">            li.extend(buk)</span><br><span class="line">       t += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>时间复杂度：（kn)</p><p>空间复杂度：（n+k)</p><p>k表示最大数位数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法复杂度&quot;&gt;&lt;a href=&quot;#算法复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法复杂度&quot;&gt;&lt;/a&gt;算法复杂度&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;判断时间复杂度&lt;/strong&gt;&lt;br&gt;时间复杂度判断占用时间&lt;br&gt;快速判断算法复杂度：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://123.57.158.5/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="数据结构与算法" scheme="http://123.57.158.5/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="http://123.57.158.5/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="查找算法" scheme="http://123.57.158.5/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络3传输层</title>
    <link href="http://123.57.158.5/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/"/>
    <id>http://123.57.158.5/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/</id>
    <published>2020-11-07T17:11:16.000Z</published>
    <updated>2021-05-23T02:34:43.883Z</updated>
    
    <content type="html"><![CDATA[<p>传输层只涉及到两个终端设备之间，路由器中没有这一层。实现的是终端之间的进程与进程的通信，与之前的Unix域套接字和共享内存等单机进程通信不同。</p><p><strong>端口</strong>（Port）用来标记计算机中不同的网路进程，使用16比特位表示（0-65535）</p><p>常用协议的端口</p><table><thead><tr><th>FTP</th><th>HTTP</th><th>HTTPS</th><th>DNS</th><th>FELNET</th></tr></thead><tbody><tr><td>21</td><td>80</td><td>443</td><td>53</td><td>23</td></tr></tbody></table><p>各层之间的相关协议：</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/clip_image002.jpg" alt="img"></p><h2 id="UDP协议详解"><a href="#UDP协议详解" class="headerlink" title="UDP协议详解"></a>UDP协议详解</h2><p>UDP（User Datagram Protocol: 用户数据报协议）</p><p>传输数据报时不拆分不合并</p><p>UDP在IP数据报内部</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/clip_image004.jpg" alt="img"></p><p>UDP协议首部分为16位源端口号、16位目的端口号、16位UDP长度、16位UDP校验和。剩下为UDP数据</p><ul><li><p>UDP是无连接协议，即发送数据前不需要建立连接</p></li><li><p>UDP不能保证可靠的交付数据</p></li><li><p>UDP是面向报文传输的，即直接传输UDP数据报的数据</p></li><li><p>UDP没有拥塞控制</p></li><li><p>UDP的首部开销很小      </p></li></ul><h2 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h2><p>TCP（Transmission Control Protocol: 传输控制协议）</p><p>TCP同样也在IP数据报内部</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/clip_image006.jpg" alt="img"></p><p><strong>特点：</strong></p><ul><li><p>TCP是面向连接的协议，即需要通信前建立连接</p></li><li><p>TCP的一个连接有两端（点对点通信）</p></li><li><p>TCP提供可靠的传输服务</p></li><li><p>TCP协议提供全双工的通信，即可同时发送或接收数据</p></li><li><p>TCP是面向字节流的协议。这里的流的指的是流出流入进程的字节序列，相对于数据报来说，是可以一个字节一个字节进行处理的。tcp数据可合并可分拆</p></li></ul><p><strong>TCP协议的首部</strong>：</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/clip_image008.jpg" alt="img"></p><p>（表格宽度代表位数）</p><p>固定有20个字节长度，即表格中的前五行</p><p><strong>序号</strong>范围0~2<sup>32</sup>-1，一个字节一个序号，代表了数据首字节字号</p><p><strong>确认号</strong>范围0~2<sup>32</sup>-1，一个字节一个序号，代表期望收到数据的首字节序号。一般来说确认号为N：则表示N-1序号的数据都已经收到</p><p><strong>数据偏移</strong>占4位：0~15，单位为32位字，即每一个偏移都可以表示4个字节的偏移，表示数据偏离首部的距离（因为TCP选项未知，需要存储数据偏移来找到真实数据位置）。15*4=60字节，最大数据便宜是60个字节，所以TCP首部是20~60字节范围</p><p><strong>TCP标记</strong>占6位，每位各有不同意义，分别是URG\ACK\PSH\PST\SYN\FIN</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/tcp.png" alt="tcp"></p><p><strong>窗口</strong>：占16位：0<del>2<sup>16</sup>-1，窗口指明对方发送的数据量。比如确认号是501，窗口是1000，表明501</del>1500这么多个字节的数据都是可以接收的。</p><p><strong>紧急指针</strong>：紧急数据（当URG=1启用)，指定紧急数据在报文的位置</p><p><strong>TCP选项</strong>：最多40个字节，用于支持TCP未来的拓展</p><h2 id="可靠传输的基本原理"><a href="#可靠传输的基本原理" class="headerlink" title="可靠传输的基本原理"></a>可靠传输的基本原理</h2><h3 id="停止等待协议（超时定时器）"><a href="#停止等待协议（超时定时器）" class="headerlink" title="停止等待协议（超时定时器）"></a>停止等待协议（超时定时器）</h3><p>为了简化讨论协议，简化为接收方和发送方。</p><p>无差错情况下，接收方发送消息，接收方收到后发送确认。在收到对方消息前都是停止等待状态。</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201209011832049.png" alt="image-20201209011832049"></p><p>出差错的情况下，发送方发送消息后，出现差错，接收方没有接收到，无法发送确认消息，等待一段时间后发送方重传消息。</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201209012107845.png" alt="image-20201209012107845"></p><p>确认消息丢失，同样发生超时重传</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201209012132010.png" alt="image-20201209012132010"></p><p>确认的消息很久才到，超时重传</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201209012315181.png" alt="image-20201209012315181"></p><p><strong>超时定时器</strong>：每发送一个消息，都需要设置一个定时器</p><p>小结：停止等待协议是最简单的可靠传输协议；停止等待协议对<font color="red">信道的利用效率</font>不高</p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>ARQ(Automatic Repeat reQuest: 自动重传请求) 。用于批量发送消息和确认</p><p><font color="red"><strong>滑动窗口</strong></font>：窗口里的数据都可以发送，只要窗口内的数据发送的确认号到达了，就往前继续滑动。不需要对里面的每个数据进行确认，而采用<font color="red"><strong>累计确认</strong></font>的方法。即只要收到某个消息的确认，说明之前的消息都已经确认了。</p><p>图中 数据5已经收到，窗口直接滑动到6继续发送。</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201209013106137.png" alt="image-20201209013106137"></p><h2 id="TCP协议的可靠传输"><a href="#TCP协议的可靠传输" class="headerlink" title="TCP协议的可靠传输"></a>TCP协议的可靠传输</h2><ul><li>TCP的可靠传输基于连续ARQ协议</li><li>TCP的滑动窗口是以字节为单位</li></ul><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201209151112625.png" alt="image-20201209151112625"></p><p>假设存在一个窗口大小为7的滑动窗口，收到确认号是22，那么滑动窗口从23开始。此时连续发送了23-26，收到确认号为24，如上图所示，窗口向前滑动两位。</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201209151330091.png" alt="image-20201209151330091"></p><p>如果出现了仅收到不连续确认号情况。如上图，此时23、24确认号未收到，需要从23开始重传。这样传输效率就不高，则需要一种方法提高传输效率，这就是<strong>选择重传</strong></p><h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><ul><li>选择重传需要指定需要重传的字节（通过字节的32位序号指定）</li><li>序号选择的是需要重传的边界，传输其间的字节流</li></ul><p>注意：选择重传是重传整个字节流，而不是单个字节。</p><h2 id="TCP协议的流量控制"><a href="#TCP协议的流量控制" class="headerlink" title="TCP协议的流量控制"></a>TCP协议的流量控制</h2><p>流量控制指让发送方发送速率不要太快。流量控制是使用滑动窗口来实现的</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201211212117045.png" alt="image-20201211212117045"></p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201211212449952.png" alt="image-20201211212449952"></p><p>再进行数据传输之后，接收方将窗口设置为0，停止传送。等待接收方处理完数据之后，发送调整窗口为1000的消息。此时如果该调整窗口的消息发生了丢失，两边都在等待，形成了死锁，该怎么办？（对于接受带ACK的这种确认消息才有超时重传机制，特殊消息不具有）</p><h3 id="坚持定时器"><a href="#坚持定时器" class="headerlink" title="坚持定时器"></a>坚持定时器</h3><ul><li>当发送方接收到窗口为0的消息，则启动坚持定时器</li><li>坚持定时器每隔一段时间发送一个窗口探测报文。（即便调整窗口的消息丢失也不会变成死锁）</li></ul><h2 id="TCP协议的拥塞控制"><a href="#TCP协议的拥塞控制" class="headerlink" title="TCP协议的拥塞控制"></a>TCP协议的拥塞控制</h2><ul><li>一条数据链路经过非常多的设备</li><li>数据链路中各个部分都有可能成为网路传输的瓶颈</li></ul><p>流量控制考虑点对点的通信量的控制，拥塞控制考虑整个网络，是全局性的考虑</p><p><strong>报文超时可以是判断拥塞的方法</strong></p><p>拥塞控制的两个算法：</p><h3 id="慢启动算法"><a href="#慢启动算法" class="headerlink" title="慢启动算法"></a>慢启动算法</h3><p>由小到大逐渐增加发送数据量，每收到一个保温确认，就加一。比如第一次发送1个报文，收到1次确认后，增发一次报文，第二次发送两个报文，以此类推1，2，4，8，16… 呈现指数增长。</p><p>当指数增长到<strong>慢启动阈值(ssthresh)<strong>，就不再增长了，进行</strong>拥塞避免算法</strong></p><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>维护一个拥塞窗口的变量；只要网络不拥塞，就试探着拥塞窗口调大。</p><p>假设前面提到发送报文到达了慢启动阈值16，收到16个报文的确认后，随后发送17个报文，18个报文，直到发生拥塞。</p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201214203005176.png" alt="image-20201214203005176" style="zoom:67%;"><p>拥塞控制可以保证网络不发生拥塞的情况下，更多得发送数据</p><h2 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h2><p>TCP首部标记中ACK\SYN\FIN，在TCP连接的建立中非常重要</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201217132914099.png" alt="image-20201217132914099"></p><p>三次握手的过程：</p><ol><li>发送方发送SYN=1,seq=x（同步位是1，序列号为x）的报文，表示请求建立连接</li><li>接收方收到后发送SYN=1,ACK=1,seq=y,ack=x+1（同步位为1，确认位为1，序列号为y，确认号为x+1)的报文，表示收到请求，确认号生效，建立连接</li><li>发送方发送ACK=1,seq=x+1，ack=y+1(确认位为1，序列号为x+1,确认号为y+1)的报文，连接建立成功。</li></ol><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201217134034435.png" alt="image-20201217134034435"></p><h3 id="为什么发送方要发出第三个确认报文呢？"><a href="#为什么发送方要发出第三个确认报文呢？" class="headerlink" title="为什么发送方要发出第三个确认报文呢？"></a>为什么发送方要发出第三个确认报文呢？</h3><p>避免已经失效的连接请求发送到对方，引起错误</p><p>如果第一次连接请求发送后超时，重发之后（假如两次握手建立起连接后），可能会建立起两次连接</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201217134552335.png" alt="image-20201217134552335"></p><h2 id="TCP连接的释放"><a href="#TCP连接的释放" class="headerlink" title="TCP连接的释放"></a>TCP连接的释放</h2><p>第一次挥手：发送方发送FIN=1,seq=u（终止位为1，序列号为u）的报文，表示准备连接释放，发送方进入断开连接的第一次等待状态</p><p>第二次挥手：接收方发送ACK=1,seq=v,ack=u+1(确认位为1，序列号为v，确认号为u+1)的报文，接收方进入关闭等待状态，但是此时接收方还可以继续进行数据传输给发送方。发送方接收到报文后进入断开连接的第二次等待状态。</p><p>第三次挥手：待发送方发送完数据后，就发送FIN=1,ACK=1,seq=w,ack=u+1（终止位为1，确认位为1，序列号为w，确认号为u+1）的报文，随后接收方进入最后确认状态</p><p>第四次挥手：发送方接受到报文后，随即发送ACK=1,seq=u+1,ack=w+1（确认位为1，序列号为u+1，确认号为w+1）的报文，发送方<font color="red">等待计时器</font>生效，随后进入关闭状态。</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201224163319872.png" alt="image-20201224163319872"></p><h3 id="等待定时器"><a href="#等待定时器" class="headerlink" title="等待定时器"></a>等待定时器</h3><p>对于等待定时器，会等待2倍MSL（Max Segment Lifetime）：最长报文段寿命</p><p>MSL建议设置为2分钟</p><p>在等待定时器作用期间不会释放端口（一个TCP连接会占用一个端口），要等待其结束才能重新复用该端口</p><p><strong>为什么需要2MSL</strong></p><p>2MSL一般是报文在网络中存活的最长时间</p><ol><li>确保发送方的ACK可以到达接收方，2MSL时间内没有收到，则接收方会重发报文（第三次挥手步骤）</li><li>确保当前连接的所有报文都已经过期</li></ol><h2 id="套接字与套接字编程"><a href="#套接字与套接字编程" class="headerlink" title="套接字与套接字编程"></a>套接字与套接字编程</h2><p>端口（Port）用来标记不同的网络进程，使用16个比特位表示（0~65535）</p><p>ip加端口的组合就可以用来指定网络中某一台主机的具体进程，这个组合又叫<strong>套接字</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;IP:Port&#125;</span><br></pre></td></tr></table></figure><p><strong>套接字（Socket）</strong>是抽象概念，表示TCP连接的一端。通过套接字就可以进行数据发送和接收</p><p>对与TCP连接就可以表示为两个套接字的连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP=&#123;Socket1:Socket2&#125;=&#123;&#123;IP:Port&#125;&#123;IP:Port&#125;&#125;</span><br></pre></td></tr></table></figure><p>服务端（左）和客户端（右）套接字编程过程</p><p><img src="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/image-20201224172347839.png" alt="image-20201224172347839"></p><p>实例：</p><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>():</span></span><br><span class="line">    <span class="comment"># 创建socket</span></span><br><span class="line">    s = socket.socket()</span><br><span class="line">    host = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">    port = <span class="number">8000</span></span><br><span class="line">    <span class="comment"># 绑定套接字</span></span><br><span class="line">    s.bind((host, port))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 监听，参数为backlog，代表已建立连接队列和未完成建立的连接队列数之和。</span></span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c, addr = s.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Connect Addr:&#x27;</span>, addr)</span><br><span class="line">        c.send(<span class="string">b&#x27;Welcome to my server&#x27;</span>)</span><br><span class="line">        c.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server()</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    s = socket.socket()</span><br><span class="line">    <span class="comment"># 连接套接字</span></span><br><span class="line">    s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># recv(bufsize),bufsize表示一次接收的最大数据量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Recv msg:&#123;&#125;,Client:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s.recv(<span class="number">1024</span>), i))</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        client(i)</span><br></pre></td></tr></table></figure><p>运行服务端之后，会自动开启监听，再运行客户端，连接套接字之后就可以通信了，此时服务端也可以知道客户端的地址信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8874)</span><br><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8875)</span><br><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8876)</span><br><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8877)</span><br><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8878)</span><br><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8879)</span><br><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8880)</span><br><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8881)</span><br><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8882)</span><br><span class="line">Connect Addr: (&#x27;127.0.0.1&#x27;, 8883)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">0</span></span><br><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">1</span></span><br><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">2</span></span><br><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">3</span></span><br><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">4</span></span><br><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">5</span></span><br><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">6</span></span><br><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">7</span></span><br><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">8</span></span><br><span class="line">Recv msg:<span class="string">b&#x27;Welcome to my server&#x27;</span>,Client:<span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>网络套接字对比域套接字</strong></p><p>使用网络套接字进行通信会经过四层模型的协议栈；域套接字不需要经过协议栈，适合单机间的通信。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;传输层只涉及到两个终端设备之间，路由器中没有这一层。实现的是终端之间的进程与进程的通信，与之前的Unix域套接字和共享内存等单机进程通信不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;端口&lt;/strong&gt;（Port）用来标记计算机中不同的网路进程，使用16比特位表示（0-65535</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://123.57.158.5/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>flask表单介绍</title>
    <link href="http://123.57.158.5/2020/10/17/flask%E8%A1%A8%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://123.57.158.5/2020/10/17/flask%E8%A1%A8%E5%8D%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-10-17T07:33:15.000Z</published>
    <updated>2021-05-23T02:34:37.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wtf表单介绍"><a href="#wtf表单介绍" class="headerlink" title="wtf表单介绍"></a>wtf表单介绍</h2><p>特点：</p><ul><li>集成wtforms</li><li>CSRF保护</li><li>与Flask-Uploads一起支持文件上传</li></ul><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Flask-WTF</span><br></pre></td></tr></table></figure><p>配置（CSRF保护）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config[<span class="string">&#x27;WTF_CSRF_SECRET_KEY&#x27;</span>] = <span class="string">&#x27;a random string&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="第一个表单模型"><a href="#第一个表单模型" class="headerlink" title="第一个表单模型"></a>第一个表单模型</h3><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 用户名 &quot;&quot;&quot;</span></span><br><span class="line">    username = StringField(label=<span class="string">&#x27;用户名&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="表单常用字段类型及渲染"><a href="#表单常用字段类型及渲染" class="headerlink" title="表单常用字段类型及渲染"></a>表单常用字段类型及渲染</h2><ul><li>label——label标签（如输入框前的文字描述）</li><li>default——表单的默认值</li><li>validators——表单验证规则</li><li>widget——定制界面显示方式（如：文本框、选择框）</li><li>description——帮助文字（在Django表单中使用的是help_text）</li></ul><p><strong>使用模板语法渲染表单内容</strong>：</p><ul><li><p>表单输入区域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; form.username &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>表单label：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; form.username.label.text &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>文本/字符串：</p><ul><li>StringField——字符串输入</li><li>PasswordField——密码输入</li><li>TextAreaField——长文本输入</li><li>HiddenField——隐藏表单域</li></ul><p>数值：</p><ul><li>FloatField——浮点数输入</li><li>IntegerField——整数输入</li><li>DecimalField——小数输入（更精确）</li></ul><p>选择：</p><ul><li>RadioField——radio单选</li><li>SelectField——下拉单选</li><li>SelectMutipleField——下拉多选</li><li>BooleanField——勾选（复选框）</li></ul><p>日期/时间：</p><ul><li>DateField——日期选择</li><li>DateTimeField——日期时间选择</li></ul><p>文件上传：</p><ul><li>FileField——文件单选</li><li>MultipleFileField——文件多选</li></ul><p>其他：</p><ul><li>SubmitField——提交按钮</li><li>FieldList——自定义的表单选择列表（如：选择用户对象）</li><li>FormField——自定义多个字段构成的选项</li></ul><p>from文件，app内引用该表单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, PasswordField, SubmitField</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 模拟登陆表单 &quot;&quot;&quot;</span></span><br><span class="line">    username = StringField(label=<span class="string">&#x27;用户名&#x27;</span>,description=<span class="string">&#x27;仅限英文大小写&#x27;</span>)</span><br><span class="line">    password=PasswordField(label=<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">    submit = SubmitField(label=<span class="string">&#x27;提交&#x27;</span>)</span><br></pre></td></tr></table></figure><p>app.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> form <span class="keyword">import</span> LoginForm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/form&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_form</span>():</span></span><br><span class="line">    form = LoginForm()</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;form.html&#x27;</span>,form=form)</span><br></pre></td></tr></table></figure><p>然后html中可以渲染表单内容</p><p><strong>也可以通过前面提到的宏来简化表单</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; form.username.label &#125;&#125;</span><br><span class="line">    &#123;&#123; form.username &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; form.password.label &#125;&#125;</span><br><span class="line">    &#123;&#123; form.password &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; form.submit &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/10/17/flask%E8%A1%A8%E5%8D%95%E4%BB%8B%E7%BB%8D/image-20201125224156148.png" alt="image-20201125224156148"></p><h2 id="通过表单来保存数据"><a href="#通过表单来保存数据" class="headerlink" title="通过表单来保存数据"></a>通过表单来保存数据</h2><ul><li><p>第一步：检测表单是否已经通过验证</p><p><code>form.validate_on_submit()</code></p></li><li><p>第二步：获取表单中传递过来的值</p><p><code>form.field_name.data</code></p></li><li><p>第三步：业务逻辑代码编写（可结合ORM）</p></li></ul><p>涉及到表单提交必然会有<strong>csrf保护</strong>，防止表单重复提交等风险。</p><p>Flask是默认开启CSRF保护的</p><p>关闭单个表单的CSRF保护（不推荐）：</p><p><code>form = LoginForm(csrf_enabled=False)</code></p><p>可能需要同步改写LoginForm的构造方法将参数顺利传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,csrf_enabled,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(csrf_enabled=csrf_enabled,*args,**Kwargs)</span><br></pre></td></tr></table></figure><p>全局关闭（不推荐）：</p><p><code>WTF_CSRF_ENABLED = False</code></p><p><strong>同步请求CSRF保护</strong></p><ul><li><p>模板中添加csrf_token</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方式一 --&gt;</span></span><br><span class="line">&#123;&#123; form.csrf_token &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- 方式二 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;hidden&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;csrf_token&#x27;</span> <span class="attr">vlaue</span>=<span class="string">&#x27;&#123;&#123; csrf_token() &#125;&#125;&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>异步请求（AJAX）CSRF保护</strong></p><ul><li><p>第一步：模板中添加csrf_token</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;csrf-token content=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt;</span></span></span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    var csrftoken=&quot;</span><span class="template-variable">&#123;&#123; <span class="name">csrf_token</span>() &#125;&#125;</span><span class="xml">&quot;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二步：填加X-CSRFToken头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> csrftoken = $(<span class="string">&#x27;meta[name=csrf-token]&#x27;</span>).attr(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"></span><br><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">    <span class="attr">beforeSend</span>: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, settings</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/^(GET|HEAD|OPTIONS|TRACE)$/i</span>.test(settings.type)</span><br><span class="line">          &amp;&amp; !<span class="built_in">this</span>.crossDomain)&#123;</span><br><span class="line">            xhr.setRequestHeader(<span class="string">&quot;X-CSRFToken&quot;</span>, csrftoken)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>通过表单传递用户数据并添加进入数据库：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;user_add&#x27;) &#125;&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加csrf保护 --&gt;</span></span><br><span class="line">    &#123;&#123; form.csrf_token &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; form.username.label &#125;&#125;</span><br><span class="line">        &#123;&#123; form.username &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; form.password.label &#125;&#125;</span><br><span class="line">        &#123;&#123; form.password &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; form.birthdate.label &#125;&#125;</span><br><span class="line">        &#123;&#123; form.birthdate &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; form.age.label &#125;&#125;</span><br><span class="line">        &#123;&#123; form.age &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; form.submit &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% if form.errors %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123; form.errors &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>forms.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, PasswordField, DateField, IntegerField, SubmitField</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddUser</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 新增用户 &quot;&quot;&quot;</span></span><br><span class="line">    username = StringField(label=<span class="string">&#x27;用户名&#x27;</span>, description=<span class="string">&#x27;仅限英文大小写&#x27;</span>)</span><br><span class="line">    password = PasswordField(label=<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">    birthdate = DateField(label=<span class="string">&#x27;生日&#x27;</span>)</span><br><span class="line">    age = IntegerField(label=<span class="string">&#x27;年龄&#x27;</span>)</span><br><span class="line">    submit = SubmitField(label=<span class="string">&#x27;提交&#x27;</span>)</span><br></pre></td></tr></table></figure><p>app.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, flash, redirect, url_for</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> form <span class="keyword">import</span> AddUser</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 配置数据库的连接参数</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;mysql://root:960423@127.0.0.1/flasker&#x27;</span></span><br><span class="line"><span class="comment"># 消息通知用到了session，基于安全的考虑需要加密</span></span><br><span class="line">app.secret_key = <span class="string">&#x27;abacdef&#x27;</span></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意添加提交方式method</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/add&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_add</span>():</span></span><br><span class="line">    form = AddUser()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        <span class="comment"># 获取数据</span></span><br><span class="line">        username = form.username.data</span><br><span class="line">        password = form.password.data</span><br><span class="line">        birthday = form.birthdate.data</span><br><span class="line">        age = form.age.data</span><br><span class="line">        <span class="comment"># 保存数据</span></span><br><span class="line">        user = User(username=username, password=password, birthday=birthday, age=age)</span><br><span class="line">        db.session.add(user)</span><br><span class="line">        db.session.commit()</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;index&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;add_user_form.html&#x27;</span>,form=form)</span><br></pre></td></tr></table></figure><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>步骤一：导入内置的表单验证器（或自定义）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired</span><br></pre></td></tr></table></figure><p>步骤二：配置到表单字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用自定义的表单验证器</span></span><br><span class="line">username=StringField(<span class="string">&#x27;用户名&#x27;</span>,validators=[InputRequired(), my_validator])</span><br></pre></td></tr></table></figure><p>内置表单的验证器：</p><ul><li><code>DataRequired/InputRequired</code>——必填</li><li><code>Email/URL/UUID</code>——电子邮箱/URL/UUID</li><li><code>Length(min=-1,max=-1,message=None)</code>——长度范围验证</li><li><code>EqualTo(filename, message=None)</code>——两个字段输入的值相等（如：密码确认）</li></ul><p>自定义表单验证器：</p><p>场景一：只在本表单中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    username = StringField(label=<span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_username</span>(<span class="params">self, field</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(field.data) &gt; <span class="number">50</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;不超过50个字符&#x27;</span>)</span><br></pre></td></tr></table></figure><p>场景二：在所用表单中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phone_validate</span>(<span class="params">form, field</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(field.data) &gt; <span class="number">50</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;不超过50个字符&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    username = StringField(label=<span class="string">&#x27;用户名&#x27;</span>,validators=[phone_validate])</span><br></pre></td></tr></table></figure><p>举个例子：</p><p>验证用户名为手机号，且密码不能为空（采用自带验证器）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddUser</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 新增用户 &quot;&quot;&quot;</span></span><br><span class="line">    username = StringField(label=<span class="string">&#x27;用户名&#x27;</span>, description=<span class="string">&#x27;仅限英文大小写&#x27;</span>)</span><br><span class="line">    password = PasswordField(label=<span class="string">&#x27;密码&#x27;</span>, validators=[DataRequired()])</span><br><span class="line">    birthdate = DateField(label=<span class="string">&#x27;生日&#x27;</span>)</span><br><span class="line">    age = IntegerField(label=<span class="string">&#x27;年龄&#x27;</span>)</span><br><span class="line">    submit = SubmitField(label=<span class="string">&#x27;提交&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在表单强制为validate_field的这种格式的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_username</span>(<span class="params">self, field</span>):</span></span><br><span class="line">        <span class="comment"># 自定义用户表单验证，强制输入为手机号</span></span><br><span class="line">        username = field.data</span><br><span class="line">        pattern = <span class="string">r&#x27;1[1-9]&#123;10&#125;$&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> re.search(pattern, username):</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;用户名必须为手机号&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><ul><li>方式一：不使用wtf实现</li><li>方式二：使用FileField并添加验证</li></ul><p>文件名称格式化：<code>werkzeug.utils.secure_filename</code></p><h3 id="不使用wtf"><a href="#不使用wtf" class="headerlink" title="不使用wtf"></a>不使用wtf</h3><ol><li><p>设置<code>&lt;form&gt;</code>的enctype</p><p><code>enctype=&quot;multipart/form-data&quot;</code></p></li><li><p>在视图函数中获取文件对象</p><p><code>f = request.files</code></p></li><li><p>保存文件</p><p><code>f.save(file_path)</code></p></li></ol><p>app.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, url_for, request</span><br><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> secure_filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/file_upload&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_upload</span>():</span></span><br><span class="line">    <span class="comment"># 获取当前温江路径，获得相对的存放上传文件的文件夹路径</span></span><br><span class="line">    media_path = os.path.join(os.path.dirname(__file__), <span class="string">&#x27;medias&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment"># 获取文件对象，字典格式</span></span><br><span class="line">        file = request.files[<span class="string">&#x27;icon&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> file:</span><br><span class="line">            <span class="comment"># 格式化文件名（主要是将文件名中的空格用下划线代替）</span></span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            file_path = os.path.join(media_path, filename)</span><br><span class="line">            <span class="comment"># 保存文件</span></span><br><span class="line">            file.save(file_path)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;file_upload.html&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;file_upload&#x27;) &#125;&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&#x27;submit file&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于文件目录可以在项目顶部配置：</p><p><code>app.config[&#39;UPLOAD_PATH&#39;]=os.path.join(os.path.dirname(__file__), &#39;medias&#39;)</code></p><p>在url中就可以通过<code>app.config[&#39;UPLOAD_PATH&#39;]</code>调取项目路径</p><h3 id="使用FileField并图片验证"><a href="#使用FileField并图片验证" class="headerlink" title="使用FileField并图片验证"></a>使用FileField并图片验证</h3><p><code>FileRequired</code>、<code>FileAllowed</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> flask_wtf.file <span class="keyword">import</span> FileField, FileRequired, FileAllowed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAvtarForm</span>(<span class="params">FlaskForm</span>):</span></span><br><span class="line">avatar = FileField(label=<span class="string">&#x27;上传头像&#x27;</span>, validators=[</span><br><span class="line">        FileRequired(<span class="string">&#x27;请选择图片文件&#x27;</span>), </span><br><span class="line">        FileAllowed([<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;jpeg&#x27;</span>],<span class="string">&#x27;格式不支持&#x27;</span>)</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>添加路由：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/file_upload&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_upload</span>():</span></span><br><span class="line">    form = UserAvatarForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        avatar = form.avatar.data</span><br><span class="line">        <span class="comment"># 格式化文件名（主要是将文件名中的空格用下划线代替）</span></span><br><span class="line">        filename = secure_filename(avatar.filename)</span><br><span class="line">        file_path = os.path.join(app.config[<span class="string">&#x27;UPLOAD_PATH&#x27;</span>], filename)</span><br><span class="line">        avatar.save(file_path)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;file_upload.html&#x27;</span>, form=<span class="keyword">from</span>)</span><br></pre></td></tr></table></figure><p>模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;file_upload&#x27;) &#125;&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; form.csrf_token &#125;&#125;</span><br><span class="line">    &#123;&#123; form.avatar &#125;&#125;</span><br><span class="line">    &#123;#  显示图片验证未通过的错误 #&#125;</span><br><span class="line">    &#123;% for err in form.avatar.errors %&#125;</span><br><span class="line">        &#123;&#123; err &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&#x27;submit file&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/10/17/flask%E8%A1%A8%E5%8D%95%E4%BB%8B%E7%BB%8D/html.png" alt="html"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;wtf表单介绍&quot;&gt;&lt;a href=&quot;#wtf表单介绍&quot; class=&quot;headerlink&quot; title=&quot;wtf表单介绍&quot;&gt;&lt;/a&gt;wtf表单介绍&lt;/h2&gt;&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集成wtforms&lt;/li&gt;
&lt;li&gt;CSRF保护&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Python" scheme="http://123.57.158.5/categories/Python/"/>
    
    <category term="Flask" scheme="http://123.57.158.5/categories/Python/Flask/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="Flask" scheme="http://123.57.158.5/tags/Flask/"/>
    
    <category term="Jinja2" scheme="http://123.57.158.5/tags/Jinja2/"/>
    
    <category term="SQLAlchemy" scheme="http://123.57.158.5/tags/SQLAlchemy/"/>
    
  </entry>
  
  <entry>
    <title>python使用openpyxl操作excel</title>
    <link href="http://123.57.158.5/2020/10/05/python-openpyxl/"/>
    <id>http://123.57.158.5/2020/10/05/python-openpyxl/</id>
    <published>2020-10-05T06:45:01.000Z</published>
    <updated>2021-05-23T02:34:39.915Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python的openpyxl库操作Excel</p><p>在获得实验Hf同位素数据后，需要自己手动复制粘贴提取出来太麻烦了，所以就想到了python的强大的第三方库，借此机会学一下python操作excel表格。</p><p>首先要有openpyxl库,这里使用的是3.0版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure><blockquote><p>该模块支持最新版的Excel文件格式，对Excel文件具有响应的读写操作，对此有专门的Reader和Writer两个类，便于对Excel文件的操作。也可以直接用workbook来进行操作。openpyxl的官方文档地址：<a href="https://openpyxl.readthedocs.io/en/stable/">https://openpyxl.readthedocs.io/en/stable/</a></p></blockquote><p>写入excel：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.utils <span class="keyword">import</span> get_column_letter</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"></span><br><span class="line">dest_filename = <span class="string">&#x27;empty_book.xlsx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建名为‘range names’的sheet,添加39行数据每行0-599</span></span><br><span class="line">ws1 = wb.active</span><br><span class="line">ws1.title = <span class="string">&quot;range names&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">40</span>):</span><br><span class="line">    ws1.append(<span class="built_in">range</span>(<span class="number">600</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 新建名为‘Pi’的sheet，给F5表格写入3.14</span></span><br><span class="line">ws2 = wb.create_sheet(title=<span class="string">&quot;Pi&quot;</span>)</span><br><span class="line"></span><br><span class="line">ws2[<span class="string">&#x27;F5&#x27;</span>] = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建‘Data’sheet,在指定区域放入对应列名的数据</span></span><br><span class="line">ws3 = wb.create_sheet(title=<span class="string">&quot;Data&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line">     <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>, <span class="number">54</span>):</span><br><span class="line">         ws3.cell(column=col, row=row, value=<span class="string">&quot;&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(get_column_letter(col)))</span><br><span class="line">        </span><br><span class="line">wb.save(filename = dest_filename)</span><br></pre></td></tr></table></figure><p>读取已存在的表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line">wb = load_workbook(filename = <span class="string">&#x27;empty_book.xlsx&#x27;</span>)</span><br><span class="line">sheet_ranges = wb[<span class="string">&#x27;range names&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(sheet_ranges[<span class="string">&#x27;D18&#x27;</span>].value)</span><br></pre></td></tr></table></figure><h2 id="实战提取实验数据"><a href="#实战提取实验数据" class="headerlink" title="实战提取实验数据"></a>实战提取实验数据</h2><p>直接上代码，注释中解释具体用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hf_data</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用于读取/写入excel中的Hf同位素数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, work_path, data_file, i</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param work_path: 数据所在的工作文件夹</span></span><br><span class="line"><span class="string">        :param data_file: 待写入文件</span></span><br><span class="line"><span class="string">        :param i: 写入hf数据编号</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.work_path = work_path</span><br><span class="line">        self.data_file = data_file</span><br><span class="line">        self.i = i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_file_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># listdir获取工作文件夹下的所有文件名，返回列表</span></span><br><span class="line">        hf_data_filename = os.listdir(self.work_path)[self.i]</span><br><span class="line">        <span class="keyword">return</span> hf_data_filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 去掉后缀的文件名，用于填写数据编号</span></span><br><span class="line">        <span class="keyword">return</span> self.get_file_name()[:-<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param i: 数据文件在文件夹中的位置</span></span><br><span class="line"><span class="string">        :return: 数据列表</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hf_data_filename = self.get_file_name()</span><br><span class="line">        sheet_name = self.get_data_name()</span><br><span class="line">        <span class="comment"># 拼接数据文件路径</span></span><br><span class="line">        file_path = os.path.join(self.work_path, hf_data_filename)</span><br><span class="line">        <span class="comment"># 加载数据文件，data_only表示只读取数值，sheet_name是数据编号</span></span><br><span class="line">        hf_data = openpyxl.load_workbook(file_path, data_only=<span class="literal">True</span>)[sheet_name]</span><br><span class="line">        aim_row = hf_data.max_row-<span class="number">8</span></span><br><span class="line">        <span class="comment"># [&#x27;A1&#x27;]等价于 sheet.cell(row=int,column=int)</span></span><br><span class="line">        <span class="keyword">return</span> hf_data[<span class="string">&#x27;P&#123;&#125;:R&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(aim_row,aim_row+<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将数据写入新xlsx文件</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hf_data = self.get_data()</span><br><span class="line">        hf_file = self.data_file</span><br><span class="line">        hf_file[<span class="string">&#x27;A&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.i+<span class="number">1</span>)] = self.get_data_name()</span><br><span class="line">        hf_file[<span class="string">&#x27;B&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.i+<span class="number">1</span>)] = hf_data[<span class="number">0</span>][<span class="number">0</span>].value</span><br><span class="line">        hf_file[<span class="string">&#x27;D&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.i+<span class="number">1</span>)] = hf_data[<span class="number">0</span>][<span class="number">1</span>].value</span><br><span class="line">        hf_file[<span class="string">&#x27;F&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.i+<span class="number">1</span>)] = hf_data[<span class="number">0</span>][<span class="number">2</span>].value</span><br><span class="line">        hf_file[<span class="string">&#x27;C&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.i+<span class="number">1</span>)] = hf_data[<span class="number">4</span>][-<span class="number">3</span>].value</span><br><span class="line">        hf_file[<span class="string">&#x27;E&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.i+<span class="number">1</span>)] = hf_data[<span class="number">4</span>][-<span class="number">2</span>].value</span><br><span class="line">        hf_file[<span class="string">&#x27;G&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.i+<span class="number">1</span>)] = hf_data[<span class="number">4</span>][-<span class="number">1</span>].value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    work_path = <span class="string">&#x27;H:\ZHONGYEDING 20191222&#x27;</span></span><br><span class="line">    <span class="comment"># 这里用的是原有excel文件打开 写入</span></span><br><span class="line">    data_file = openpyxl.load_workbook(<span class="string">&#x27;hf.xlsx&#x27;</span>)</span><br><span class="line">    data_sheet = data_file[<span class="string">&#x27;Sheet&#x27;</span>]</span><br><span class="line">    <span class="comment"># 循环写入数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(os.listdir(work_path))):</span><br><span class="line">        hf = Hf_data(work_path=work_path, data_file=data_sheet, i=i)</span><br><span class="line">        hf.write_data()</span><br><span class="line">    data_file.save(filename=<span class="string">&#x27;hf.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用Python的openpyxl库操作Excel&lt;/p&gt;
&lt;p&gt;在获得实验Hf同位素数据后，需要自己手动复制粘贴提取出来太麻烦了，所以就想到了python的强大的第三方库，借此机会学一下python操作excel表格。&lt;/p&gt;
&lt;p&gt;首先要有openpyxl库,这里使用的</summary>
      
    
    
    
    <category term="Python" scheme="http://123.57.158.5/categories/Python/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="openpyxl" scheme="http://123.57.158.5/tags/openpyxl/"/>
    
    <category term="Excel" scheme="http://123.57.158.5/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>Flask之ORM的介绍与项目实战</title>
    <link href="http://123.57.158.5/2020/10/03/flask-ORM/"/>
    <id>http://123.57.158.5/2020/10/03/flask-ORM/</id>
    <published>2020-10-03T12:27:12.000Z</published>
    <updated>2021-05-23T02:34:37.801Z</updated>
    
    <content type="html"><![CDATA[<p>Flask ORM的介绍与项目实战</p><h2 id="Flask-SQLAlchemy介绍"><a href="#Flask-SQLAlchemy介绍" class="headerlink" title="Flask-SQLAlchemy介绍"></a>Flask-SQLAlchemy介绍</h2><p>pip安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Flask-SQLAlchemy</span><br></pre></td></tr></table></figure><p>源码安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p><a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/">https://flask-sqlalchemy.palletsprojects.com/en/2.x/</a></p><p><a href="https://www.sqlalchemy.org/">https://www.sqlalchemy.org/</a></p><h3 id="Flask-SQLAIchemy配置"><a href="#Flask-SQLAIchemy配置" class="headerlink" title="Flask-SQLAIchemy配置"></a>Flask-SQLAIchemy配置</h3><p><strong>数据库URI</strong><br><code>SQLALCHEMY_DATABASE_URI</code></p><p>URI参数格式：<br>Postgres:<br><code>postgresql://username:password@127.0.0.1/mydatabase</code><br>MySQL:<br><code>mysql://username:password@127.0.0.1/mydatabase</code><br>Oracle:<br><code>oracle://usernname:password@127.0.0.1/mydatabase</code><br>SQLite:<br><code>sqlite:////absolute/path/to/foo.db</code></p><p><strong>多个数据库支持</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SQLALCHEMY_BINDS = &#123;</span><br><span class="line"><span class="string">&#x27;db1&#x27;</span>: <span class="string">&#x27;mysqldb://localhost/user&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;db2&#x27;</span>: <span class="string">&#x27;sqlite:////path/to/appmeta.db&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如 flask中配置mysql数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 配置数据库的连接参数</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;mysql://root:960423@127.0.0.1/flasker&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="使用ORM进行CURD操作"><a href="#使用ORM进行CURD操作" class="headerlink" title="使用ORM进行CURD操作"></a>使用ORM进行CURD操作</h2><h3 id="设计数据库模型并创建表"><a href="#设计数据库模型并创建表" class="headerlink" title="设计数据库模型并创建表"></a>设计数据库模型并创建表</h3><p>绑定到Flask对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = SQLAlchemy(app)</span><br></pre></td></tr></table></figure><p>ORM模型创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line"><span class="built_in">id</span> = db.Column(db.Integer,primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>指定表的名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__tablename__ = <span class="string">&#x27;mall_product&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="创建和删除表"><a href="#创建和删除表" class="headerlink" title="创建和删除表"></a>创建和删除表</h4><ul><li><p>手动创建数据库</p></li><li><p>创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.create_all()</span><br></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; db.drop_all()</span><br></pre></td></tr></table></figure></li></ul><h4 id="ORM模型字段类型支持"><a href="#ORM模型字段类型支持" class="headerlink" title="ORM模型字段类型支持"></a>ORM模型字段类型支持</h4><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Integer/Float</td><td>整型/浮点类型</td></tr><tr><td>String(size)</td><td>有长度限制的字符串</td></tr><tr><td>Text</td><td>一些较长的文本（如：通知详情、商品详情）</td></tr><tr><td>Date Time</td><td>表示为Python datetime 对象的 时间和日期</td></tr><tr><td>Boolean</td><td>存储为布尔值</td></tr><tr><td>PickleType</td><td>存储为一个持久化的Python对象</td></tr><tr><td>LargeBinary</td><td>存储一个任意大的二进制数据</td></tr></tbody></table><ul><li><p>一对多关系，外键关联。relation</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">address = db.relationship(<span class="string">&#x27;UserAddress&#x27;</span>,backref=db.backref(<span class="string">&#x27;person&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>多对多关系(建议使用Table实现，不建议使用Model)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tags = db.Table(<span class="string">&#x27;mall_product_tags&#x27;</span>,</span><br><span class="line">db.Column(<span class="string">&#x27;tag_id&#x27;</span>,db.Integer,db.ForeignKey(<span class="string">&#x27;tag.id&#x27;</span>)),</span><br><span class="line">                db.Column(<span class="string">&#x27;product_id&#x27;</span>,db.Integer,db.ForeignKey(<span class="string">&#x27;Product.id&#x27;</span>))</span><br><span class="line">               )</span><br></pre></td></tr></table></figure></li></ul><p><strong>举例</strong>：先创建用户表和用户地址表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask.ext.sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;mysql://root:password@127.0.0.1/flasker&#x27;</span></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 用户基本信息表 &quot;&quot;&quot;</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;flask_user&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = db.Column(db.String(<span class="number">20</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    password = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    birthday = db.Column(db.Date, nullable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAddress</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 用户地址表 &quot;&quot;&quot;</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;flask_user_address&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    addr = db.Column(db.String(<span class="number">64</span>), nullable=<span class="literal">True</span>)</span><br><span class="line">    user_id = db.Column(db.Integer, db.ForeignKey(<span class="string">&#x27;flask_user.id&#x27;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 关联的是表的类名</span></span><br><span class="line">    user = db.relationship(<span class="string">&#x27;User&#x27;</span>, backref=db.backref(<span class="string">&#x27;address&#x27;</span>, lazy=<span class="string">&#x27;select&#x27;</span>))</span><br></pre></td></tr></table></figure><p>创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from app import db</span><br><span class="line">&gt;&gt;&gt; db.create_all()</span><br></pre></td></tr></table></figure><p>如果中途报错<code>ModuleNotFoundError: No module named &#39;MySQLdb&#39;</code>,说明缺少Python操作数据库的模块可以通过安装包解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure><h3 id="插入-修改-删除数据"><a href="#插入-修改-删除数据" class="headerlink" title="插入/修改/删除数据"></a>插入/修改/删除数据</h3><h4 id="新增-修改数据"><a href="#新增-修改数据" class="headerlink" title="新增/修改数据"></a>新增/修改数据</h4><ul><li><p>构造ORM模型对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = User(<span class="string">&#x27;amdin&#x27;</span>,<span class="string">&#x27;admin@exmaple.com&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>添加到db.session (备注：可添加多个对象)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.session.add(user)</span><br></pre></td></tr></table></figure></li><li><p>提交到数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure></li></ul><h4 id="物理删除数据"><a href="#物理删除数据" class="headerlink" title="物理删除数据"></a>物理删除数据</h4><ul><li><p>查询ORM 模型对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = User.query.filter_by(username=<span class="string">&#x27;zhangshan&#x27;</span>).first()</span><br></pre></td></tr></table></figure></li><li><p>添加到db.session</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.session.delete(user)</span><br></pre></td></tr></table></figure></li><li><p>提交到数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用ORM查询并展示数据"><a href="#使用ORM查询并展示数据" class="headerlink" title="使用ORM查询并展示数据"></a>使用ORM查询并展示数据</h3><h4 id="ORM-查询"><a href="#ORM-查询" class="headerlink" title="ORM 查询"></a>ORM 查询</h4><ul><li><p>返回结果集(list)</p><ul><li><p>查询所有数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.query.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure></li><li><p>按条件查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User.query.filter_by(username=<span class="string">&#x27;giao&#x27;</span>)</span><br><span class="line">User.query.<span class="built_in">filter</span>(User.username.endswith(<span class="string">&#x27;o&#x27;</span>)).<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.query.order_by(User.username)</span><br></pre></td></tr></table></figure></li><li><p>查询TOP10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.query.limit(<span class="number">10</span>).<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>返回单个ORM对象</p><ul><li><p>根据pk查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.query.get(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>查询第一条记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.query.first()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>视图快捷函数：有则返回，无则返回404</p><p><code>first()</code>vs<code>first_or_404()</code></p><p><code>get()</code>vs<code>get_or_404()</code></p></li><li><p>多表关联查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.session.query(User).join(Address)</span><br><span class="line">User.query.join(Address)</span><br></pre></td></tr></table></figure></li></ul><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ol><li><p>使用offset 和limit</p><p><code>.offset(offset).limit(limit)</code></p></li><li><p>paginate分页支持</p><p><code>.paginate(page=2,per_page=4)</code> 返回Pagination对象</p></li></ol><p><code>has_prev/has_next</code>——是否有上一页/下一页</p><p><code>iter_pages()</code>——当前页的数据列表</p><p><code>prev_num/next_num</code>——上一页/下一页页码</p><p><code>total</code>——总记录数</p><p><code>pages</code>——总页数</p><h4 id="结合模板实现分页"><a href="#结合模板实现分页" class="headerlink" title="结合模板实现分页"></a>结合模板实现分页</h4><ol><li><p>准备数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_user = User.query.filter_by(is_valid=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>分页</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_user.paginate(page=<span class="number">2</span>,per_page=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></li><li><p>在模板中实现分页操作</p></li></ol><p>举例分页展示数据库用户表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 配置数据库的连接参数</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;mysql://root:password@127.0.0.1/flasker&#x27;</span></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 用户基本信息表 &quot;&quot;&quot;</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;flask_user&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = db.Column(db.String(<span class="number">20</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    password = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    birthday = db.Column(db.Date, nullable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAddress</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 用户地址表 &quot;&quot;&quot;</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;flask_user_address&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    addr = db.Column(db.String(<span class="number">64</span>), nullable=<span class="literal">True</span>)</span><br><span class="line">    user_id = db.Column(db.Integer, db.ForeignKey(<span class="string">&#x27;flask_user.id&#x27;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 关联的是表的类名</span></span><br><span class="line">    user = db.relationship(<span class="string">&#x27;User&#x27;</span>, backref=db.backref(<span class="string">&#x27;address&#x27;</span>, lazy=<span class="string">&#x27;select&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/&lt;int:page&gt;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_list</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 分页器的使用 &quot;&quot;&quot;</span></span><br><span class="line">    page_size = <span class="number">5</span></span><br><span class="line">    page_data = User.query.paginate(page=page, per_page=page_size)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;user_list.html&#x27;</span>, page_data=page_data, page=page)</span><br></pre></td></tr></table></figure><p>user_list.html:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;共有&#123;&#123; page_data.total &#125;&#125;个用户，&#123;&#123; page_data.pages &#125;&#125;页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;当前是第&#123;&#123; page &#125;&#125;页&lt;/h3&gt;</span><br><span class="line">    &#123;% for user in page_data.items %&#125;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">        &lt;li&gt;username: &#123;&#123; user.username &#125;&#125;, password: &#123;&#123; user.password &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &#123;% if page_data.has_prev %&#125;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(&#x27;user_list&#x27;,page=page_data.prev_num) &#125;&#125;&quot;&gt;上一页&lt;/a&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &#123;% if page_data.has_next %&#125;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(&#x27;user_list&#x27;,page=page_data.next_num) &#125;&#125;&quot;&gt;下一页&lt;/a&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><img src="/2020/10/03/flask-ORM/image-20201003203249331.png" alt="image-20201003203249331" style="zoom:50%;"><h2 id="实践：创建商城模型"><a href="#实践：创建商城模型" class="headerlink" title="实践：创建商城模型"></a>实践：创建商城模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid <span class="keyword">as</span> uuid</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;mysql://root:password@127.0.0.1/flasker&#x27;</span></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 商品标签表 &quot;&quot;&quot;</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;product_tag&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    uid = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>, default=uuid.uuid4, unique=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">256</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    desc = db.Column(db.Text, nullable=<span class="literal">False</span>)</span><br><span class="line">    is_valid = db.Column(db.Boolean, default=<span class="literal">True</span>)</span><br><span class="line">    created_time = db.Column(db.DateTime)</span><br><span class="line">    update_time = db.Column(db.DateTime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductClass</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 商品分类表 &quot;&quot;&quot;</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;product_class&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    uid = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>, default=uuid.uuid4, unique=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 对应父类 一对多关系</span></span><br><span class="line">    parent_class = db.Column(db.Integer, db.ForeignKey(<span class="string">&#x27;product_class.id&#x27;</span>))</span><br><span class="line">    name = db.Column(db.String(<span class="number">256</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    desc = db.Column(db.Text)</span><br><span class="line">    img = db.Column(db.String(<span class="number">256</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    is_valid = db.Column(db.Boolean, default=<span class="literal">True</span>)</span><br><span class="line">    created_time = db.Column(db.DateTime)</span><br><span class="line">    update_time = db.Column(db.DateTime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 商品表 &quot;&quot;&quot;</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;product&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    uid = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>, default=uuid.uuid4, unique=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 商品名称</span></span><br><span class="line">    name = db.Column(db.String(<span class="number">256</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    desc = db.Column(db.Text, nullable=<span class="literal">False</span>)</span><br><span class="line">    img = db.Column(db.String(<span class="number">256</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    storage = db.Column(db.Integer, default=<span class="number">0</span>)</span><br><span class="line">    view_count = db.Column(db.Integer, default=<span class="number">0</span>)</span><br><span class="line">    score = db.Column(db.Float(precision=<span class="number">2</span>))</span><br><span class="line">    price = db.Column(db.Float(precision=<span class="number">2</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    origin_price = db.Column(db.Float(precision=<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># 外键关联</span></span><br><span class="line">    tag = db.relationship(<span class="string">&#x27;Tag&#x27;</span>, backref=<span class="string">&#x27;product&#x27;</span>, lazy=<span class="literal">True</span>)</span><br><span class="line">    p_class = db.relationship(<span class="string">&#x27;ProductClass&#x27;</span>, backref=<span class="string">&#x27;product&#x27;</span>, lazy=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    is_valid = db.Column(db.Boolean, default=<span class="literal">True</span>)</span><br><span class="line">    created_time = db.Column(db.DateTime)</span><br><span class="line">    update_time = db.Column(db.DateTime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品与标签、分类之间的多对多关系</span></span><br><span class="line">tags = db.Table(<span class="string">&#x27;tags&#x27;</span>,</span><br><span class="line">                db.Column(<span class="string">&#x27;tag_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="string">&#x27;product_tag.id&#x27;</span>), primary_key=<span class="literal">True</span>),</span><br><span class="line">                db.Column(<span class="string">&#x27;product_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="string">&#x27;product.id&#x27;</span>), primary_key=<span class="literal">True</span>))</span><br><span class="line">p_class = db.Table(<span class="string">&#x27;class&#x27;</span>,</span><br><span class="line">                   db.Column(<span class="string">&#x27;class_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="string">&#x27;product_class.id&#x27;</span>), primary_key=<span class="literal">True</span>),</span><br><span class="line">                   db.Column(<span class="string">&#x27;product_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="string">&#x27;product.id&#x27;</span>), primary_key=<span class="literal">True</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Flask ORM的介绍与项目实战&lt;/p&gt;
&lt;h2 id=&quot;Flask-SQLAlchemy介绍&quot;&gt;&lt;a href=&quot;#Flask-SQLAlchemy介绍&quot; class=&quot;headerlink&quot; title=&quot;Flask-SQLAlchemy介绍&quot;&gt;&lt;/a&gt;Flask-S</summary>
      
    
    
    
    <category term="Python" scheme="http://123.57.158.5/categories/Python/"/>
    
    <category term="Flask" scheme="http://123.57.158.5/categories/Python/Flask/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="实战" scheme="http://123.57.158.5/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="Flask" scheme="http://123.57.158.5/tags/Flask/"/>
    
    <category term="Jinja2" scheme="http://123.57.158.5/tags/Jinja2/"/>
    
    <category term="SQLAlchemy" scheme="http://123.57.158.5/tags/SQLAlchemy/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络2之网络层</title>
    <link href="http://123.57.158.5/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://123.57.158.5/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2020-09-02T11:56:08.000Z</published>
    <updated>2021-05-23T02:34:45.084Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP四层模型（应用层、传输层、网络层、网络接口层）之网络层</p><p>前面讲到数据链路层只能解决相邻物理节点传输的问题，而网络层能解决跨节点传输的问题。</p><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/image-20200902200857189.png" alt="image-20200902200857189"></p><h2 id="IP协议详解"><a href="#IP协议详解" class="headerlink" title="IP协议详解"></a>IP协议详解</h2><h3 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h3><p>实际的计算机网络是错综复杂的，物理设备通过使用IP协议，屏蔽了物理网络之间的差异，当网络中的主机使用IP协议连接时，则无需关注网络细节。这就是<strong>虚拟互连网络</strong>的概念</p><ul><li><p>IP协议使得复杂的实际网络变为一个虚拟互连的网络</p></li><li><p>IP协议使得网络层可以屏蔽底层细节而专注网络层的数据转发</p></li><li><p>IP协议<font color="red">解决了在虚拟网络中数据传输路径的问题</font></p></li></ul><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>MAC地址是不可改变的，IP地址根据网络环境发生变化。</p><ul><li>IP地址长度为32位，常分为4个8位</li><li>IP地址常使用点分十进制来表示</li></ul><p>这样的IP地址可以有2<sup>32</sup>个</p><p>前面提到，数据传输对于物理层来说传输的是01…这样的比特流，对于数据链路层，传输的是<strong>数据帧</strong>，而其中出去帧首尾部以外，帧数据里面就是<strong>IP数据报</strong>的内容了</p><p><strong>IP数据报</strong>分为IP首部和IP数据报的数据</p><p>下表就是IP协议中IP首部的具体内容，每一行都是32位（4个字节），前五行就是IP协议头部的内容，所以对于IP头部至少有20个字节大小：</p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/image-20200906142941406.png" alt="image-20200906142941406" style="zoom: 50%;"><p><strong>版本</strong>：占4位，指的是IP协议的版本，通信双方的版本必须一致，有IPv4、IPv6。</p><p><strong>首部长度</strong>：占4位，最大数值为15，表示的是IP首部长度，单位是“32位字“（4个字节），也即是IP首部最大长度我60字节。</p><p><strong>总长度</strong>：占16位，最大数值为65535（32位字），表示的是IP数据报总长度（IP首部+IP数据）。之前的数据链路层知识中，最大传输单元<strong>MTU</strong>一般为1500个字节，存在总长度比MTU高的情况，把一个较长的IP数据报拆分成多个数据帧进行传输。</p><p><strong>标记</strong>：标记IP报文是否可以分片，目前只有2位有意义，IP数据报较长会进行分片处理</p><p><strong>片偏移</strong>：如果需要分片处理，用于记录当前数据帧保存的是第几个偏移的数据。</p><p><strong>TTL</strong>：占8位，表示IP数据报文在网络中的寿命，每经过一个设备TTL减1，当TTL=0时，网络设备必须丢弃该报文。避免数据被无限的传输而消耗带宽。</p><p><strong>协议</strong>：占8位，表明IP数据所携带的具体数据是什么协议的（如TCP、UDP等）</p><p>下列这些协议在使用ip协议进行传输的时候，都会附上各协议对应字段值。同时在ip协议中还可以继续封装ip协议</p><table><thead><tr><th>协议名</th><th>ICMP</th><th>IGMP</th><th><em>IP</em></th><th>TCP</th><th>UDP</th><th>OSPF</th><th>…</th></tr></thead><tbody><tr><td>字段值</td><td>1</td><td>2</td><td>4</td><td>6</td><td>17</td><td>89</td><td></td></tr></tbody></table><p><strong>首部校验和</strong>：占16位，校验IP首部是否有出错</p><p><strong>源IP地址</strong>：指示发送IP地址</p><h2 id="IP协议的转发流程"><a href="#IP协议的转发流程" class="headerlink" title="IP协议的转发流程"></a>IP协议的转发流程</h2><h3 id="路由表简介"><a href="#路由表简介" class="headerlink" title="路由表简介"></a>路由表简介</h3><p><strong>逐跳（hop-by-hop)</strong>: 就是发出的ip报文从各个网络、路由器最后到接收设备的过程</p><p><strong>路由表简介</strong></p><p>在单个路由表中，根据MAC地址寻找对应接口的过程：</p><ol><li>A通过网卡发出数据帧</li><li>数据帧到达路由器，路由器取出前6字节</li><li>路由器匹配MAC地址表，找到对应的网络接口</li><li>路由器往该网络接口发送数据帧</li></ol><p>而在通过<strong>路由表</strong>，我们可以在逐跳过程中找到目的IP地址对应的下一跳的IP地址</p><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/image-20200906220623339.png" alt="image-20200906220623339"></p><p>计算机或者路由器都拥有路由表</p><h3 id="IP协议的转发流程-1"><a href="#IP协议的转发流程-1" class="headerlink" title="IP协议的转发流程"></a>IP协议的转发流程</h3><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/image-20200906220946384.png" alt="image-20200906220946384" style="zoom:50%;"><ul><li>A发出目的地为C的IP数据报，查询路由器表发现下一跳为E</li><li>A将数据报发送给E</li><li>E查询路由表发现下一跳为F，将数据报发送给F</li><li>F查询路由表发现目的地C直接连接，将数据报发送给C</li></ul><p><strong>将网络层与数据链路层结合起来看，该过程为：</strong></p><p><strong>A-路由E</strong>：</p><ul><li>A发出目的地为C的IP数据报，<font color="red">查询路由表发现下一跳为E</font></li><li>A将IP数据报<font color="red">交给数据链路层，并告知目的MAC地址是E</font></li><li>数据链路层<font color="red">填充源MAC地址</font>和<font color="red">目的MAC地址E</font></li><li>数据链路层通过物理层将数据发送给E</li></ul><p><strong>路由E-路由F</strong>：</p><ul><li>E的数据链路层收到数据帧，<font color="red">把数据交给网络层</font></li><li>E<font color="red">查询路由表，发现下一跳为F</font></li><li>E<font color="red">把数据交给数据链路层，并告知目的MAC地址为F</font></li><li>E的数据链路层<font color="red">封装数据帧并发送</font></li></ul><p><strong>路由F-C</strong>：</p><ul><li>F的数据链路层接收到数据帧，<font color="red">把帧数据交给网络层</font></li><li>F<font color="red">查询路由表，发现下一跳为C</font></li><li>F<font color="red">把数据交给数据链路层，并告知目的MAC地址为C</font></li><li>F的数据链路层<font color="red">封装数据帧并发送</font></li></ul><p>值得注意的是：</p><p><strong>数据帧的每一跳MAC地址都在变化</strong>，因为发送端开始不知道目的主机的MAC地址，所以没经过一个路由MAC地址是在变化的。</p><p><strong>IP数据报每一跳的IP地址始终不变</strong>。路由器只是在接收到数据报时候，检查数据报的目的IP地址，然后查找路由表，选择合适的接口发送出去。</p><h2 id="IP地址的子网划分"><a href="#IP地址的子网划分" class="headerlink" title="IP地址的子网划分"></a>IP地址的子网划分</h2><h3 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h3><p>如果对42亿多个ip地址进行分类的话十分复杂，则需要先把ip地址进一步划分为两个部分，网络号和主机号，加起来为32位。</p><p>A类地址：网络号8位，主机号24位；B类地址：网络号16位，主机号16位；C类地址：网络号24位，主机号8位。</p><p>注意：<font color="red">根据网络号的前几位判断，比如A类是0开头，B类是10开头</font></p><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/image-20200913131127092.png" alt="image-20200913131127092"></p><table><thead><tr><th></th><th>最小网络号</th><th>最大网络号</th><th>子网数量</th><th>最小主机号</th><th>最大主机号</th><th>主机数量</th></tr></thead><tbody><tr><td>A</td><td>0（00000000）</td><td>127（01111111）</td><td>2^7</td><td>0.0.0</td><td>255.255.255</td><td>2^24</td></tr><tr><td>B</td><td>128.0</td><td>192.255</td><td>2^14</td><td>0.0</td><td>255.255</td><td>2^16</td></tr><tr><td>C</td><td>192.0.0</td><td>223.255.255</td><td>2^21</td><td>0</td><td>255</td><td>2^8</td></tr></tbody></table><p><strong>特殊主机号</strong></p><ul><li><p>主机号全0表示当前网络段，不可分配为特定主机</p><p>例如1.0.0.0（主机号全为0）表示A类地址的网路段</p></li><li><p>主机号为全1表示广播地址，向当前网络段所有主机发消息</p><p>例如1.255.255.255，如果往这个地址发送信息的话，会广播给所有当前网络段的所有主机</p></li></ul><p><strong>特殊的网络号</strong></p><ul><li>A类地址网路段0(00000000)表示特殊网络</li><li>A类地址网络段后7位全1(01111111:127)表示回环地址</li><li>B类地址网络段(10000000.00000000:128.0)是不可使用的</li><li>C类地址网络段(192.0.0)是不可使用的</li></ul><p>出去这些特殊网络号和主机号之后</p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/QQ拼音截图20201010203015.png" alt="QQ拼音截图20201010203015" style="zoom:60%;"><blockquote><p>127.0.0.1，通常被称为本地回环地址(Loopback Address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在Windows操作系统中也有相似的定义，所以通常在安装网卡前就可以ping通这个本地回环地址。一般都会用来检查本地网络协议、基本数据接口等是否正常的。</p></blockquote><p>另外D类地址网络号前几位为1110……;E类地址网络号1111……</p><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p><strong>假设某公司拥有256名员工，没人配备一个计算机，请问该公司应该申请哪种网路段？</strong></p><p>答：只能分配B类地址，比如分配192.17.0.0这个网络段，有2^16-2个主机号/ip地址</p><p>但是会造成很大的地址空间浪费，因此提出了<strong>子网划分</strong>的概念</p><p>把ip地址分为网路号、子网号、主机号</p><p>比如将193.10.10.0分为两个子网：最后八位主机号分别是.00000000和.10000000。即193.10.10.0<del>193.10.10.127和193.10.10.128</del>193.10.10.255，每个子网有128个ip地址</p><p><strong>子网号这么多人，有没有办法快速判断某个IP的网络号？</strong></p><p><strong>子网掩码</strong></p><blockquote><p>子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p></blockquote><ul><li>子网掩码和IP地址一样，都是32位</li><li>子网掩码由连续的1和连续的0组成</li><li>某一个子网的子网掩码具备网络号位数个连续的1</li></ul><p>所以A类地址的子网掩码是255.0.0.0；B类地址的是255.255.0.0；C类地址的是255.255.255.0</p><p>通过ip与其子网掩码可以快速得到该ip地址的网络号</p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/QQ拼音截图20201010211843.png" alt="QQ拼音截图20201010211843" style="zoom:60%;"><p>例如一个ip地址为193.10.10.6，其子网掩码为255.255.255.128，将他们转换为二进制，做<strong>AND运算</strong>，得到二进制的网络号，其网络号为193.10.10.0</p><p>假设一个ip为193.10.10.129，子网掩码为255.255.255.128，其网络号为？</p><p>答：193.10.10.128</p><p>内网通信问题：</p><p>如果两个ip在同一个网络号下，就可以实现内网通信。</p><h3 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h3><ul><li><p>CIDR中没有A\B\C类网络号，和子网划分的概念</p></li><li><p>CIDR将网络前缀相同的IP地称为一个“CIDR地址块”</p><p>将ip地址分为<strong>网络前缀</strong>和主机号，网络前缀是任意位数的</p></li></ul><p>CIDR使用斜线记法</p><p>例如193.10.10.129/25 表明其网络前缀有25位，主机号7位。其他前缀长度有13,14,15,16…等</p><p>CIDR除去网络前缀的概念外，其他的子网掩码等性质与前面一致，其相比原来子网划分更加灵活，目前较为通用。</p><h2 id="网络地址转换NAT技术"><a href="#网络地址转换NAT技术" class="headerlink" title="网络地址转换NAT技术"></a>网络地址转换NAT技术</h2><p>内网地址：内部机构使用；避免与外网地址重复</p><p>外网地址：网球范围使用；全球公网唯一</p><p>三类内网地址：</p><ul><li>10.0.0.0~10.255.255.255(支持千万数量级设备)</li><li>172.16.0.0~172.31.255.255(支持百万数量级设备)</li><li>192.168.0.0~192.168.255.255(支持万数量级设备)</li></ul><p>当内网多个设备使用同一个外网IP请求外网的服务，外部怎么知道具体是哪个设备在请求的？</p><p>此时需要使用网络地址转换NAT(Network Address Translation)，NAT技术用于多个主机通过一个公有IP访问互联网的私有网络中；</p><p>NAT技术减缓了IP地址的损耗，但是增加了网络通信的复杂度</p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/QQ拼音截图20201016145019.png" alt="QQ拼音截图20201016145019" style="zoom:60%;"><p>举例：当内网设备192.168.2.11进程与外网某目的计算机进行通信时使用到了NAT技术（路由器的外网IP地址为173.21.59.10）：</p><p>192.168.2.11:6666进程通过NAT技术转化为新的地址和端口号然后发送到网络中去。接收数据也是这一过程。</p><p>这个映射表就成为NA(P)T表</p><h2 id="ICMP协议详解"><a href="#ICMP协议详解" class="headerlink" title="ICMP协议详解"></a>ICMP协议详解</h2><p>网际控制报文协议（Internet Control Message Protocal）</p><p>ICMP协议可以报告错误信息或者异常情况</p><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/QQ%E6%8B%BC%E9%9F%B3%E6%88%AA%E5%9B%BE20201016150645.png" alt="QQ拼音截图20201016150645"></p><p>ICMP报文数据包含8位类型8位代码和16位校验和</p><p>如果ip协议传输的是ICMP数据的话，将会在IP首部中的8位协议写入1</p><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/QQ%E6%8B%BC%E9%9F%B3%E6%88%AA%E5%9B%BE20201016151046.png" alt="QQ拼音截图20201016151046"></p><p>报文种类：差错报告报文和询问报文</p><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/QQ%E6%8B%BC%E9%9F%B3%E6%88%AA%E5%9B%BE20201016151307.png" alt="QQ拼音截图20201016151307"></p><p>举例：如果一个计算机和另一个已关机的计算机通信，此时就会返回ICMP代码为1，类型为3的报文</p><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/QQ%E6%8B%BC%E9%9F%B3%E6%88%AA%E5%9B%BE20201016151718.png" alt="QQ拼音截图20201016151718"></p><h2 id="ICMP协议的应用"><a href="#ICMP协议的应用" class="headerlink" title="ICMP协议的应用"></a>ICMP协议的应用</h2><h3 id="Ping应用"><a href="#Ping应用" class="headerlink" title="Ping应用"></a>Ping应用</h3><p>ping这个命令返回的就是一种询问报文，报文类型为回送请求或应答</p><p>网络故障排查：</p><p>ping127.0.01可以检查本地协议或数据接口是否正常；ping网关地址（路由器地址192.168.1.1）检查与路由器的连接是否正常；ping远端地址 不通说明运营商问题</p><h3 id="Traceroute应用"><a href="#Traceroute应用" class="headerlink" title="Traceroute应用"></a>Traceroute应用</h3><p>Traceroute可以探测IP数据报在网络中走过的路径。原理是通过TTL不停增加1，返回ICMP协议<strong>终点不可达差错报文</strong>来确定每个经过的路径</p><p>可通过命令行查询 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tracert rice-and-bran.site</span><br></pre></td></tr></table></figure><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/image-20201016163314268.png" alt="image-20201016163314268"></p><h2 id="网络层的路由概述"><a href="#网络层的路由概述" class="headerlink" title="网络层的路由概述"></a>网络层的路由概述</h2><p>进行网络通信时候，通过路由表来查找下一跳地址，那么：</p><p>下一跳地址是怎么来的？下一跳地址是唯一的吗？下一跳地址是最佳的吗？</p><p>路由器是怎么协同工作的？</p><p>为了解决这些问题，需要一个好的路由算法。</p><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/clip_image001.png" alt="img"></p><ul><li><p>每一顶点表示一个网络、路由器或者计算机</p></li><li><p>每一条边表示一条网络路劲</p></li></ul><p>路由算法实际上是图论的算法，但是网络环境复杂，又要比图论的算法要复杂！</p><p>一个好的路由算法需要满足：</p><ul><li><p>算法是正确的、完整的</p></li><li><p>算法在计算上应该尽可能的简单</p></li><li><p>算法可以适应网络中的变化</p></li><li><p>算法是稳定的和公平的</p></li></ul><p><strong>自治系统（Autonomous System）</strong>：一个自治系统是处于一个管理机构下的网络设备群；AS内部自行管理，AS对外提供一个或者多个出入口。</p><p>在之前提到的网络层次划分，每一个主干ISP或者地区ISP或者校园都可以理解为一个AS</p><p>自治系统内部路由的协议称为：内部网关协议（RIP、OSPF）</p><p>自治系统外部路由的协议称为：外部网关协议（BGP）</p><h2 id="内部网关路由协议之RIP协议"><a href="#内部网关路由协议之RIP协议" class="headerlink" title="内部网关路由协议之RIP协议"></a>内部网关路由协议之RIP协议</h2><h3 id="距离矢量（DV）算法"><a href="#距离矢量（DV）算法" class="headerlink" title="距离矢量（DV）算法"></a>距离矢量（DV）算法</h3><ul><li>每一个节点使用两个向量D<sub>i</sub>和S<sub>i</sub></li><li>D<sub>i</sub>描述的是当前节点到别的节点的距离</li><li>S<sub>i</sub>描述的是当前节点到别的节点的下一节点</li><li>每一个节点与相邻的节点交换D<sub>i</sub>和S<sub>i</sub>的信息</li><li><font color="red">每一个节点根据交换的信息更新自己的节点信息</font></li></ul><h3 id="RIP协议的过程"><a href="#RIP协议的过程" class="headerlink" title="RIP协议的过程"></a>RIP协议的过程</h3><ul><li>RIP(Routing Information Protocol)协议，是使用DV算法的一种路由协议</li><li>RIP协议把网络的跳数(hop)作为DV算法的距离</li><li>RIP协议每隔30s交换一次路由信息</li><li>RIP协议认为跳数&gt;15的路由则为不可达路由</li></ul><ol><li>路由初始化路由信息(两个向量D<sub>i</sub>和S<sub>i</sub>)</li><li>对相邻路由器X发过来的信息，对信息的内容进行修改（下一跳地址设置为X，所有距离加1）<ol><li>检索本地路由，将信息中新的路由插入到路由表里面</li><li>检索本地路由，对于下一跳为X的，更新为修改后的信息</li><li>检索本地路由，对此相同目的的距离，如果信息的距离更小，则更新本地路由表</li></ol></li><li>如果3分钟没有收到路由信息，则把相邻路由设置为不可达（16跳）</li></ol><h3 id="RIP协议缺点"><a href="#RIP协议缺点" class="headerlink" title="RIP协议缺点"></a>RIP协议缺点</h3><p>故障信息传递慢：</p><p>过度依赖相邻路由信息，“视野不够广”，如果A宕机，B、C之间会反复查找，直到达到16跳。</p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/image-20201115104650763.png" alt="image-20201115104650763" style="zoom: 67%;"><p>RIP协议优点是实现简单，开销很小，但是限制了网络的规模，“坏消息传的慢”，更新收敛时间过长</p><h2 id="Dijkstra-迪杰斯特拉-算法"><a href="#Dijkstra-迪杰斯特拉-算法" class="headerlink" title="Dijkstra(迪杰斯特拉)算法"></a>Dijkstra(迪杰斯特拉)算法</h2><p>Dijkstra(迪杰斯特拉)算法是准名的图算法，解决有权图从一个节点到其他节点的最短路径问题。</p><p>特点是“以起点为中心，向外层层扩展”</p><p>例如：</p><p>我们要从A到E，每两个节点之间距离已知，则可以有以下五条路径</p><p><img src="/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/image-20201129184837923.png" alt="image-20201129184837923"></p><p>算法实现过程：</p><p><em>1. 初始化两个集合(S,U)(S为只有初始顶点点A的集合，U为其他顶点集合)</em></p><p><em>2. 如果U不为空，对U集合顶点进行距离的排序，并取出距离A最近的一个顶点D</em></p><ul><li><em>将顶点D纳入S集合</em></li><li><em>更新A通过顶点D到达U集合所有点的距离（如果距离更小则更新，否则不更新）</em></li><li><em>重复2步骤</em></li></ul><p><em>3. 直到U集合为空，算法完成</em></p><h2 id="内部网关协议之OSPF协议"><a href="#内部网关协议之OSPF协议" class="headerlink" title="内部网关协议之OSPF协议"></a>内部网关协议之OSPF协议</h2><p>LS协议定义了内部网关的规则，OSPF协议用于实现该规则</p><h3 id="链路状态（LS）协议"><a href="#链路状态（LS）协议" class="headerlink" title="链路状态（LS）协议"></a>链路状态（LS）协议</h3><p>规则：</p><p>路由器向所有的相邻路由器发送信息，一传十，十传百。而RIP协议中只和相邻的路由器交换信息。</p><p>该协议的消息描述该路由器与相邻路由器的链路状态（包括距离、时延、带宽等），而前面的RIP协议只能交换并使用信息中的跳数</p><p>只有链路状态发生变化时，才发送更新信息</p><h3 id="OSPF协议的过程"><a href="#OSPF协议的过程" class="headerlink" title="OSPF协议的过程"></a>OSPF协议的过程</h3><p>OSPF(Open Shortest Path First: 开放最短路径优先)，核心是Dijkstra算法。</p><p>向所有路由器发送信息，实现”网络的完整拓扑”，也称”链路状态数据库“。然后通过Dijstra算法，每个路由器都能找到最短路径</p><p> 消息描述该路由器与相邻路由器的链路状态（包括距离、时延、带宽等），OSPF协议实现起来更客观更先进</p><p>只有链路状态发生变化时，才发送更新信息，减少了数据的交换，更快的收敛</p><p>OSPF协议的五种消息类型：</p><ul><li>问候消息</li><li>链路状态数据库描述信息</li><li>链路状态请求信息</li><li>链路状态更新信息</li><li>链路状态确认信息</li></ul><p>过程：1. 路由器接入网络 2. 路由器向邻居发出问候信息 3. 与邻居交流链路状态数据库 4.路由器广播和更新未知路由</p><p><strong>RIP对比OSPF</strong></p><table><thead><tr><th>RIP协议</th><th>OSPF协议</th></tr></thead><tbody><tr><td>从邻居看网络</td><td>整个网络的拓扑</td></tr><tr><td>在路由器之间累加距离</td><td>Dijstra算法计算最短路径</td></tr><tr><td>频繁、周期更新、收敛很慢</td><td>状态变化更新，收敛很快</td></tr><tr><td>路由间拷贝路由信息</td><td>路由间传递链路状态，自行计算路径</td></tr></tbody></table><h2 id="外部网关路由协议之BGP协议简述"><a href="#外部网关路由协议之BGP协议简述" class="headerlink" title="外部网关路由协议之BGP协议简述"></a>外部网关路由协议之BGP协议简述</h2><p>BGP（Border Gateway Protocol: 边际网关协议），是运行在AS(自治系统)之间的一种协议</p><p>外部网关使用BGP协议的原因：</p><ul><li>互联网规模很大，如果使用到“链路状态数据库”则十分庞大；</li><li>且AS内部之间使用不同的路由协议，无法直接兼容</li><li>AS之间需要考虑除网络特性之外的一些因素（政治、安全等）</li></ul><p>BGP协议因为很多其他的因素，能够找到一条到达目的地比较好的路由（不一定是最好的）</p><p>BGP发言人（speaker）：一般将AS边界路由器配置为BGP发言人。BGP并不关心内部网络拓扑，AS之间通过BGP发言人交流信息，BGP Speaker可以人为策略配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP/IP四层模型（应用层、传输层、网络层、网络接口层）之网络层&lt;/p&gt;
&lt;p&gt;前面讲到数据链路层只能解决相邻物理节点传输的问题，而网络层能解决跨节点传输的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/09/02/%E8%AE%A1%E7%AE%97%E6%9C%</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://123.57.158.5/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>python编程问答基础篇2(更新中)</title>
    <link href="http://123.57.158.5/2020/08/27/Python%E9%9D%A2%E8%AF%95/"/>
    <id>http://123.57.158.5/2020/08/27/Python%E9%9D%A2%E8%AF%95/</id>
    <published>2020-08-27T12:51:17.000Z</published>
    <updated>2021-05-23T02:34:39.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-def-func-a-b-这种写法有什么坑？"><a href="#1-def-func-a-b-这种写法有什么坑？" class="headerlink" title="1.def func(a,b=[]) 这种写法有什么坑？"></a>1.<code>def func(a,b=[])</code> 这种写法有什么坑？</h2><p>参数如果不填的话最好设置为None，而不要这样设置为空列表。因为函数在定义的时候b已经被赋值了，而列表是不可变类型，添加元素存储地址不发生改变，下面例子的func(2)结果中返回的列表显然还是第一次调用时候的列表，列表并没有重置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a,b=[]</span>):</span></span><br><span class="line">    b.append(a)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line">func(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[1]</span></span><br><span class="line"><span class="string">[1,2]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-如何实现-“1-2-3”-变成-‘1’-’2’-’3’"><a href="#2-如何实现-“1-2-3”-变成-‘1’-’2’-’3’" class="headerlink" title="2.如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?"></a>2.如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">&#x27;1,2,3&#x27;</span></span><br><span class="line">string.split(<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="3-如何实现-‘1’-’2’-’3’-变成-1-2-3"><a href="#3-如何实现-‘1’-’2’-’3’-变成-1-2-3" class="headerlink" title="3.如何实现[‘1’,’2’,’3’]变成[1,2,3] ?"></a>3.如何实现[‘1’,’2’,’3’]变成[1,2,3] ?</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_list = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">[<span class="built_in">int</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> num_list]</span><br></pre></td></tr></table></figure><h2 id="4-比较：a-1-2-3-和-b-1-2-3-以及-c-1-2-3-的区别？"><a href="#4-比较：a-1-2-3-和-b-1-2-3-以及-c-1-2-3-的区别？" class="headerlink" title="4.比较：a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 c = [(1,),(2,),(3,) ] 的区别？"></a>4.比较：a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 c = [(1,),(2,),(3,) ] 的区别？</h2><p>a和b里面的元素是一样的，c里面的元素是元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] == b[<span class="number">0</span>] <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="5-如何用一行代码生成-1-4-9-16-25-36-49-64-81-100"><a href="#5-如何用一行代码生成-1-4-9-16-25-36-49-64-81-100" class="headerlink" title="5.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?"></a>5.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br></pre></td></tr></table></figure><h2 id="6-一行代码实现删除列表中重复的值"><a href="#6-一行代码实现删除列表中重复的值" class="headerlink" title="6.一行代码实现删除列表中重复的值 ?"></a>6.一行代码实现删除列表中重复的值 ?</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">set</span>(num_list))</span><br></pre></td></tr></table></figure><h2 id="7-如何在函数中设置一个全局变量"><a href="#7-如何在函数中设置一个全局变量" class="headerlink" title="7.如何在函数中设置一个全局变量 ?"></a>7.如何在函数中设置一个全局变量 ?</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># global关键字(内部作用域想要对外部作用域的变量进行修改)</span></span><br><span class="line"><span class="comment"># 首先外部要有被变量</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>()：</span></span><br><span class="line"><span class="function"><span class="title">global</span> <span class="title">a</span></span></span><br><span class="line"><span class="function">    <span class="title">a</span> = &#x27;<span class="title">wdnmd</span>&#x27;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"># 调用之后，<span class="title">global</span>才会起作用    </span></span><br><span class="line"><span class="function"><span class="title">func</span>()</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params">a</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="title">wdnmd</span></span></span><br><span class="line"><span class="function">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="8-logging模块的作用？以及应用场景？"><a href="#8-logging模块的作用？以及应用场景？" class="headerlink" title="8.logging模块的作用？以及应用场景？"></a>8.logging模块的作用？以及应用场景？</h2><p>日志模块，用来记录用户的行为 或者 代码执行的过程。作用:可以了解程序的运行情况是否正常,在程序出现故障快速定位出错地方以及故障分析。</p><blockquote><p><a href="https://www.jianshu.com/p/e539636ab854">https://www.jianshu.com/p/e539636ab854</a></p></blockquote><h2 id="9-请用代码简答实现stack-。"><a href="#9-请用代码简答实现stack-。" class="headerlink" title="9.请用代码简答实现stack 。"></a>9.请用代码简答实现stack 。</h2><blockquote><p>栈（stack）在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。</p></blockquote><p>我们来通过list简单实现stack</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack=[]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.stack.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">&#x27;stack is empty&#x27;</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_exsit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(self.stack)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 取出栈中的最新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="10-简述-生成器、迭代器、可迭代对象-以及应用场景？"><a href="#10-简述-生成器、迭代器、可迭代对象-以及应用场景？" class="headerlink" title="10.简述 生成器、迭代器、可迭代对象 以及应用场景？"></a>10.简述 生成器、迭代器、可迭代对象 以及应用场景？</h2><p><strong>生成器</strong>：</p><p>Python使用生成器对延迟操作提供了支持，所谓延迟操作，是指在需要的时候才产生结果，而不是立即产生结果。</p><p>比如我们要循环输出有规律的数组，我们可以计算一次，返回一次，这就是<strong>生成器</strong>，而不是一次性生成列表。</p><p>产生生成器的方法：</p><ol><li><p>生成器表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>generator_object = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>generator_object</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x000001A77EDB16D8</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>生成器函数</p><blockquote><p>和常规函数定义一样,但是返回语句return被yield语句代替了.yield语句一次返回一个结果,在每个结果中间,挂起函数的状态,以便下次从它离开的地方继续执行.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">generator_func</span>(<span class="params">n</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> i*i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>generator_func(<span class="number">10</span>)</span><br><span class="line">&lt;generator <span class="built_in">object</span> generator_func at <span class="number">0x000001A77EDB19A8</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>自动实现迭代器协议:对于生成器,Python会自动实现它的可迭代协议,以便用在可以迭代的地方.所以我们可调用它的next方法,获取下一个元素,并且在没有值可以返回的时候,生成器会自动产生StopIteration异常</p></blockquote><p><strong>迭代器</strong>：</p><p>迭代器对象就是实现了<code>iter()</code> 和 <code>next()</code>方法的对象.其中<code>iter()</code>返回迭代器本身,而<code>next()</code>返回容器的下一个元素,在结尾处引发StopInteration异常.</p><p><code>ir=iter(itrable)</code>将一个可迭代对象转化为迭代器，<code>next(ir)</code>获取下迭代器中的下一个值。</p><p>可迭代对象就是可以转化为迭代器的对象，比如dict、tuple、list、str等。而且他们都可用作for循环，遵循可迭代协议。</p><h2 id="11-用Python实现一个二分查找的函数。"><a href="#11-用Python实现一个二分查找的函数。" class="headerlink" title="11.用Python实现一个二分查找的函数。"></a>11.用Python实现一个二分查找的函数。</h2><blockquote><p>二分查找又称折半查找，优点是比较次数少、查找速度快、平均性能好；其缺点是要求待查表为有序表，且插入删除困难，因此折半查找适用于不经常变动而查找频繁的有序序列。其算法思想是将表中中间位置记录的关键字与要查找的关键字比较，如果两者相等则查找成功，否则利用中间位置将表分成前、后两个子表。如果中间记录的关键字大于查找关键字，则进一步查找前一字表，否则进一步查找后一子表。重复以上过程，直到满足条件则查找成功，否则查找失败。</p></blockquote><p>算法实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">array, val</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        python二分查找，查找数值在有序列表中的位置，找到后返回在列表中顺序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="built_in">len</span>(array)</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = length+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high):</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> val &lt; array[mid]:</span><br><span class="line">            high = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> val &gt; array[mid]:</span><br><span class="line">            low = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary_search(array, <span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>(binary_search(array, <span class="number">4</span>))</span><br><span class="line">    <span class="built_in">print</span>(binary_search(array, <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(binary_search(array, <span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-谈谈你对闭包的理解？"><a href="#12-谈谈你对闭包的理解？" class="headerlink" title="12.谈谈你对闭包的理解？"></a>12.谈谈你对闭包的理解？</h2><blockquote><p>闭包概念：在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">origin</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closure</span>(<span class="params">y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    <span class="keyword">return</span> closure</span><br></pre></td></tr></table></figure><p>函数origin中返回的是函数closure，而函数closure对orign的x变量进行了引用，这就是闭包。闭包也是装饰器的原理</p><h2 id="13-os和sys模块的作用？"><a href="#13-os和sys模块的作用？" class="headerlink" title="13.os和sys模块的作用？"></a>13.os和sys模块的作用？</h2><p>Python 的 os 模块封装了常见的文件和目录操作</p><p>下面是部分常见的用法：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">os.mkdir</td><td align="center">创建目录</td></tr><tr><td align="center">os.rmdir</td><td align="center">删除目录</td></tr><tr><td align="center">os.rename</td><td align="center">重命名</td></tr><tr><td align="center">os.remove</td><td align="center">删除文件</td></tr><tr><td align="center">os.getcwd</td><td align="center">获取当前工作路径</td></tr><tr><td align="center">os.walk</td><td align="center">遍历目录</td></tr><tr><td align="center">os.path.join</td><td align="center">连接目录与文件名</td></tr><tr><td align="center">os.path.split</td><td align="center">分割文件名与目录</td></tr><tr><td align="center">os.path.abspath</td><td align="center">获取绝对路径</td></tr><tr><td align="center">os.path.dirname</td><td align="center">获取路径</td></tr><tr><td align="center">os.path.basename</td><td align="center">获取文件名或文件夹名</td></tr><tr><td align="center">os.path.splitext</td><td align="center">分离文件名与扩展名</td></tr><tr><td align="center">os.path.isfile</td><td align="center">判断给出的路径是否是一个文件</td></tr><tr><td align="center">os.path.isdir</td><td align="center">判断给出的路径是否是一个目录</td></tr></tbody></table><blockquote><p>“sys”即“system”，“系统”之意。该模块提供了一些接口，用于访问 Python 解释器自身使用和维护的变量，同时模块中还提供了一部分函数，可以与解释器进行比较深度的交互。</p></blockquote><p>下面是部分常见的用法：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">sys.argv</td><td align="center">展示调用python提供的命令行参数</td></tr><tr><td align="center">sys.platform</td><td align="center">运行的平台</td></tr><tr><td align="center">sys.executable</td><td align="center">解释器对应的绝对路径</td></tr><tr><td align="center">sys.getsizeof</td><td align="center">作用对象占用的字节数</td></tr></tbody></table><h2 id="14-Python面向对象中的继承有什么特点？"><a href="#14-Python面向对象中的继承有什么特点？" class="headerlink" title="14.Python面向对象中的继承有什么特点？"></a>14.Python面向对象中的继承有什么特点？</h2><p>提高代码的复用程度，避免重复操作</p><p>特点：</p><ol><li>在继承中基类的构造(<code>__init__()</code>方法)不会被自动调用，它需要在其派生类的构造中亲自专门调用。</li><li>在调用基类的方法时候，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时候并不需要带上self参数</li><li>python总是首先札沼对应类型的方法，如果不能在派生类中找到对应的方法，它才开始到基类中逐个查找</li></ol><h2 id="15-面向对象深度优先和广度优先是什么？"><a href="#15-面向对象深度优先和广度优先是什么？" class="headerlink" title="15.面向对象深度优先和广度优先是什么？"></a>15.面向对象深度优先和广度优先是什么？</h2><p>Python的类可以继承多个类，Python的类如果继承了多个类，那么其寻找方法的方式有两种： 当类是经典类时，多继承情况下，会按照深度优先方式查找 （py3） ；当类是新式类时，多继承情况下，会按照广度优先方式查找（ py2）</p><p>简单点说就是：经典类是纵向查找，新式类是横向查找</p><p>经典类和新式类的区别就是，在声明类的时候，新式类需要加上object关键字。</p><p>在python3中默认全是新式类</p><p>来源：<a href="https://blog.csdn.net/CHERISHGF/article/details/105300072">https://blog.csdn.net/CHERISHGF/article/details/105300072</a></p><h2 id="16-是否使用过functools中的函数？其作用是什么？"><a href="#16-是否使用过functools中的函数？其作用是什么？" class="headerlink" title="16.是否使用过functools中的函数？其作用是什么？"></a>16.是否使用过functools中的函数？其作用是什么？</h2><p>参考：<a href="https://learnku.com/docs/pymotw/functools-function-operation-toolbox/3376">https://learnku.com/docs/pymotw/functools-function-operation-toolbox/3376</a></p><p>functools用于高阶函数：指那些作用于函数或者返回其他函数的函数。通常情况下，只要是可以被当做函数调用的对象就是这个模块的目标。模块提供了许多改写或拓展函数或其他可调用对象的工具，而无需完全重写它们。</p><blockquote><p>functools 模块中提供的主要工具是 partial 类，它可以用来包装一个可调用对象，使其具有默认参数。生成的对象也是一个可调用对象，并且可以把它当做原来的函数。新生成的可调用对象可接受和原有函数完全一样的参数，并且可以在调用时接受额外的位置参数或关键词参数。partial 可以代替 lambda 为函数参数提供默认值，并同时留下一些没有指定默认值的参数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo = partial(<span class="built_in">int</span>,base=<span class="number">2</span>) <span class="comment"># 重新包装int函数为foo，将二进制转换为10进制</span></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="string">&#x27;11110111&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">247</span></span><br></pre></td></tr></table></figure><h2 id="17-列举面向对象中带双下划线的特殊方法，如：-new-、-init"><a href="#17-列举面向对象中带双下划线的特殊方法，如：-new-、-init" class="headerlink" title="17.列举面向对象中带双下划线的特殊方法，如：__new__、__init__"></a>17.列举面向对象中带双下划线的特殊方法，如：<code>__new__</code>、<code>__init__</code></h2><ul><li><code>_xx</code>前置单下划线，私有属性或方法，意思是只有类对象和子类对象自己能访问到这些变量；</li><li><code>__xx</code>前置双下划线，私有化属性或方法，无法在外部直接访问（名字重整所以访问不到,只能是允许这个类本身进行访问了。连子类也不可以）。</li><li><code>__xx__</code>：前后双下划线，系统定义名字（这就是在python中强大的魔法方法），因为变量名<code>__xx__</code>对Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。</li><li><code>xx_</code>：后置单下划线，用于避免与Python关键词的冲突</li></ul><p><code>__init__</code>是属于Python中的魔法方法。所谓魔法方法，即是Python中内置的、当进行特定操作时，会自动调用的方法，表现为方法名前后有两个下划线</p><p><code>__new__</code>方法是将对象创建出来的方法。在实际运行中，先走<code>__new__</code>方法，生成对象并返回，后调用<code>__init__</code>方法，将对象的引用传给<code>__init__</code>方法中的self</p><h2 id="18-如何判断是函数还是方法？"><a href="#18-如何判断是函数还是方法？" class="headerlink" title="18.如何判断是函数还是方法？"></a>18.如何判断是函数还是方法？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Capybara</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self,food=<span class="string">&#x27;melon&#x27;</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">small_capy = Capybara()</span><br><span class="line"><span class="built_in">print</span>(Capybara.eat)</span><br><span class="line"><span class="built_in">print</span>(small_capy.eat)</span><br><span class="line">&gt;&gt;&gt;&lt;function Capybara.eat at <span class="number">0x0000013BB6436AE8</span>&gt;</span><br><span class="line">&gt;&gt;&gt;&lt;bound method Capybara.eat of &lt;__main__.Capybara <span class="built_in">object</span> at <span class="number">0x0000013BB6395E80</span>&gt;&gt;</span><br></pre></td></tr></table></figure><p>可以看出通过类的方法调用就是函数，通过实例化调用就是方法</p><h2 id="19-静态方法和类方法区别？"><a href="#19-静态方法和类方法区别？" class="headerlink" title="19.静态方法和类方法区别？"></a>19.静态方法和类方法区别？</h2><p>实例方法只能被实例对象调用，静态方法(由@staticmethod装饰的方法)、类方法(由@classmethod装饰的方法)，可以被类或类的实例对象调用。<br> 实例方法，第一个参数必须要默认传实例对象，一般习惯用self。<br> 静态方法，参数没有要求。<br> 类方法，第一个参数必须要默认传类，一般习惯用cls。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;类三种方法语法形式&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;是类&#123;&#125;的实例方法，只能被实例对象调用&quot;</span>.<span class="built_in">format</span>(Foo))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_method</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;是静态方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;是类方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">foo.instance_method()</span><br><span class="line">foo.static_method()</span><br><span class="line">foo.class_method()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----------------&#x27;</span>)</span><br><span class="line">Foo.static_method()</span><br><span class="line">Foo.class_method()</span><br></pre></td></tr></table></figure><p>作者：python爱好者<br>链接：<a href="https://www.jianshu.com/p/212b6fdb2c50">https://www.jianshu.com/p/212b6fdb2c50</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="20-列举面向对象中的特殊成员以及应用场景"><a href="#20-列举面向对象中的特殊成员以及应用场景" class="headerlink" title="20.列举面向对象中的特殊成员以及应用场景"></a>20.列举面向对象中的特殊成员以及应用场景</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__doc__描述类的信息</span></span><br><span class="line"><span class="string">__module__表示当前操作对象在哪个模块</span></span><br><span class="line"><span class="string">__class__表示当前操作对象的类</span></span><br><span class="line"><span class="string">__del__构析方法，当对象在内存中被释放时，自动触发执行</span></span><br><span class="line"><span class="string">__call__如果类中定义了call方法对象后面加括号，触发执行</span></span><br><span class="line"><span class="string">__dict__类或对象中的所有成员</span></span><br><span class="line"><span class="string">__str__如果类中定义了str方法，打印对象时，默认输出该方法的返回值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="21-1、2、3、4、5-能组成多少个互不相同且无重复的三位数"><a href="#21-1、2、3、4、5-能组成多少个互不相同且无重复的三位数" class="headerlink" title="21.1、2、3、4、5 能组成多少个互不相同且无重复的三位数"></a>21.1、2、3、4、5 能组成多少个互不相同且无重复的三位数</h2><p>实现思路：</p><ol><li>从列表中依次取出一个数，作为百位</li><li>从列表中依次取出一个数，作为十位</li><li>列表中取出剩下的百位。</li></ol><p>实现方式有两种，都是三层循环嵌套，第一种是在每次循环中拷贝原列表，pop出元素，不影响列表完整性；第二种在每次循环pop元素，套下一层循环之后，将元素添加回去，同样不影响列表完整性。</p><p>这里使用的是方法二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)): <span class="comment"># 循环找出百位</span></span><br><span class="line">    x = <span class="built_in">str</span>(li.pop(i))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)): <span class="comment"># 在列表剩下的数中寻找十位</span></span><br><span class="line">        y = <span class="built_in">str</span>(li.pop(j))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)): <span class="comment"># 在列表剩下的数中寻找个位</span></span><br><span class="line">            z = <span class="built_in">str</span>(li[k]) <span class="comment"># 注意这里不能用pop弹出数据，因为pop之后，列表发生了改变，要依次使用列表中剩余的数字</span></span><br><span class="line">            <span class="built_in">print</span>(x+y+z, end=<span class="string">&quot;|&quot;</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        li.insert(j, <span class="built_in">int</span>(y)) <span class="comment"># 将数字送回列表，方便下一次循环</span></span><br><span class="line">    li.insert(i, <span class="built_in">int</span>(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;number of unrepeated number is&#x27;</span>, count)</span><br></pre></td></tr></table></figure><h2 id="22-什么是反射？以及应用场景？"><a href="#22-什么是反射？以及应用场景？" class="headerlink" title="22. 什么是反射？以及应用场景？"></a>22. 什么是反射？以及应用场景？</h2><p>放射：通过字符串映射object对象的方法或者属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hasattr(obj,name_str): 判断objec是否有name_str这个方法或者属性</span><br><span class="line">getattr(obj,name_str): 获取object对象中与name_str同名的方法或者函数</span><br><span class="line">setattr(obj,name_str,value): 为object对象设置一个以name_str为名的value方法或者属性</span><br><span class="line">delattr(obj,name_str): 删除object对象中的name_str方法或者属性</span><br></pre></td></tr></table></figure><p>可以用一个方法方便调用不同的函数，比如在我们做接口自动化的时候,需要通过不同的请求方式,调用不同的函数：</p><p>参考：<a href="https://www.jianshu.com/p/628f61f01a54">https://www.jianshu.com/p/628f61f01a54</a></p><p>68、metaclass作用？以及应用场景？<br>69、用尽量多的方法实现单例模式。<br>70、装饰器的写法以及应用场景。<br>71、异常处理写法以及如何主动跑出异常（应用场景）<br>72、什么是面向对象的mro<br>73、isinstance作用以及应用场景？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-def-func-a-b-这种写法有什么坑？&quot;&gt;&lt;a href=&quot;#1-def-func-a-b-这种写法有什么坑？&quot; class=&quot;headerlink&quot; title=&quot;1.def func(a,b=[]) 这种写法有什么坑？&quot;&gt;&lt;/a&gt;1.&lt;code&gt;de</summary>
      
    
    
    
    <category term="Python" scheme="http://123.57.158.5/categories/Python/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="问答题" scheme="http://123.57.158.5/tags/%E9%97%AE%E7%AD%94%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络1概述篇</title>
    <link href="http://123.57.158.5/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://123.57.158.5/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-08-26T07:41:05.000Z</published>
    <updated>2021-05-23T02:34:42.439Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络主要是由一些通用的、可编程的硬件互连而成，通过这些硬件，可以传送不同类型的数据，并且可以支持广泛日益增长的应用。</p><ul><li>计算机网络不是软件概念，还包括硬件设备</li><li>计算机网络不仅仅是信息通信，还可以支持广泛的应用</li></ul><p>网络作用范围：</p><ul><li>广域网</li><li>城域网</li><li>局域网</li></ul><table><thead><tr><th>分类</th><th>英文</th><th>范围</th><th>区域</th></tr></thead><tbody><tr><td>广域网</td><td>WAN(Wide Area Network)</td><td>几十到几千公里</td><td>跨省、跨国</td></tr><tr><td>城域网</td><td>MAN(Metro Area Network)</td><td>5km-50km</td><td>城市间</td></tr><tr><td>局域网</td><td>LAN(Local Area Network)</td><td>1km以内</td><td>地区内</td></tr></tbody></table><p>根据网络使用者分类：</p><ul><li>公用网络</li><li>专用网络</li></ul><h2 id="计算机网络的发展简史"><a href="#计算机网络的发展简史" class="headerlink" title="计算机网络的发展简史"></a>计算机网络的发展简史</h2><h3 id="互联网的发展历史"><a href="#互联网的发展历史" class="headerlink" title="互联网的发展历史"></a>互联网的发展历史</h3><h4 id="第一阶段：单个网络ARPANET"><a href="#第一阶段：单个网络ARPANET" class="headerlink" title="第一阶段：单个网络ARPANET"></a>第一阶段：单个网络ARPANET</h4><p>计算机和交换机组成</p><h4 id="第二阶段：三级结构互联网"><a href="#第二阶段：三级结构互联网" class="headerlink" title="第二阶段：三级结构互联网"></a>第二阶段：三级结构互联网</h4><p>主干网——地区网——校园网</p><h4 id="第三阶段：-多层次ISP互联网"><a href="#第三阶段：-多层次ISP互联网" class="headerlink" title="第三阶段： 多层次ISP互联网"></a>第三阶段： 多层次ISP互联网</h4><p>ISP(Internet Service Provider)：网络服务提供商</p><p>多个主干ISP全球互连——地区ISP——公司、校园、家庭</p><h3 id="中国互联网发展简史"><a href="#中国互联网发展简史" class="headerlink" title="中国互联网发展简史"></a>中国互联网发展简史</h3><p>1980年开始互联网实验——1989年第一个公用网络建立运行——1994接入国际互联网</p><p>中国当前最大的五个计算机网络：</p><ul><li>中国电信互联网CHINANET</li><li>中国联通互联网UNINET</li><li>中国移动互联网CMNET</li><li>中国教育与科研计算机网CERNET</li><li>中国科学技术网CSTNET</li></ul><h2 id="计算机网络的层次结构"><a href="#计算机网络的层次结构" class="headerlink" title="计算机网络的层次结构"></a>计算机网络的层次结构</h2><h3 id="层次结构设计的基本原则"><a href="#层次结构设计的基本原则" class="headerlink" title="层次结构设计的基本原则"></a>层次结构设计的基本原则</h3><p>如果计算机A需要与计算机B进行通信，则需要</p><ul><li>保证数据通路畅通</li><li>识别目的计算机</li><li>查询目的计算机的状态</li><li>数据是否错误</li></ul><p>分层实现不同的功能，这些功能基本可以通过三层来实现<font color="red">网络应用数据、数据可靠通信、物理网络接入</font></p><p>层次结构设计的基本原则：</p><ul><li>各层之间是相互独立的</li><li>每一层有足够的灵活性</li><li>各层之间完全解耦</li></ul><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><strong>应用层</strong>：为计算机提供接口和服务</p><p><strong>表示层</strong>：数据处理（编码解码、加码解密等）</p><p><strong>会话层</strong>：管理（建立、维护、重连）通信会话</p><p><strong>传输层</strong>：管理端到端的通信连接</p><p><strong>网络层</strong>：数据路由（决定数据在网络的路径）</p><p><strong>数据链路层</strong>：管理相邻节点之间的通信</p><p><strong>物理层</strong>：数据通信的光电物理特性</p><ul><li>OSI欲成为全球计算机都遵循的标准</li><li>OSI在市场化过程中困难重重，TCP/IP在全球范围成功运行</li><li>OSI最终并没有成为广泛使用的标准模型</li></ul><h3 id="TCP-IP四层模型（重点）"><a href="#TCP-IP四层模型（重点）" class="headerlink" title="TCP/IP四层模型（重点）"></a>TCP/IP四层模型（重点）</h3><p><strong>应用层</strong>：对应七层模型中的应用层、表示层和会话层，主要有HTTP/FTP/SMTP/POP3等协议</p><p><strong>传输层</strong>：对应七层模型中的传输层，TCP/UDP协议</p><p><strong>网络层</strong>：对应七层模型中的网络层，IP/ICMP协议</p><p><strong>网络接口层</strong>：对应七层模型中的数据链路层和物理层，Ethernet/ARP/RARP协议</p><p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200826172715303.png" alt="image-20200826172715303"></p><h3 id="TCP-IP各层之间的协议简述"><a href="#TCP-IP各层之间的协议简述" class="headerlink" title="TCP/IP各层之间的协议简述"></a>TCP/IP各层之间的协议简述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP各层实现的协议</span><br><span class="line">应用层：</span><br><span class="line">HTTP：超文本传输协议，基于TCP，使用80号端口，是用于从www服务器传输超文本到本地浏览器的传输协议。</span><br><span class="line">SMTP：简单邮件传输协议，基于TCP，使用25号端口，是一组用于由源地址到目的地址传送邮件的规则，用来控制信件的发送、中转。</span><br><span class="line">FTP：文件传输协议，基于TCP，一般上传下载用FTP服务，数据端口是20号，控制端口号是21号。</span><br><span class="line">TELNET：远程登录协议，基于TCP，使用23号端口，是Internet远程登录服务的标准协议和主要方式。为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序连接到服务器。使用明码传送，保密性差，简单方便。</span><br><span class="line">DNS：域名解析，基于UDP，使用53号端口，提供域名到IP地址之间的转换。（访问百度，是www.baidu.com，这些域名对应着IP地址）</span><br><span class="line">SSH：安全外壳协议，基于TCP，使用22号端口，为建立在应用层和传输层基础上的安全 协议。SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。（远程管理网路设备或服务器时，一般都使用ssh工具进行连接）</span><br><span class="line">传输层</span><br><span class="line">TCP：传输控制协议。一种面向连接的、可靠的、基于字节流的传输层通信协议。</span><br><span class="line">UDP：用户数据报协议。一种面向无连接的通讯协议，不可靠的，基于报文的传输层通信协议。</span><br><span class="line">SCTP：流量传输控制协议。一种面向连接的流传输协议。（可以看做TCP协议的改进）</span><br><span class="line">三种优点：</span><br><span class="line">1、多宿主的连接，TCP是单地址进行连接的，SCTP可通知对方有多个IP地址。</span><br><span class="line">2、一个TCP连接支持一个流，SCTP支持多个流，在某条路径堵塞时，将数据转移到较好的备用的路径进行传输的</span><br><span class="line">3、由于使用多条路径传输，SCTP有更好的安全性</span><br><span class="line">MPTCP：多路径传输控制协议。TCP的多路径版本。SCTP虽然在首发两端有多条路径，但实际只是使用一条路径传输，当该条路径出现故障时，不需要断开连接，而是转移到其他路径。MPTCP真正意义上实现了多路径并行传输，在连接建立阶段，建立多条路径，然后使用多条路径同时传输数据。</span><br><span class="line">网络层：</span><br><span class="line">IP：Internet协议。通过路由选择下一条IP封装后交给接口层。IP数据报是连接服务。（分IPv6和IPv4）</span><br><span class="line">ICMP：Internet控制报文协议。是网络层的补充。用于在Ping主机、路由器之间传递控制消息</span><br><span class="line">ARP：地址解析协议。通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。</span><br><span class="line">RARP：反向地址解析协议</span><br></pre></td></tr></table></figure><h2 id="现代互联网的网络拓扑"><a href="#现代互联网的网络拓扑" class="headerlink" title="现代互联网的网络拓扑"></a>现代互联网的网络拓扑</h2><p>边缘部分：家庭</p><p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200826173128291.png" alt="image-20200826173128291"></p><p>边缘部分：企业</p><p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200826173257315.png" alt="image-20200826173257315"></p><p>核心部分</p><p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200826173418414.png" alt="image-20200826173418414"></p><p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200826175317706.png" alt="image-20200826175317706"></p><p>从用户角度看互联网：</p><p>客户-服务器模式——用户向服务器请求服务，然后获得服务</p><p>对等连接（P2P）模式</p><h2 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h2><p>bps=bit/s</p><p><strong>时延</strong>：由发送时延、排队时延、传输时延、处理时延组成</p><p><strong>发送时延</strong>：发送时延=数据长度(bit)/发送速率(bit/s)</p><p>发送速率受限于计算机网卡</p><p><strong>传播时延</strong>：传输时延=传输路径距离/传播速率(bit/s)</p><p>传播速率受限于传播介质</p><p><strong>排队时延</strong>：数据包在网络设备中等待被处理的时间</p><p><strong>处理时延</strong>：数据包达到设备或者目的机器被处理所需要的时间</p><p>总时延=发送时延+排队时延+传播时延+处理时延</p><p><strong>往返时间RTT</strong>：</p><p>RTT(Route-Trip Time是评估网络质量的一项重要指标)，RTT表示的是数据报文在端到端通信中的来回一次的时间。通常使用<code>ping</code>命令查看RTT</p><h2 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h2><h3 id="物理层的作用"><a href="#物理层的作用" class="headerlink" title="物理层的作用"></a>物理层的作用</h3><ul><li>连接不同的物理设备</li><li>传输比特流</li></ul><p>连接不同物理设备的介质：双绞线、同轴电缆、光纤、红外线、无线、激光等</p><p>比特流，通过高低电平传输01数据</p><h3 id="信道基本概念"><a href="#信道基本概念" class="headerlink" title="信道基本概念"></a>信道基本概念</h3><ul><li>信道是往一个方向传送信息的媒体</li><li>一条通信电路包含一个接收信道和一个发送信道</li></ul><p>单工通信信道：只能往一个方向通信，没有反方向反馈的信道，比如有线电视、无线收音机等</p><p>半双工信通信信道：双方都可以发送和接收信息，不能双方同时发送，也不能同时接收</p><p>全双工通信信通：双方都可以同时发送和接收信息。</p><h3 id="分用-复用技术"><a href="#分用-复用技术" class="headerlink" title="分用-复用技术"></a>分用-复用技术</h3><blockquote><p>复用技术是指一种在传输路径上综合多路信道，然后恢复原机制或解除终端各信道复用技术的过程。</p><p>在数据通信中，复用技术提高了信道传输效率，有广泛应用。多路复用技术是在发送端将多路信号进行组合(如广电前端使用的混合器)，在一条专用的物理信道上实现传输，接收端再将复合信号分离出来。</p></blockquote><h2 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h2><p>物理层和数据链路层组成了TCP/IP四层模型的网络接口层</p><p>数据链路层需要解决的问题：</p><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><ul><li>‘帧’是数据链路层数据的基本单位</li><li>发送端在网络层的一段数据前后添加特点标记形成‘帧’</li><li>接收端根据前后特定标记识别出‘帧’</li></ul><p>帧首部和帧尾部是特定的控制字符（特定比特流）</p><p>例如帧首部和真尾部的控制字符：</p><p><code>SOH:000000001</code></p><p><code>EOT:00000100</code></p><p>但是如果数据里面恰好有这些比特流咋办？此时就需要学习透明传输</p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><ul><li>“透明”在计算机领域是非常重要的一个术语</li><li>在数据链路中的”透明“指的是”控制字符在帧数据中，但是要当做不存在的去处理“</li></ul><p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200831000814485.png" alt="image-20200831000814485"></p><p>当帧数据中出现了控制字符，在它前面加一个转义字符ESC，这样就不会将它识别为控制字符处理了。</p><p>但是如果数据中也出现了转义字符怎么办？很简单，再在前面加一个转义字符即可</p><h3 id="差错监测"><a href="#差错监测" class="headerlink" title="差错监测"></a>差错监测</h3><ul><li>物理层只管传输比特流，无法控制是否出错</li></ul><p>见下章</p><h2 id="数据链路层的差错检测"><a href="#数据链路层的差错检测" class="headerlink" title="数据链路层的差错检测"></a>数据链路层的差错检测</h2><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>在比特流的尾部添加一个比特位来检测</p><p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200831001652551.png" alt="image-20200831001652551"></p><p>所有位数相加，得到奇数则在尾部添加1，反之添加0。如果在传输过程中，数据发生了特定的改变，就能够一定程度上校验出来。如果传输过程过出现偶数个差错的话就很难被检测出来。</p><h3 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h3><ul><li>一种根据传输或保存的数据而<font color="red">产生固定位数校验码</font>的方法</li><li>检测数据传输或者保存后可能产生的错误</li><li>生成的数据计算出来并且<font color="red">附加到数据后面</font></li></ul><p>首先来了解<strong>模’2‘除法</strong></p><p><strong>模’2‘除法</strong>是二进制下的除法，与算术除法类似，但除法不借位，实际是“异或”操作（相同0，不同1）</p><p>生成循环冗余校验码CRC步骤：</p><ol><li>选定一个用于检验的多项式G(x)，并在数据尾部添加r个0</li><li>将添加r个0后的数据，使用<font color="red">模2除法</font>除以<font color="red">多项式的位串</font></li><li><font color="red">得到的余数</font>填充在<font color="red">原数据r个0的位置</font>得到可校验的位串</li></ol><p>例子1：使用CRC计算101001的可校验位串。</p><p><strong>第一步 选定一个用于检验的多项式G(x)，并在数据尾部添加r个0</strong><br>$$<br>G(x)=x^3+x^2+1<br>$$<br>二进制位串：1101，最高阶为3<br>$$<br>G(x)1<em>x^3+1</em>x^2+0<em>x^1+1</em>x^0<br>$$<br>r指的是最阶高数，这里为3</p><p>所以添加3个0之后为，101001<font color="red">000</font></p><p><strong>第二步 将添加r个0后的数据，使用模2除法除以多项式的位串</strong></p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200831011040853.png" alt="image-20200831011040853" style="zoom:50%;"><p><strong>第三步 得到的余数填充在原数据r个0的位置得到可校验的位串</strong></p><p>101001<font color="red">000</font> ——&gt; 101001<font color="red">001</font></p><p>发送端生成CRC码后，接收端接收的数据除以G(x)的位串，根据余数判断出错，余数不为0则出错</p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200831011434956.png" alt="image-20200831011434956" style="zoom:50%;"><p>例2：使用CRC计算10110011的可校验位串</p><p>提示G(x)：<br>$$<br>G(x)=x^4+x^3+1<br>$$<br>答案：10110011<font color="red">0100</font></p><p>几点注意：</p><ul><li>CRC的错误检测能力与位串的阶数r有关</li><li>数据链路层只进行数据的检测，不进行纠正（若出错直接丢弃）</li><li>G(x)一般采用一定的标准</li></ul><p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200831012210465.png" alt="image-20200831012210465"></p><h2 id="最大传输单元"><a href="#最大传输单元" class="headerlink" title="最大传输单元"></a>最大传输单元</h2><p><strong>最大传输单元MTU（Maximum Transmission Unit）</strong></p><p>数据链路层的数据帧也不是无限大的，MTU用来描述最大数据帧长度。数据帧过大或者过小都会影响传输的效率，过大的话回答导致时延增加，过小影响性能。<font color="red">以太网MTU一般为1500字节</font>。</p><p><strong>路径MTU</strong></p><p>假设两台通信设备之间通信经过好几个小型网络，他们的路径MTU由链路中MTU的最小值决定。</p><h2 id="以太网协议详解"><a href="#以太网协议详解" class="headerlink" title="以太网协议详解"></a>以太网协议详解</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul><li><p>MAC地址（物理地址、硬件地址）</p></li><li><p>每一个设备都拥有唯一的MAC地址</p></li><li><p>MAC地址共48个比特位，使用十六进制表示</p><p>通过<code>ipconfig -all</code>查看本机所有网络设备的MAC地址。例如<code>30-B4-93-ED-83-AF</code></p></li></ul><h3 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h3><ul><li>以太网（Ethernet）是一种使用广泛的<font color="red">局域网</font>技术</li><li>以太网是一种应用于数据链路层的协议</li><li>使用以太网可以完成<font color="red">相邻设备</font>的数据帧传输</li></ul><p>以太网的数据分为五个部分</p><table><thead><tr><th>目的地址</th><th>原地址</th><th>类型</th><th>帧数据</th><th>CRC</th></tr></thead><tbody><tr><td>6</td><td>6</td><td>2</td><td>46~1500</td><td>4</td></tr></tbody></table><p><em>注：这里单位为字节，目的MAC地址48个比特位，为6个字节</em></p><p><em>类型表示帧数据具体是什么协议的数据</em></p><p>比如帧数据为网络层的ip数据的话，它的类型为<code>0800</code>（类型为16进制表示）；ARP请求/应答的类型为<code>0806</code>；RARP请求/应答的类型为<code>8035</code></p><p><strong>MAC地址表</strong>，MAC地址与硬件接口一一对应的表</p><p>假如A设备需要发送数据给C设备，在路由器中经历的过程为：</p><ol><li>A通过网卡发送数据帧</li><li>数据帧达到路由器，路由器取出前6个字节</li><li>路由器匹配MAC地址表，找到对应的网络接口</li><li>路由器往该网络接口发送数据帧</li></ol><p><img src="/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20200901233627164.png" alt="image-20200901233627164"></p><p>但是当MAC地址表中没有C的映射信息，会这样处理：</p><ol><li>A发送数据帧之后，E检查MAC地址表，发现没有C的信息</li><li>E将广播A的数据包到除A以外的端口</li><li>E将收到来自B、C的回应，并将地址记录</li></ol><p>通过MAC表只可以完成<font color="red">相邻设备</font>的数据帧传输，如果有多个路由跨设备传输怎么办？我们继续学习网络层的内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机网络主要是由一些通用的、可编程的硬件互连而成，通过这些硬件，可以传送不同类型的数据，并且可以支持广泛日益增长的应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机网络不是软件概念，还包括硬件设备&lt;/li&gt;
&lt;li&gt;计算机网络不仅仅是信息通信，还可以支持广泛的应用&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://123.57.158.5/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式</title>
    <link href="http://123.57.158.5/2020/08/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://123.57.158.5/2020/08/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-08-20T11:47:04.000Z</published>
    <updated>2021-05-23T02:34:41.141Z</updated>
    
    <content type="html"><![CDATA[<p>复习一下正则表达式</p><p>正则表达式（regex）是一些由字符和特殊符号组成的字符串，能按照某种模式匹配一系列有相似特征的字符串</p><h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><ul><li><p>简单匹配 例如：abc   =&gt; abc</p></li><li><p>多个匹配模式 例如：abc | 12c  =&gt; abc， 12c</p></li><li><p>匹配任意字符(.)，除\n之外  例如：.  =&gt; abcdef</p></li><li><p><code>*</code>匹配0次多或多次</p></li><li><p><code>+</code>匹配一次或多次</p></li><li><p><code>?</code>匹配0次或1次</p></li><li><p><code>&#123;N&#125;</code>匹配指定的N次</p></li><li><p><code>&#123;M,N&#125;</code>匹配M-N次，最大化优先</p></li><li><p><code>\d</code>匹配数字</p></li><li><p><code>\w</code>匹配数字和字母</p></li><li><p><code>\s</code>匹配任何空格字符</p></li><li><p>边界匹配 用^匹配开头，用$匹配结尾</p></li><li><p>匹配特殊字符需要用<code>\</code>进行转义</p></li><li><p>指定匹配选项 </p><ul><li><p>使用<code>[]</code>指定要匹配的集合</p><p>例如：<code>[a-zA-Z]&#123;2&#125;</code></p></li><li><p>使用<code>[^]</code>指定<font color="red">不要</font>匹配的内容 注意是在^括号里，匹配开头是在正则的最前面</p><p>例如：<code>[^abc]&#123;2&#125;</code></p></li></ul></li></ul><h2 id="正则表达式分组"><a href="#正则表达式分组" class="headerlink" title="正则表达式分组"></a>正则表达式分组</h2><p>重复一个字符串时，可以使用()进行分组，使用<code>(?&lt;word&gt;\w+)</code>指定组名。从左向右，以分组的左括号为标志，第一个出现的组号为1，第二个为2，以此类推。</p><ul><li><p>使用()对匹配的内容分组</p><p>例如：<code>(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;</code>    匹配192.168.60.14</p></li><li><p>使用\1、\2反向引用</p><p>例如：<code>He (l..e)s her \1r.</code>    匹配He loves her lover.    He likes her liker.</p></li></ul><h2 id="贪婪模式vs非贪婪模式"><a href="#贪婪模式vs非贪婪模式" class="headerlink" title="贪婪模式vs非贪婪模式"></a>贪婪模式vs非贪婪模式</h2><p><strong>贪婪模式</strong>：在整个表达式匹配成功的前提下，尽可能多的匹配</p><p><strong>非贪婪模式</strong>：在整个表达式匹配成功的前提下，以最少的匹配字符</p><p>默认是贪婪模式</p><p>非贪婪模式只需在匹配pattern中加上<code>?</code>：</p><p>表达式<code>ab.*?c</code>    测试数据：abacaxcd，匹配结果：abac</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>re模块</p><ul><li><p>正则编译 — compile()函数<br><code>compile(pattern,flags=0)</code><br>使用任何可选的标记来编译正则表达式的模式,然后返回一个正则表达式的【对象】或者叫pattern</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;([a-z]+) ([a-z]+)&#x27;</span>,re.I)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;hello wdnmd hello&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;hello wdnmd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;wdnmd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">2</span>)<span class="comment"># 返回第二个分组匹配成功的子串索引</span></span><br><span class="line">(<span class="number">6</span>, <span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()</span><br><span class="line">(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;wdnmd&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>正则匹配 — match()函数、search()函数、findall()函数</p><ol><li>match() 函数<br><code>match(pattern,string,flags=0)</code><br>尝试使用带有可选的标记的正则表达式的模式来匹配字符串。如果匹配成功，就返回匹配【对象】；如果失败，就返回【None】</li><li>search()函数<br><code>search(pattern, string, flags=0)</code><br>使用可选标记搜索字符串中第一次出现的正则表达式模式。如果匹配成功，则返回匹配【对象】；如果失败，则返回【None】<br>match() 和 search() 的区别<br>match()从头开始查找，如果从第1个就不匹配，则立马停止。<br>search()会检索整个字符串</li><li>findall() 函数<br><code>findall(pattern,string[,flags])</code><br>查找字符串中所有(非重复)出现的正则表达式模式，并返回一个匹配【列表】</li></ol></li><li><p>正则分组 — group(num) 函数、groups()函数、groupdict()函数</p><ol><li>group(num) 函数<br>返回整个匹配对象或编号为num的特定子组的【字符串】</li><li>groups() 函数<br>返回一个包含所有匹配子组的【元组】；如果没有匹配的，则返回一个【空元组】</li><li>groupdict() 函数<br>返回一个【字典】，其中key为子组名，value为子组内容对象</li></ol></li><li><p>正则分割 — split()函数<br><code>split(pattern, string, max = 0)</code> – max：可指定分割次数<br>根据正则表达式的模式分隔符，split函数将字符串分割为列表，然后返回成功匹配的【列表】，分割最多操作max次（默认分割所有成功的位置）</p></li><li><p>正则替换、更换位置和修改内容 — sub()函数<br><code>sub(pattern, repl, string, max = 0)</code> – 可指定替换次数<br>使用repl替换string中每一个匹配的子串后返回替换后的【字符串】，最多操作max次（默认替换所有）</p></li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">re.I</td><td align="left">使匹配对大小写不敏感</td></tr><tr><td align="left">re.L</td><td align="left">做本地化识别（locale-aware）匹配</td></tr><tr><td align="left">re.M</td><td align="left">多行匹配，影响 ^ 和 $</td></tr><tr><td align="left">re.S</td><td align="left">使 . 匹配包括换行在内的所有字符</td></tr><tr><td align="left">re.U</td><td align="left">根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td></tr><tr><td align="left">re.X</td><td align="left">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><h2 id="常用正则匹配"><a href="#常用正则匹配" class="headerlink" title="常用正则匹配"></a>常用正则匹配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 匹配国内电话号码</span><br><span class="line">\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\&#123;7,8&#125;</span><br><span class="line"># 18位身份证</span><br><span class="line">^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;3&#125;)([0-9]|X)$</span><br><span class="line"># 匹配email</span><br><span class="line">[\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+(?:\.[\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\w](?:[\w-]*[\w])?\.)+[\w](?:[\w-]*[\w])?</span><br></pre></td></tr></table></figure><p>更多内容<a href="https://www.runoob.com/python3/python3-reg-expressions.html">https://www.runoob.com/python3/python3-reg-expressions.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;复习一下正则表达式&lt;/p&gt;
&lt;p&gt;正则表达式（regex）是一些由字符和特殊符号组成的字符串，能按照某种模式匹配一系列有相似特征的字符串&lt;/p&gt;
&lt;h2 id=&quot;匹配规则&quot;&gt;&lt;a href=&quot;#匹配规则&quot; class=&quot;headerlink&quot; title=&quot;匹配规则&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Python" scheme="http://123.57.158.5/categories/Python/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="正则表达式" scheme="http://123.57.158.5/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Flask模板的介绍与应用</title>
    <link href="http://123.57.158.5/2020/08/14/flask-template/"/>
    <id>http://123.57.158.5/2020/08/14/flask-template/</id>
    <published>2020-08-14T11:19:02.000Z</published>
    <updated>2021-06-07T05:18:32.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板介绍"><a href="#模板介绍" class="headerlink" title="模板介绍"></a>模板介绍</h2><p>Jinja2是flask的默认模板引擎，自带</p><p>模板的基本配置</p><ul><li><code>template_folder=&#39;templates&#39;</code>    模板的默认目录，可以不用另外指定</li><li><code>render_template()</code>    (x)html自动转义</li><li><code>render_template_string()</code>    字符串自动转义</li><li>![截屏2021-06-07 下午1.17.02](/Users/gan/blog/source/_posts/flask-template/截屏2021-06-07 下午1.17.02.png)</li><li>全局函数和辅助对象    增强模板的功能</li></ul><p><strong>转义</strong>就是把特殊意义的字符串显示出来</p><p><a href="https://tool.oschina.net/commons?type=2">字符转义对照表</a></p><p><strong>全局对象</strong>：</p><ul><li>config——Flask的配置信息</li><li>request——请求对象</li><li>session——会话对象</li><li>g——请求相关的全局变量（如：g.user）</li></ul><p>就是模板可以直接通过<code>&#123;&#123; config &#125;&#125;</code>等获取相关信息</p><p><strong>全局函数</strong></p><ul><li><p><code>url_for()</code></p><p>URL解析函数（如：静态文件地址解析、链接跳转地址解析 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(url_for(<span class="string">&#x27;hello_world&#x27;</span>))</span><br><span class="line">    <span class="comment"># _external=True是打印完整URL</span></span><br><span class="line">    <span class="built_in">print</span>(url_for(<span class="string">&#x27;hello_world&#x27;</span>, _external=<span class="literal">True</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! wdnmd&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>get_flashed_messages()</code></p><p>会话消息</p></li></ul><p><strong>上下文处理器</strong>：</p><ul><li><p>在模板的上下文中添加新的内容</p></li><li><p>内容可以是变量，也可以是函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xx <span class="keyword">import</span> constants</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.context_processor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject_constants</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(&#123;<span class="string">&#x27;constants&#x27;</span>:contants&#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">将constants的内容传入模板</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="模板中变量的使用"><a href="#模板中变量的使用" class="headerlink" title="模板中变量的使用"></a>模板中变量的使用</h2><p>回顾模板的渲染机制：</p><ul><li>从磁盘中读取html字符串</li><li>将满足特定规则的内容进行替换</li><li>发送给浏览器展示</li></ul><p>模板变量的语法:</p><p><code>&#123;&#123; ojbect.attribute &#125;&#125;</code></p><p>dict类型数据的渲染<br>list/tuple类型数据的渲染<br>list/tuple嵌套dict复杂类型数据的渲染</p><p>以上都与django模板DTL类似，列表元组传递用的是<code>list[index]</code>，更接近于python语法</p><p>传递方法略有区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render_template(<span class="string">&#x27;index.html&#x27;</span>,<span class="built_in">object</span>=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><h2 id="模板标签"><a href="#模板标签" class="headerlink" title="模板标签"></a>模板标签</h2><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tag %&#125;</span><br></pre></td></tr></table></figure><p>和DTL一样可以使用条件变量 循环等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 不同与DTL，.items()要加括号</span><br><span class="line">&#123;% for k,v in dict.items() %&#125;</span><br><span class="line">&lt;p class=&#x27;&#123;&#123; loop.cycle(&#x27;odd&#x27;,&#x27;even&#x27;) &#125;&#125;&#x27;&gt;&#123;&#123; k &#125;&#125;,&#123;&#123; v &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/08/14/flask-template/image-20200815114709812.png" alt="image-20200815114709812"></p><p>思考：如果要在for循环中使用continue/break怎么办？</p><ul><li>直接在python中添加扩展</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个扩展用于在模板中添加break和continue</span></span><br><span class="line">app.jinja_env.add_extension(<span class="string">&#x27;jinja2.ext.loopcontrols&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其他的扩展可以查看jinja2官方文档</p><ul><li>去除HTML中多余的空白（浏览器渲染时候模板标签会自动加入很多空白）：</li></ul><p>在块的开始或结束位置放置一个减号(-)，不能有空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for item in seq -%&#125;</span><br><span class="line">&#123;&#123; item &#125;&#125;</span><br><span class="line">&#123;%- endfor %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>设置变量，赋值操作</p><p>先设置，后使用，也可以通过import导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set key,value = (1,2) %&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用代码块，实现块级作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% with %&#125;</span><br><span class="line">&#123;% set value = 42 %&#125;</span><br><span class="line">&#123;&#123; value &#125;&#125;只在代码块中有效</span><br><span class="line">&#123;% endwith %&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="模板语法之过滤器"><a href="#模板语法之过滤器" class="headerlink" title="模板语法之过滤器"></a>模板语法之过滤器</h2><ul><li><p>过滤器：修改变量（如：格式化显示）</p></li><li><p>和DTL类似，用管道符号<code>|</code>分割</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; name|striptags &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以链式调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; name|striptags|title &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以用圆括号传递可选参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; list|join(&#x27;,&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="过滤器的使用"><a href="#过滤器的使用" class="headerlink" title="过滤器的使用"></a>过滤器的使用</h3><ul><li><p>使用管道符号（|)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value|safe &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% filter upper %&#125;</span><br><span class="line">this text becomes uppercase</span><br><span class="line">&#123;% endfilter %&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内置过滤器举例"><a href="#内置过滤器举例" class="headerlink" title="内置过滤器举例"></a>内置过滤器举例</h3><ul><li><p>求绝对值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value|abs &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认值显示 ，boolean参数代表是否作用于为空值的参数，默认为False</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;# default(value,default_value=&#x27;&#x27;,boolean=False) #&#125;</span><br><span class="line">&#123;&#123; value|default(&#x27;默认值&#x27;) &#125;&#125;</span><br><span class="line">or</span><br><span class="line">&#123;&#123; value|d(&#x27;默认值&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>html转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value|escape &#125;&#125;</span><br><span class="line">or</span><br><span class="line">&#123;&#123; vlaue|e &#125;&#125;</span><br></pre></td></tr></table></figure><p>用于传递并显示html文本，jinja模板模式是自动转义的。所以如果需要，可以将转义设置为手动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/filter&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_escape_filter</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 转义使用过滤器 &quot;&quot;&quot;</span></span><br><span class="line">    html = <span class="string">&#x27;&lt;h2&gt;hello&lt;/h2&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;xxx.html&#x27;</span>,html=html)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;# 手动转义 #&#125;</span><br><span class="line">&#123;% autoescape false %&#125;</span><br><span class="line">&#123;# 不进行转义 #&#125;</span><br><span class="line">&#123;&#123; html &#125;&#125;</span><br><span class="line">&#123;# 进行转义 #&#125;</span><br><span class="line">&#123;&#123; html|escape &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure></li><li><p>富文本内容转义显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; vlaue|safe &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>倒序显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; vlaue|reverse &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>更多内容查看官方文档</p><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><ul><li><p>使用装饰器注册</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.template_filter(<span class="params"><span class="string">&#x27;reverse&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_filter</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s[::<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p>调用函数注册</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_filter</span>(<span class="params">s</span>):</span></span><br><span class="line"><span class="keyword">return</span> s[::-<span class="number">1</span>]</span><br><span class="line">app.jinja_env.<span class="built_in">filter</span>[<span class="string">&#x27;reverse&#x27;</span>] = reverse_filter</span><br></pre></td></tr></table></figure></li></ul><h3 id="转义显示"><a href="#转义显示" class="headerlink" title="转义显示"></a>转义显示</h3><ul><li><p>视为字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &#x27;&#123;&#123; &#125;&#125; &#123;% %&#125;&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用raw标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">&#123;% for key,value in data.items %&#125;</span><br><span class="line">&#123;&#123; key &#125;&#125;:&#123;&#123; value &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="模板全局函数"><a href="#模板全局函数" class="headerlink" title="模板全局函数"></a>模板全局函数</h2><p>全局函数可以在模板中直接使用</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for i in range(10) %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; i &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>其他全局函数：</p><p><code>dict(**items)</code></p><p><code>lipsum(n=5,html=True,min=20,max=100)</code>自动生成“乱数假文”，用于测试网页排版设计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set lipsum_context=lipsum(n=5,html=True,min=20,max=100) %&#125;</span><br><span class="line">&#123;&#123; lipsum_context &#125;&#125;</span><br></pre></td></tr></table></figure><p><code>cycler(*items)</code>——可用于css类名的循环</p><p>举例：循环打印1到100，每一行显示一个数字，每一行的字体颜色也不同（通过css控制颜色）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;giao&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .row1&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .row2&#123;</span><br><span class="line">            color: aqua;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#123;% set class_name = cycler(&quot;row1&quot;,&quot;row2&quot;) %&#125;</span><br><span class="line">&#123;% for i in range(100) %&#125;</span><br><span class="line">    &lt;p class=&quot;&#123;&#123; class_name.next() &#125;&#125;&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><code>join(sep=&#39;,&#39;)</code>——可用于字符串的拼接</p><h2 id="模板中的宏"><a href="#模板中的宏" class="headerlink" title="模板中的宏"></a>模板中的宏</h2><p>把常用的功能抽取出来，实现可重用；简单理解：宏≈函数；宏可以写在单独的html文件中。</p><p>使用宏——像调用函数一样调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro input(name,value=&#x27;&#x27;,type=&#x27;text&#x27;,size=20) -%&#125;</span><br><span class="line">&lt;input type=&quot;&#123;&#123; type &#125;&#125;&quot; name=&quot;&#123;&#123; name &#125;&#125;&quot; vlaue=&quot;&#123;&#123; vlaue|e &#125;&#125;&quot; size=&quot;&#123;&#123; sieze &#125;&#125;&quot;&gt;</span><br><span class="line">&#123;%- endmacro %&#125;</span><br></pre></td></tr></table></figure><p>比如调用自定义的input宏：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>macro<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% macro input(type_name,name,value=&#x27;&#x27;) -%&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;&#123;&#123; type_name &#125;&#125;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&#123;&#123; name &#125;&#125;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; value &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">&#123;%- endmacro %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;default&quot;&gt;--&gt;</span></span><br><span class="line">&#123;&#123; input(&#x27;text&#x27;,&#x27;username&#x27;,&#x27;default&#x27;) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件中宏的使用"><a href="#文件中宏的使用" class="headerlink" title="文件中宏的使用"></a>文件中宏的使用</h3><ol><li><p>将前面定义的宏（body中macro的部分）单独保存为forms.html</p></li><li><p>导入（类似python的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% import &#x27;forms.html&#x27; as forms %&#125;</span><br><span class="line">&lt;!-- or --&gt;</span><br><span class="line">&#123;% from &#x27;forms.html&#x27; import input %&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; forms.input(&#x27;username&#x27;) &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="模板的继承之继承语法"><a href="#模板的继承之继承语法" class="headerlink" title="模板的继承之继承语法"></a>模板的继承之继承语法</h2><p>如下场景如何设计：</p><ul><li>每个页面都引用了公共的头部，js，css——继承</li><li>有几个页面结构和内容极其相似（如：页脚）——继承之包含</li></ul><p>继承实现（和DTL类似）：</p><ol><li><p>将可变的部分圈出来（base.html)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block siderbar %&#125;</span><br><span class="line">&lt;!--菜单栏的内容--&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承父模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br></pre></td></tr></table></figure></li><li><p>填充新的内容（index.html)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block siderbar %&#125;</span><br><span class="line">&lt;!--菜单栏的内容--&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li><li><p>复用父模板的内容（可选）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block siderbar %&#125;</span><br><span class="line">&#123;&#123; super() &#125;&#125;</span><br><span class="line">&lt;!--菜单栏的内容--&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="模板的继承之包含语法"><a href="#模板的继承之包含语法" class="headerlink" title="模板的继承之包含语法"></a>模板的继承之包含语法</h2><p>包含实现：</p><ol><li><p>将拆出来的部分包进来（index.html)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;!-- 页面主要内容区域 --&gt;</span><br><span class="line">&#123;# 公用的footer #&#125;</span><br><span class="line">&#123;% include &quot;footer.html&quot; %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p><strong>include标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;# ingore missing 如果模板不存在，jinja2会忽略这条语句 #&#125;</span><br><span class="line">&#123;% include &quot;footer.html&quot; ignore missing %&#125;</span><br><span class="line">&#123;# with context/without context 是否携带当前页面的上下文 #&#125;</span><br><span class="line">&#123;% include &quot;footer.html&quot; ignore missing with context %&#125;</span><br><span class="line">&#123;% include &quot;footer.html&quot; ignore missing without context %&#125;</span><br></pre></td></tr></table></figure><p><strong>代码复用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block title %&#125;</span><br><span class="line">I am title</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&lt;h1&gt;&#123;&#123; self.title() &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&#123;% block body %&#125;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="消息闪现"><a href="#消息闪现" class="headerlink" title="消息闪现"></a>消息闪现</h2><p>闪现系统的基本工作方式是：在且只在下一个请求中访问上一个请求结束时记录的消息。</p><p>实现步骤：</p><ol><li><p>在视图中产生一个消息（提示/警告/错误）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash(msg_content,msg_type)</span><br></pre></td></tr></table></figure><p>参数msg_content: 消息内容</p><p>参数msg_type: 消息类型</p></li><li><p>在模板中展示消息</p><p><code>get_flashed_messages(category_filter=[&quot;error&quot;])</code></p><p>参数category_filter: 对产生的消息按类别查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=flashes&gt;</span><br><span class="line">&#123;% for category,message in get_flashed_messages(with_categories=true) %&#125;</span><br><span class="line">&lt;li class=&quot;&#123;&#123; category &#125;&#125;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li></ol><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, flash, redirect</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 消息通知用到了session，基于安全的考虑需要加密</span></span><br><span class="line">app.secret_key = <span class="string">&#x27;abacdef&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    flash(<span class="string">&#x27;this is a notify&#x27;</span>, <span class="string">&#x27;info&#x27;</span>)</span><br><span class="line">    flash(<span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/flash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/flash&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flash_msg</span>():</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;flash_msg.html&quot;</span>)</span><br></pre></td></tr></table></figure><p>flash_msg.html:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;flash message test&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .warning&#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            color: #fff;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;flash message test&lt;/h1&gt;</span><br><span class="line">&lt;!-- 过滤出消息通知中的warning类型，并传递消息的类型参数 --&gt;</span><br><span class="line">&#123;% for category,message in get_flashed_messages(with_categories=true,category_filter=[&quot;warning&quot;]) %&#125;</span><br><span class="line">    &lt;p class=&quot;&#123;&#123;category &#125;&#125;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>此时访问主页时候，会自动跳转到flash message页面，消息闪现的内容也是来自上一个请求（即主页），如果刷新flash message页面，消息闪现内容会消失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模板介绍&quot;&gt;&lt;a href=&quot;#模板介绍&quot; class=&quot;headerlink&quot; title=&quot;模板介绍&quot;&gt;&lt;/a&gt;模板介绍&lt;/h2&gt;&lt;p&gt;Jinja2是flask的默认模板引擎，自带&lt;/p&gt;
&lt;p&gt;模板的基本配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;templ</summary>
      
    
    
    
    <category term="Python" scheme="http://123.57.158.5/categories/Python/"/>
    
    <category term="Flask" scheme="http://123.57.158.5/categories/Python/Flask/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="Flask" scheme="http://123.57.158.5/tags/Flask/"/>
    
    <category term="Jinja2" scheme="http://123.57.158.5/tags/Jinja2/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（实践）</title>
    <link href="http://123.57.158.5/2020/08/13/linux3/"/>
    <id>http://123.57.158.5/2020/08/13/linux3/</id>
    <published>2020-08-13T15:35:41.000Z</published>
    <updated>2021-05-23T02:34:39.752Z</updated>
    
    <content type="html"><![CDATA[<p>实现支持异步任务的线程池</p><p><img src="/2020/08/13/linux3/image-20200814085740093.png" alt="image-20200814085740093"></p><ul><li>了解python的同步原语</li><li>实现线程安全的队列</li><li>实现基本任务对象</li><li>了解线程池</li><li>实现任务处理线程</li><li>实现任务处理线程池</li><li>实现异步任务处理对象</li></ul><h2 id="python同步原语"><a href="#python同步原语" class="headerlink" title="python同步原语"></a>python同步原语</h2><p><strong>互斥锁</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用线程锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="comment"># 加锁</span></span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="comment"># 解锁</span></span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure><p><strong>条件变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用条件变量,Condition底层实现了互斥锁配合使用</span></span><br><span class="line">condition = threading.Condition()</span><br><span class="line"><span class="comment"># 加锁</span></span><br><span class="line">condition.acquire()</span><br><span class="line"><span class="comment"># 解锁</span></span><br><span class="line">condition.release()</span><br><span class="line"><span class="comment"># 等待</span></span><br><span class="line">condition.wait()</span><br><span class="line"><span class="comment"># 通知</span></span><br><span class="line">condition.notify()</span><br></pre></td></tr></table></figure><h2 id="实现线程的安全队列Queue"><a href="#实现线程的安全队列Queue" class="headerlink" title="实现线程的安全队列Queue"></a>实现线程的安全队列Queue</h2><ul><li><p>队列用于存放多个元素，是存放各种元素的”池“</p></li><li><p>实现安全队列步骤：</p><ol><li>获取当前队列的数量</li><li>往队列放入元素</li><li>从队列取出元素</li></ol></li><li><p>队列可能有多个线程同时操作，因此需要保证线程安全</p><p>多个线程同时访问队列元素，要保证多个线程获取的串行。此时需要<strong>使用“锁”保护队列</strong></p><p>队列元素为空时获取队列元素，会发生阻塞，需要等待队列不为空。此时需要<strong>使用条件变量等待队列元素</strong></p></li></ul><p>queue.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding=utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程安全的队列</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingSafeQueueException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程安全队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingSafeQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, max_size=<span class="number">0</span></span>):</span></span><br><span class="line">        self.queue = []</span><br><span class="line">        self.max_size = max_size</span><br><span class="line">        self.lock = threading.Lock()</span><br><span class="line">        self.condition = threading.Condition()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前队列元素的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 多线程调用可能会影响队列大小，需要进行加锁和解锁操作</span></span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        size = <span class="built_in">len</span>(self.queue)</span><br><span class="line">        self.lock.release()</span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 往队列里面放入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.max_size != <span class="number">0</span> <span class="keyword">and</span> self.size() &gt; self.max_size:</span><br><span class="line">            <span class="keyword">return</span> ThreadingSafeQueueException()</span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        self.queue.append(item)</span><br><span class="line">        self.lock.release()</span><br><span class="line">        <span class="comment"># 当队列为空，可能会发生阻塞。往队列放入元素需要通知阻塞的线程继续执行</span></span><br><span class="line">        self.condition.acquire()</span><br><span class="line">        self.condition.notify()</span><br><span class="line">        self.condition.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">batch_put</span>(<span class="params">self, item_list</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(item_list, <span class="built_in">list</span>):</span><br><span class="line">            item_list = <span class="built_in">list</span>(item_list)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> item_list:</span><br><span class="line">            self.put(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从队列中取出元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self, block=<span class="literal">False</span>, timeout=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        block:当队列中没有元素时，是否阻塞去等待</span></span><br><span class="line"><span class="string">        timeout:阻塞等待时间</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.size() == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 需要阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> block:</span><br><span class="line">                self.condition.acquire()</span><br><span class="line">                self.condition.wait(timeout=timeout)</span><br><span class="line">                self.condition.release()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        item = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 再次判断队列长度。为保持操作的原子性，操作需要在线程锁中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.queue) &gt; <span class="number">0</span>:</span><br><span class="line">            item = self.queue.pop()</span><br><span class="line">        self.lock.release()</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        item = self.queue[index]</span><br><span class="line">        self.lock.release()</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试队列是否成功：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = ThreadingSafeQueue(max_size=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">produceor</span>():</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            queue.put(<span class="number">1</span>)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = queue.pop(block=<span class="literal">True</span>,timeout=<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;get item form queue: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(item))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    thread1 = threading.Thread(target=produceor)</span><br><span class="line">    thread2 = threading.Thread(target=consumer)</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">get item form queue: 1</span></span><br><span class="line"><span class="string">get item form queue: None</span></span><br><span class="line"><span class="string">get item form queue: 1</span></span><br><span class="line"><span class="string">get item form queue: None</span></span><br><span class="line"><span class="string">get item form queue: 1</span></span><br><span class="line"><span class="string">get item form queue: None</span></span><br><span class="line"><span class="string">get item form queue: 1</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 生产者append1之后，消费者取到了，与此同时生产者休眠三秒，消费者休眠一秒。一秒后消费者取到空值，此时进行等待，两秒后，生成者append1，重复。。。</span></span><br></pre></td></tr></table></figure><h2 id="实现基本任务对象Task"><a href="#实现基本任务对象Task" class="headerlink" title="实现基本任务对象Task"></a>实现基本任务对象Task</h2><p>实现基本任务对象：通过任务参数、任务唯一标记（uuid）、任务具体的执行逻辑</p><p>task.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding=utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本任务对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 任务具体逻辑 ，通过函数引用传递过来</span></span><br><span class="line">        self.<span class="built_in">callable</span> = func</span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line">        self.<span class="built_in">id</span> = uuid.uuid4()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Task id: &#x27;</span> + <span class="built_in">str</span>(self.<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure><p>测试基本任务对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;this is a task test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    task = Task(func=my_func)</span><br><span class="line">    <span class="built_in">print</span>(task)</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Task id: 31be88be-8d02-4ed6-908a-f28592c35898</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><ul><li>线程池是存放多个线程的容器</li><li>CPU调度线程执行后不会销毁线程，将线程放回线程池重复利用</li></ul><h3 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h3><ul><li>线程是稀缺资源，不应该频繁创建和销毁</li><li>架构解耦，线程创建和业务处理解耦，更加优雅</li><li>线程池是使用线程的最佳实践</li></ul><h2 id="实现任务处理线程ProcessThread"><a href="#实现任务处理线程ProcessThread" class="headerlink" title="实现任务处理线程ProcessThread"></a>实现任务处理线程ProcessThread</h2><ul><li>任务处理线程需要不断的从任务队列里取任务执行</li><li>任务处理线程需要有一个标记，标记线程什么时候应该停止</li></ul><p>实现任务处理线程：<br>基本属性（任务队列，标记）、线程执行的逻辑（run）、线程停止（stop）</p><p>pool.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding=utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operate_system.task <span class="keyword">import</span> Task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 实现任务处理线程 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, task_queue, *args, **kwargs</span>):</span></span><br><span class="line">        threading.Thread.__init__(self, *args, **kwargs)</span><br><span class="line">        <span class="comment"># 线程停止标记</span></span><br><span class="line">        self.dismiss_flag = threading.Event()</span><br><span class="line">        <span class="comment"># 任务队列（处理线程不断从队列取出元素处理）</span></span><br><span class="line">        self.task_queue = task_queue</span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 判断线程是否被要求停止</span></span><br><span class="line">            <span class="keyword">if</span> self.dismiss_flag.is_set():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            task = self.task_queue.pop()</span><br><span class="line">            <span class="comment"># 判断是否为我们定义的基本任务对象</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(task,Task):</span><br><span class="line">                <span class="comment"># 若不是 忽略任务</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 执行task实际逻辑（是透过函数调用引进来的）</span></span><br><span class="line">            result = task.<span class="built_in">callable</span>(*task.args,**task.kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dismiss</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.dismiss_flag.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.dismiss()</span><br></pre></td></tr></table></figure><h2 id="实现任务处理线程池Pool"><a href="#实现任务处理线程池Pool" class="headerlink" title="实现任务处理线程池Pool"></a>实现任务处理线程池Pool</h2><ul><li>存放多个任务处理线程</li><li>负责多个线程的启停</li><li>管理向线程池的提交任务，下发给线程去执行</li></ul><p>实现任务处理线程池：基本属性、提交任务（put、batch_put）、线程启停（start、join）、线程池大小（size）</p><p>pool.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operate_system.queue <span class="keyword">import</span> ThreadingSafeQueue</span><br><span class="line"><span class="keyword">from</span> operate_system.task <span class="keyword">import</span> Task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 实现线程池 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> size:</span><br><span class="line">            <span class="comment"># 约定线程池大小为cput核心数的两倍（最佳实践）</span></span><br><span class="line">            size = psutil.cpu_count() * <span class="number">2</span></span><br><span class="line">            <span class="comment"># 线程池</span></span><br><span class="line">            self.pool = ThreadingSafeQueue(size)</span><br><span class="line">            <span class="comment"># 任务队列</span></span><br><span class="line">            self.task_queue = ThreadingSafeQueue()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                self.pool.put(ProcessThread(self.task_queue))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(self.pool.size()):</span><br><span class="line">            thread = self.pool.get(index)</span><br><span class="line">            thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 停止线程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(self.pool.size()):</span><br><span class="line">            thread = self.pool.get(index)</span><br><span class="line">            thread.stop()</span><br><span class="line">        <span class="comment"># 清空线程池</span></span><br><span class="line">        <span class="keyword">while</span> self.pool.size():</span><br><span class="line">            thread = self.pool.pop()</span><br><span class="line">            thread.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 往线程池提交任务</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(task, Task):</span><br><span class="line">            <span class="keyword">raise</span> TaskErrorException()</span><br><span class="line">        self.task_queue.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 批量提交</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">batch_put</span>(<span class="params">self, task_list</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(task_list, <span class="built_in">list</span>):</span><br><span class="line">            task_list = <span class="built_in">list</span>(task_list)</span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> task_list:</span><br><span class="line">            self.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.pool.size()</span><br></pre></td></tr></table></figure><h2 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleTask</span>(<span class="params">task.Task</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">callable</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="built_in">callable</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span>():</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;this is SimpleTask callable function 1.&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;this is SimpleTask callable function 2.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="comment"># 1.初始化一个线程池</span></span><br><span class="line">    test_pool = pool.ThreadPool()</span><br><span class="line">    test_pool.start()</span><br><span class="line">    <span class="comment"># 2.生成一系列的任务</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        simple_task = SimpleTask(process)</span><br><span class="line">        <span class="comment"># 3.往线程池提交任务执行</span></span><br><span class="line">        test_pool.put(simple_task)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p><img src="/2020/08/13/linux3/image-20200821193453104.png" alt="image-20200821193453104"></p><p>可以看到并发执行的函数</p><h2 id="实现异步任务处理AsyncTask"><a href="#实现异步任务处理AsyncTask" class="headerlink" title="实现异步任务处理AsyncTask"></a>实现异步任务处理AsyncTask</h2><p>为了清楚的知道任务什么时候开始和结束。</p><p>需求：需要给任务添加一个标记，任务完成后，则标记为已完成。任务完成时，可直接获取任务运行结果。任务未完成时，获取任务结果，会阻塞获取线程。</p><p>实现AsyncTask：设置运行结果<code>(set_result)</code>，获取运行结果<code>(get_result)</code></p><p>在task.py中添加AsyncTask类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>(<span class="params">Task</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 异步任务处理对象 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,func, *args, **kwargs</span>):</span></span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line">        self.condition = threading.Condition()</span><br><span class="line">        <span class="built_in">super</span>().__init__(func, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置运行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span>(<span class="params">self,result</span>):</span></span><br><span class="line">        self.condition.acquire()</span><br><span class="line">        self.result = result</span><br><span class="line">        <span class="comment"># 通知可能在等待的线程</span></span><br><span class="line">        self.condition.notify()</span><br><span class="line">        self.condition.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取运行结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.condition.acquire()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.result:</span><br><span class="line">            self.condition.wait()</span><br><span class="line">        result= self.result</span><br><span class="line">        self.condition.release()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>同时需要给任务处理线程添加任务结果<code>set_result</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operate_system.queue <span class="keyword">import</span> ThreadingSafeQueue</span><br><span class="line"><span class="keyword">from</span> operate_system.task <span class="keyword">import</span> Task, AsyncTask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 实现任务处理线程 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 判断线程是否被要求停止</span></span><br><span class="line">            <span class="keyword">if</span> self.dismiss_flag.is_set():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            task = self.task_queue.pop()</span><br><span class="line">            <span class="comment"># 判断是否为我们定义的基本任务对象</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(task, Task):</span><br><span class="line">                <span class="comment"># 若不是 忽略任务</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 执行task实际逻辑（是透过函数调用引进来的）</span></span><br><span class="line">            result = task.<span class="built_in">callable</span>(*task.args, **task.kwargs)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(task,AsyncTask):</span><br><span class="line">                task.set_result(result)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>随后我们对异步任务进行测试</p><p>test.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_test</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">async_process</span>():</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">            num += i</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.初始化一个线程池</span></span><br><span class="line">    test_pool = pool.ThreadPool()</span><br><span class="line">    test_pool.start()</span><br><span class="line">    <span class="comment"># 2.生成一系列的任务</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        async_task = task.AsyncTask(func=async_process)</span><br><span class="line">        <span class="comment"># 3.往线程池提交任务执行</span></span><br><span class="line">        test_pool.put(async_task)</span><br><span class="line">        result = async_task.get_result()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get result &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(result))</span><br></pre></td></tr></table></figure><p>运行后输出了结果，说明这个异步任务 任务完成时，可直接获取任务运行结果</p><p>接下来判断异步任务的等待(wait)是否起作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_test2</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 测试是否可以真正的等待（wait）&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">async_process</span>():</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">            num += i</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.初始化一个线程池</span></span><br><span class="line">    test_pool = pool.ThreadPool()</span><br><span class="line">    test_pool.start()</span><br><span class="line">    <span class="comment"># 2.生成一系列的任务</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        async_task = task.AsyncTask(func=async_process)</span><br><span class="line">        <span class="comment"># 3.往线程池提交任务执行</span></span><br><span class="line">        test_pool.put(async_task)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get result in timestamp:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(time.time())))</span><br><span class="line">        result = async_task.get_result()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get result in timestamp:&#123;&#125;,&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(time.time()),result))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 运行后结果：</span></span><br><span class="line"><span class="string"> get result in timestamp:1598018392</span></span><br><span class="line"><span class="string">get result in timestamp:1598018393,19901</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>给task函数添加了1秒等待，在这1秒中，<code>get_result</code>如果没有获得结果会持续等待，说明等待起了作用</p><p>接下来测试没有等待是否可以获取结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_test3</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 测试没有等待是否也可以正常获取结果&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">async_process</span>():</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">            num += i</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.初始化一个线程池</span></span><br><span class="line">    test_pool = pool.ThreadPool()</span><br><span class="line">    test_pool.start()</span><br><span class="line">    <span class="comment"># 2.生成一系列的任务</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        async_task = task.AsyncTask(func=async_process)</span><br><span class="line">        <span class="comment"># 3.往线程池提交任务执行</span></span><br><span class="line">        test_pool.put(async_task)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get result in timestamp:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(time.time())))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 可以转而去处理其他任务</span></span><br><span class="line">        <span class="comment"># 此时get_result实际上不会发生等待的</span></span><br><span class="line">        result = async_task.get_result()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get result in timestamp:&#123;&#125;,&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(time.time()), result))</span><br><span class="line">        </span><br><span class="line"> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 运行结果为：</span></span><br><span class="line"><span class="string"> get result in timestamp:1598020223</span></span><br><span class="line"><span class="string">get result in timestamp:1598020224,19901</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>这里成功间隔了一秒钟获取到结果。说明将任务提交线程池处理后，可以异步去执行其他任务，而不影响最后获取结果。</p><p>这样我们就实现了异步任务处理。</p><p>本文的内容重点还是异步任务处理，不在于语言，python只是为了帮助理解多线程、异步等原理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实现支持异步任务的线程池&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/08/13/linux3/image-20200814085740093.png&quot; alt=&quot;image-20200814085740093&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解python的同步原语&lt;/</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="Linux" scheme="http://123.57.158.5/tags/Linux/"/>
    
    <category term="操作系统" scheme="http://123.57.158.5/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="异步" scheme="http://123.57.158.5/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="线程池" scheme="http://123.57.158.5/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Flask框架入门</title>
    <link href="http://123.57.158.5/2020/08/05/flask1/"/>
    <id>http://123.57.158.5/2020/08/05/flask1/</id>
    <published>2020-08-05T04:02:45.000Z</published>
    <updated>2021-05-23T02:34:37.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flask微框架"><a href="#Flask微框架" class="headerlink" title="Flask微框架"></a>Flask微框架</h2><h3 id="认识FLask"><a href="#认识FLask" class="headerlink" title="认识FLask"></a>认识FLask</h3><p>Python实现的Web开发微框架，小而美，丰富的周边扩展</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv flask//创建虚拟环境</span><br><span class="line">pip install Flask//安装falsk</span><br><span class="line">workon 虚拟环境名//切换虚拟环境</span><br><span class="line">deactivate//退出虚拟环境</span><br></pre></td></tr></table></figure><h4 id="第一个Flask程序"><a href="#第一个Flask程序" class="headerlink" title="第一个Flask程序"></a>第一个Flask程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;hello_world&#x27;</span></span><br></pre></td></tr></table></figure><p>参数<code>__name__</code>解释：</p><p>表示Flask应用的主模块或包的名称。Flask使用该参数确定应用的位置，然后找到应用中其他文件的位置，如网页中的图片位置，模块目录</p><p>装饰器<code>app.route()</code>:</p><p>表示一个路由配置，即：用户在浏览器输入URL，使用对应的函数处理其中的业务逻辑</p><h3 id="MTV模型介绍"><a href="#MTV模型介绍" class="headerlink" title="MTV模型介绍"></a>MTV模型介绍</h3><p>模型（Model）</p><ul><li>Flask-PyMongo/Flask-MongoKit</li><li>Flask-SQLAlchemy</li></ul><p>视图（View）</p><ul><li>Flask-WTF/bootstrap-flask/Flask-Uploads</li></ul><p>模板（Template）</p><ul><li>Jinja2</li></ul><h3 id="Flask启动选项及调试"><a href="#Flask启动选项及调试" class="headerlink" title="Flask启动选项及调试"></a>Flask启动选项及调试</h3><p>步骤一：设置环境变量</p><p>先切换到Flask项目目录，将之前的代码保存到flasker.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows：set FLASK_APP=flasker.py</span><br><span class="line">Mac/Linux：export FLASK_APP=flasker.py</span><br></pre></td></tr></table></figure><p>步骤二：flask run启动内置web服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flask run --host=0.0.0.0 --port=8001 或者：</span><br><span class="line">flask run -h 0.0.0.0 -p 8001</span><br><span class="line">flask run //不指定端口 使用默认</span><br></pre></td></tr></table></figure><p>通过flask run -h 0.0.0.0 -p 8001启动之后，可通过电脑ip地址:8001（通过局域网访问）、127.0.0.1:8001、localhost:8001（后两者类似）访问</p><h4 id="开启调试模式"><a href="#开启调试模式" class="headerlink" title="开启调试模式"></a>开启调试模式</h4><p>步骤一：设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows：set FLASK_ENV=development</span><br><span class="line">Mac/Linux：export FLASK_ENV=development</span><br></pre></td></tr></table></figure><p>步骤二：flask run 启动内置web服务器</p><p>对于flask v1.0以前：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># flasker.py中添加</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>然后直接执行flasker.py</p><h2 id="URL配置及报文显示"><a href="#URL配置及报文显示" class="headerlink" title="URL配置及报文显示"></a>URL配置及报文显示</h2><h3 id="url配置及路由"><a href="#url配置及路由" class="headerlink" title="url配置及路由"></a>url配置及路由</h3><p>方式一：使用装饰器 method是请求方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params">url, methods</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 登录请求需要GET 和 POST两种请求</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传递参数</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/&lt;username&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="comment"># 指定参数类型</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/post/&lt;int:post_id&gt;&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><p>方式二：使用api配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.add_url_rule(url, url_name, view_name)</span><br></pre></td></tr></table></figure><p>url参数类型：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>接受任何不包括含斜杠的文本（默认值）</td></tr><tr><td>int</td><td>接受正整数</td></tr><tr><td>float</td><td>接受正浮点数</td></tr><tr><td>path</td><td>类似string，但可以包含斜杠</td></tr><tr><td>uuid</td><td>接受UUID字符串</td></tr></tbody></table><p>查看URL规则列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.url_map</span><br></pre></td></tr></table></figure><p>URL逆向解析（根据名称解析成URL字符串）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url_for(url_name,**kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态文件（js/css/图片）引用</span></span><br><span class="line">url_for(<span class="string">&#x27;static&#x27;</span>,filename=<span class="string">&#x27;style.css&#x27;</span>)</span><br></pre></td></tr></table></figure><p>pycharm 可以直接新建flask项目，（如果使用了虚拟环境）同时记得使用虚拟环境的python解释器。</p><p>pycharm - edit configurations 里面可以设置自定义的启动地址和端口号：</p><p><img src="/2020/08/05/flask1/image-20200805150851566.png" alt="image-20200805150851566"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! wdnmd&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入url值</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello/&lt;username&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(username)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入url的值为可选时,需要加入两个装饰器</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/page&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/page/&lt;page&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page</span>(<span class="params">page=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;this is page &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(page)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出现有url规则</span></span><br><span class="line"><span class="built_in">print</span>(app.url_map)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出了此时的url规则</span></span><br><span class="line"><span class="string">Map([&lt;Rule &#x27;/page&#x27; (HEAD, OPTIONS, GET) -&gt; page&gt;,</span></span><br><span class="line"><span class="string"> &lt;Rule &#x27;/&#x27; (HEAD, OPTIONS, GET) -&gt; hello_world&gt;,</span></span><br><span class="line"><span class="string"> &lt;Rule &#x27;/static/&lt;filename&gt;&#x27; (HEAD, OPTIONS, GET) -&gt; static&gt;,</span></span><br><span class="line"><span class="string"> &lt;Rule &#x27;/hello/&lt;username&gt;&#x27; (HEAD, OPTIONS, GET) -&gt; hello&gt;,</span></span><br><span class="line"><span class="string"> &lt;Rule &#x27;/page/&lt;page&gt;&#x27; (HEAD, OPTIONS, GET) -&gt; page&gt;])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="请求——响应及上下文对象"><a href="#请求——响应及上下文对象" class="headerlink" title="请求——响应及上下文对象"></a>请求——响应及上下文对象</h3><p>请求-响应：就是浏览器发送一个请求，服务器接收后返回相应的视图</p><p><strong>上下文对象</strong>:</p><p>上下文通俗的理解就是工作的环境</p><blockquote><p>每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。</p></blockquote><ul><li><p>应用上下文</p><p>应用指的是flask 的app</p></li><li><p>请求上下文</p></li><li><p>在分派请求之前激活应用上下文和请求上下文</p></li><li><p>在请求处理完成后将其删除</p></li></ul><p><strong>请求分派</strong>：就是分派 url对应视图</p><p><strong>应用上下文对象</strong>：</p><ul><li><p>current_app    当前应用的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,current_app</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(current_app)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! wdnmd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 &lt;Flask &#x27;app&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 这个app是flask中app.py,不是指的变量app</span></span><br></pre></td></tr></table></figure></li><li><p>g     处理请求时的临时存储对象，每次请求都会重设这个变量</p></li></ul><p><strong>请求上下文对象</strong>：</p><ul><li>request    请求对象，封装了客户端发出的HTTP请求中的内容</li><li>session    用户会话（dict），各请求之间的数据共享</li></ul><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>指的是请求上下文对象中的request</p><p><strong>请求报文常用参数：</strong></p><ul><li><p>method：请求的类型（GET/POST/OPTIONS等）</p></li><li><p>form：POST请求数据dict</p></li><li><p>args：GET请求数据dict</p></li><li><p>values: POST 和 GET请求数据集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取get请求参数</span></span><br><span class="line">request.args.get(<span class="string">&#x27;page&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">request.values.get(<span class="string">&#x27;page&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></li><li><p>files：上传的文件数据dict</p></li><li><p>cookies：请求中的cookie dict</p></li><li><p>headers：HTTP请求头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求头参数</span></span><br><span class="line">request.header</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Host: 127.0.0.1:8001</span></span><br><span class="line"><span class="string">Connection: keep-alive</span></span><br><span class="line"><span class="string">Cache-Control: max-age=0</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36 Edg/84.0.522.52</span></span><br><span class="line"><span class="string">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="string">Sec-Fetch-Site: none</span></span><br><span class="line"><span class="string">Sec-Fetch-Mode: navigate</span></span><br><span class="line"><span class="string">Sec-Fetch-User: ?1</span></span><br><span class="line"><span class="string">Sec-Fetch-Dest: document</span></span><br><span class="line"><span class="string">Accept-Encoding: gzip, deflate, br</span></span><br><span class="line"><span class="string">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span></span><br><span class="line"><span class="string">Cookie: csrftoken=mTn4iW7HqnMg40Px3VrnAnuUlhAnV76hwXulU3QeLL4jXHjWqfaISvClGv752MuN; sessionid=ezwv6ohgjt97jmg8yqjbhf8ygpubqvmy</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 获取项目部署地址</span></span><br><span class="line">request.header.get(<span class="string">&#x27;host&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 获取请求头</span></span><br><span class="line">request.header.get(<span class="string">&#x27;user-agent&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 获取用户请求的IP地址</span></span><br><span class="line">request.remote_addr</span><br></pre></td></tr></table></figure></li></ul><p>更多详见官方文档<a href="https://flask.palletsprojects.com/en/1.1.x/">https://flask.palletsprojects.com/en/1.1.x/</a></p><p>中文文档<a href="http://docs.jinkan.org/docs/flask/">http://docs.jinkan.org/docs/flask/</a></p><h4 id="请求钩子"><a href="#请求钩子" class="headerlink" title="请求钩子"></a>请求钩子</h4><p>如下场景如何实现：<br>    每个请求汇总都要验证用户信息（是否已登录、是否有权限访问）<br>    限制某些IP的恶意请求</p><p>使用钩子函数可以减少重复代码的编写，便于维护</p><ul><li>before_first_request    服务器初始化后第一个请求到达前执行</li><li>before_request    每一个请求到达前执行</li><li>after_request    每次请求处理完成后执行，如果请求过程中产生了异常，则不执行</li><li>teardown_request    每次请求处理完成后执行，如果请求过程中产生了异常也执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.before_first_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_request</span>():</span></span><br><span class="line"><span class="comment"># 第一个请求到来前执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;first_request&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_request</span>():</span></span><br><span class="line"><span class="comment"># 每次请求到来前执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;before_request&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求处理完后，响应给到浏览器，必须带参数</span></span><br><span class="line"><span class="meta">@app.after_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">after_request</span>(<span class="params">resp</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;after_request&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>响应可以是字符串，可以是元组，元组的格式为(response,status,headers)或(response,headers)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="comment"># 元组的格式为(response,status,headers)</span></span><br><span class="line">    <span class="comment"># 请求头为字典</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;找不到了&#x27;</span>, <span class="number">403</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;user_id&#x27;</span>: <span class="string">&#x27;abc123&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params"><span class="number">404</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_found</span>(<span class="params">err</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;自定义状态 404&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 打印错误信息</span></span><br><span class="line">    <span class="built_in">print</span>(err)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;您要的页面丢失了&#x27;</span></span><br></pre></td></tr></table></figure><p>响应元组：<br>response——响应内容<br>status——响应状态码<br>headers——响应头信息</p><p><code>make_response</code>可以用来获取响应对象然后对它进行修改</p><p><code>render_template</code>可以渲染html页面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="comment"># 构造一个响应对象</span></span><br><span class="line">    resp = make_response(</span><br><span class="line"><span class="string">&#x27;test&#x27;</span>, <span class="number">404</span>    </span><br><span class="line">    )</span><br><span class="line">    resp.headers[<span class="string">&#x27;token&#x27;</span>] = <span class="string">&#x27;my_token&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/html&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">html</span>():</span></span><br><span class="line">    <span class="comment"># 从templates文件夹中寻找test.html</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;test.html&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="重定向等内部视图"><a href="#重定向等内部视图" class="headerlink" title="重定向等内部视图"></a>重定向等内部视图</h3><p><code>redirect</code>实现重定向</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> redirect(<span class="string">&#x27;/url&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>abort</code>处理错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将视图状态吗改为404</span></span><br><span class="line">abort(<span class="number">404</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Flask微框架&quot;&gt;&lt;a href=&quot;#Flask微框架&quot; class=&quot;headerlink&quot; title=&quot;Flask微框架&quot;&gt;&lt;/a&gt;Flask微框架&lt;/h2&gt;&lt;h3 id=&quot;认识FLask&quot;&gt;&lt;a href=&quot;#认识FLask&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Python" scheme="http://123.57.158.5/categories/Python/"/>
    
    <category term="Flask" scheme="http://123.57.158.5/categories/Python/Flask/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="Flask" scheme="http://123.57.158.5/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Django安全及维护————以积分商城为例</title>
    <link href="http://123.57.158.5/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/"/>
    <id>http://123.57.158.5/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/</id>
    <published>2020-07-29T10:42:41.000Z</published>
    <updated>2021-05-23T02:34:36.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表单重复提交的问题"><a href="#表单重复提交的问题" class="headerlink" title="表单重复提交的问题"></a>表单重复提交的问题</h2><p>思考：</p><p>支付时，快速点击，多次提交会有什么问题？</p><p>快速多次点击会多次提交表单。比如注册页面多次点击之后会提示已注册，对用户来说不太友好。</p><p>CSRF（Cross-site request forgery）跨站请求伪造</p><blockquote><p>某些恶意网站上包含链接、表单提交按钮或者JavaScript，它们会利用登录过的用户在浏览器中的认证信息视图在你的网站上完成某些操作，这就是跨站请求伪造。</p><p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</strong>。</p></blockquote><p>对于上面的表单重复提交问题，解决思路与应对csrf攻击类似。</p><h3 id="使用CSRF保护（针对同步提交，比如注册页面）"><a href="#使用CSRF保护（针对同步提交，比如注册页面）" class="headerlink" title="使用CSRF保护（针对同步提交，比如注册页面）"></a>使用CSRF保护（针对同步提交，比如注册页面）</h3><ol><li><p>在MIDDLEWARE设置中激活CSRF中间件</p><p><code>django.middleware.csrf.CsrfViewMiddleware</code></p></li><li><p><code>&lt;form&gt;</code>元素中使用csrf_token标签（POST请求)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;.&quot;</span>&gt;</span></span><br><span class="line">&#123;% csrf_token %&#125;</span><br></pre></td></tr></table></figure></li><li><p>选择合适的渲染方式</p><p>视图函数中，确保使用RequestContext来渲染（或者render()函数）</p><p><img src="/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/image-20200730170138575.png" alt="image-20200730170138575"></p></li></ol><p>可以看到开启使用CSRF保护之后，浏览器源码会生成一个隐藏的表单域。这个表单中自动生成了唯一的value值（每一次request都会有不同的value值），提交表单时候会将其一并提交，因为value值唯一，就不会有重复提交的情况。</p><p><img src="/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/image-20200730170604352.png" alt="image-20200730170604352"></p><h3 id="表单双重提交问题"><a href="#表单双重提交问题" class="headerlink" title="表单双重提交问题"></a>表单双重提交问题</h3><p>解决了CSRF保护，之后积分商城还有一个关于表单提交的bug，就是双重提交的问题。但快速点击表单提交按钮时候，会发生数据库重复输入的报错，解决办法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;weui-content&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;.&quot;</span> <span class="attr">id</span>=<span class="string">&quot;form_id&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-btn weui-btn_warn&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;submit_button_id&#x27;</span>&gt;</span>注册并登陆<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">$( <span class="string">&quot;#submit_button_id&quot;</span> ).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">     <span class="comment">// jQuery prop() 方法设置或返回被选元素的属性和值。</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 当该方法用于返回属性值时，则返回第一个匹配元素的值。</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 当该方法用于设置属性值时，则为匹配元素集合设置一个或多个属性/值对。</span></span></span><br><span class="line"><span class="javascript">    $( <span class="string">&quot;#submit_button_id&quot;</span> ).prop(<span class="string">&#x27;disabled&#x27;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    $( <span class="string">&quot;#form_id&quot;</span> ).submit();</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="AJAX-POST请求使用CSRF保护（针对异步提交）"><a href="#AJAX-POST请求使用CSRF保护（针对异步提交）" class="headerlink" title="AJAX  POST请求使用CSRF保护（针对异步提交）"></a>AJAX  POST请求使用CSRF保护（针对异步提交）</h3><p><a href="https://docs.djangoproject.com/en/2.2/ref/csrf/">https://docs.djangoproject.com/en/2.2/ref/csrf/</a></p><p>对于添加购物车这种post请求 csrf保护 会产生报错或者添加失败，</p><p><img src="/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/image-20200730205220318.png" alt="image-20200730205220318"></p><p>解决办法如下：</p><ol><li><p>获取csrftoken</p><p>方式一：从Cookie获取csrftoken</p><p>项目设置中添加 <code>CSRF_USE_SESSIONS=False</code>，</p></li></ol><p><img src="/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/image-20200730204514846.png" alt="image-20200730204514846"></p><p>然后在到对应的html模板中添加jquery代码，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.cookie &amp;&amp; <span class="built_in">document</span>.cookie !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> cookie = cookies[i].trim();</span><br><span class="line">            <span class="comment">// Does this cookie string begin with the name we want?</span></span><br><span class="line">            <span class="keyword">if</span> (cookie.substring(<span class="number">0</span>, name.length + <span class="number">1</span>) === (name + <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">                cookieValue = <span class="built_in">decodeURIComponent</span>(cookie.substring(name.length + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> csrftoken = getCookie(<span class="string">&#x27;csrftoken&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​    方式二：从DOM获取csrftoken</p><p>​    项目设置中添加 CSRF_USE_SESSIONS=True，在html模板中添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//using jQuery</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> csrftoken = jQuery(<span class="string">&#x27;[name=csrfmiddlewaretoken]&#x27;</span>).val()</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在请求头设置token</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">csrfSafeMethod</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// these HTTP methods do not require CSRF protection</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="regexp">/^(GET|HEAD|OPTIONS|TRACE)$/</span>.test(method));</span><br><span class="line">&#125;</span><br><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">    <span class="attr">beforeSend</span>: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, settings</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!csrfSafeMethod(settings.type) &amp;&amp; !<span class="built_in">this</span>.crossDomain) &#123;</span><br><span class="line">            xhr.setRequestHeader(<span class="string">&quot;X-CSRFToken&quot;</span>, csrftoken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时 post请求可以成功提交而不会被拦截</p><h2 id="安全维护"><a href="#安全维护" class="headerlink" title="安全维护"></a>安全维护</h2><h3 id="bug邮件通知"><a href="#bug邮件通知" class="headerlink" title="bug邮件通知"></a>bug邮件通知</h3><ul><li><p>发送文字邮件</p></li><li><p>发送HTML邮件</p></li><li><p>发送带附件的邮件</p></li><li><p>发送多个邮件</p></li><li><p>打破连接限制，连接复用</p><p>譬如用户注册 绑定邮箱激活的页面，就可以只使用一个链接，通过用户名和密码登录该链接实现激活</p></li></ul><p>对于以上场景，实现方法类似，django2.2都有提供</p><p><a href="https://docs.djangoproject.com/en/2.2/topics/email/">https://docs.djangoproject.com/en/2.2/topics/email/</a></p><p>Django支持SMTP服务发送邮件，例如我们使用qq邮箱的SMTP服务，首先到qq邮箱找到SMTP服务设置指南，并且确保SMTP服务开启，然后生成授权码</p><blockquote><p>SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能跨越网络传输邮件，即“SMTP邮件中继”。</p><p><a href="https://baike.baidu.com/item/SMTP/175887?fr=aladdin">https://baike.baidu.com/item/SMTP/175887?fr=aladdin</a></p></blockquote><p><img src="/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/image-20200804115823944.png" alt="image-20200804115823944"></p><p><img src="/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/20090508_1_3.jpg" alt="img"></p><p>在项目中添加发送邮件配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 邮件发送配置</span></span><br><span class="line"><span class="comment"># 发送邮件的服务器</span></span><br><span class="line">EMAIL_HOST = <span class="string">&#x27;smtp.qq.com&#x27;</span></span><br><span class="line"><span class="comment"># 端口号EMAIL_PORT 默认25 不考虑加密情况可以不做设置。</span></span><br><span class="line"><span class="comment"># 你的邮箱名和STMP授权码</span></span><br><span class="line">EMAIL_HOST_USER = <span class="string">&#x27;jwei.gan@qq.com&#x27;</span></span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="普通邮件发送模板"><a href="#普通邮件发送模板" class="headerlink" title="普通邮件发送模板"></a>普通邮件发送模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"></span><br><span class="line">send_mail(</span><br><span class="line">    <span class="string">&#x27;Subject here&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Here is the message.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;from@example.com&#x27;</span>,</span><br><span class="line">    [<span class="string">&#x27;to@example.com&#x27;</span>],</span><br><span class="line">    fail_silently=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/image-20200804154820186.png" alt="image-20200804154820186"></p><h4 id="自动发送异常邮件到指定邮箱"><a href="#自动发送异常邮件到指定邮箱" class="headerlink" title="自动发送异常邮件到指定邮箱"></a>自动发送异常邮件到指定邮箱</h4><p>比如Django在项目中添加ADMINS设置，将可以发送报错的内容到管理者邮箱</p><blockquote><p><code>ADMINS</code></p><p>Default: <code>[]</code> (Empty list)</p><p>A list of all the people who get code error notifications. When <a href="https://docs.djangoproject.com/en/2.2/ref/settings/#std:setting-DEBUG"><code>DEBUG=False</code></a>（注：同时修改ALLOWED_HOST = [‘*’]） and <a href="https://docs.djangoproject.com/en/2.2/topics/logging/#django.utils.log.AdminEmailHandler"><code>AdminEmailHandler</code></a> is configured in <a href="https://docs.djangoproject.com/en/2.2/ref/settings/#std:setting-LOGGING"><code>LOGGING</code></a> (done by default), Django emails these people the details of exceptions raised in the request/response cycle.</p><p>(确保设置了关闭了debug模式)</p><p>Each item in the list should be a tuple of (Full name, email address). Example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;[(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;john@example.com&#x27;</span>), (<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;mary@example.com&#x27;</span>)]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADMINS = [(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;john@example.com&#x27;</span>), (<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;mary@example.com&#x27;</span>)]</span><br><span class="line"><span class="comment"># 配置发送邮件者</span></span><br><span class="line">SERVER_EMAIL = <span class="string">&#x27;jwei.gan@qq.com&#x27;</span></span><br></pre></td></tr></table></figure><p>然后在任意一个页面raise一个异常试试</p><p>就会自动收到异常的邮件</p><p><img src="/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/image-20200804155849068.png" alt="image-20200804155849068"></p><p>django2.2支持的其他邮件类型都可以查看django官方文档</p><h3 id="日志记录配置"><a href="#日志记录配置" class="headerlink" title="日志记录配置"></a>日志记录配置</h3><p>logging是一个python标准库</p><p>logging的四个部分（配置logging中很重要）：</p><ul><li><p>logger——日志记录入口</p><p>logger的级别：</p><ul><li>DEBUG：用于调试目的的底层系统信息</li><li>INFO: 普通的系统信息</li><li>WARNING： 警告，较小的问题，不影响执行顺序</li><li>ERROR: 错误，较大的问题</li><li>CRITICAL: 严重，致命的问题</li></ul><p>logger记录内容：</p><ul><li>django 记录所有内容</li><li>django.request 记录？（官方文档说是记录请求，但是使用后发现没有写入任何内容。。。</li><li>django.server 记录请求</li><li>django.template 记录与渲染模板相关的内容</li><li>django.db.backends 记录数据库操作</li><li>django.security.* 记录与安全相关的内容</li></ul></li><li><p>Handler——决定处理logger中消息的方式</p><p>比如写入文件‘log_file’，控制台输出’console‘，发送邮件’mail_admins’等等</p></li><li><p>Filters——对日志进行条件控制</p></li><li><p>Formatters——日志记录的文本顺序（格式）</p></li></ul><h4 id="在view视图中写入logging的方法"><a href="#在view视图中写入logging的方法" class="headerlink" title="在view视图中写入logging的方法"></a>在view视图中写入logging的方法</h4><p>确保切换到了debug模式，否则本地运行无法读取静态文件，服务器端运行则需要部署nginx。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import the logging library</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment"># Get an instance of a logger</span></span><br><span class="line"><span class="comment"># __name__对应django的记录模式，比如&#x27;django&#x27;等，也可以自定义，但是需要到设置中配置handler</span></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request, arg1, arg</span>):</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> bad_mojo:</span><br><span class="line"><span class="comment"># Log an error message</span></span><br><span class="line">logger.error(<span class="string">&#x27;Something went wrong!&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="日志记录配置-1"><a href="#日志记录配置-1" class="headerlink" title="日志记录配置"></a>日志记录配置</h4><ul><li>记录SQL日志，份文件存储、控制台打印</li><li>错误日志发送到邮件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 这是最普通Logging模板 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">LOGGING = &#123;</span><br><span class="line"><span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line"><span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 这里logger的操作为写入文件</span></span><br><span class="line"><span class="string">&#x27;log_file&#x27;</span>: &#123;</span><br><span class="line"><span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.FileHandler&#x27;</span>,</span><br><span class="line">            <span class="comment"># 在积分商城中我们使用的是&#x27;filename&#x27;: os.path.join(BASE_DIR,&#x27;log/debug.log&#x27;),</span></span><br><span class="line"><span class="string">&#x27;filename&#x27;</span>: <span class="string">&#x27;/path/to/django/debug.log&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 对应django的记录信息，‘django’是指默认记录信息</span></span><br><span class="line"><span class="string">&#x27;django&#x27;</span>: &#123;</span><br><span class="line"><span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;log_file&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 复杂的logging配置 配置原理在前面已经提到 官方文档中也可查 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="comment"># 格式化log的内容，然后在handler中配置</span></span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;&#123;levelname&#125; &#123;asctime&#125; &#123;module&#125; &#123;process:d&#125; &#123;thread:d&#125; &#123;message&#125;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;style&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;&#123;levelname&#125; &#123;message&#125;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;style&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># 过滤器 用于筛选记录内容的条件</span></span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;special&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;project.logging.SpecialFilter&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;require_debug_true&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;django.utils.log.RequireDebugTrue&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;require_debug_true&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;mail_admins&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;ERROR&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;django.utils.log.AdminEmailHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;special&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;django&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;django.request&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;mail_admins&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;ERROR&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;myproject.custom&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;mail_admins&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;special&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们要配置一个记录首页及SQL的log内容，该内容必须包含格式化的log数据（verbose）：</p><p>views:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="comment"># 设置一个专门的关于首页的log内容</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 首页视图 &quot;&quot;&quot;</span></span><br><span class="line">    logger.debug(<span class="string">&#x27;调试信息&#x27;</span>)</span><br><span class="line">    logger.info(<span class="string">&#x27;普通消息&#x27;</span>)</span><br><span class="line">    logger.error(<span class="string">&#x27;异常&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure><p>settings:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;&#123;levelname&#125; &#123;asctime&#125; &#123;module&#125; &#123;process:d&#125; &#123;thread:d&#125; &#123;message&#125;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;style&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;&#123;levelname&#125; &#123;message&#125;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;style&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 这里logger的操作为写入文件</span></span><br><span class="line">        <span class="string">&#x27;log_file&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.FileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;log/debug.log&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;verbose&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;mail_admins&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;ERROR&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;django.utils.log.AdminEmailHandler&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 对应django的记录信息</span></span><br><span class="line">        <span class="string">&#x27;django.db.backends&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;log_file&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;index&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;log_file&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后log的内容记录如下：</p><p><img src="/2020/07/29/Django%E5%AE%89%E5%85%A8%E5%8F%8A%E7%BB%B4%E6%8A%A4/image-20200804212013066.png" alt="image-20200804212013066"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;表单重复提交的问题&quot;&gt;&lt;a href=&quot;#表单重复提交的问题&quot; class=&quot;headerlink&quot; title=&quot;表单重复提交的问题&quot;&gt;&lt;/a&gt;表单重复提交的问题&lt;/h2&gt;&lt;p&gt;思考：&lt;/p&gt;
&lt;p&gt;支付时，快速点击，多次提交会有什么问题？&lt;/p&gt;
&lt;p&gt;快速多</summary>
      
    
    
    
    <category term="Python" scheme="http://123.57.158.5/categories/Python/"/>
    
    <category term="Django" scheme="http://123.57.158.5/categories/Python/Django/"/>
    
    
    <category term="Python" scheme="http://123.57.158.5/tags/Python/"/>
    
    <category term="Django" scheme="http://123.57.158.5/tags/Django/"/>
    
  </entry>
  
</feed>
